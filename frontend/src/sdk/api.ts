/* tslint:disable */
/* eslint-disable */
/**
 * Chatter API
 * # Advanced AI Chatbot Backend API Platform  A comprehensive Python-based backend API platform for building advanced AI chatbots, implemented with FastAPI, LangChain, LangGraph, Postgres, PGVector, and SQLAlchemy.  ## Features  ### Core API Features - **RESTful API** with FastAPI and OpenAPI/Swagger documentation - **Async-first architecture** with uvloop and hypercorn - **Streaming responses** for real-time LLM output - **Authentication** with JWT/OAuth2 and session management - **Rate limiting** and security validations - **Health checks** with `/healthz` and `/readyz` endpoints - **API versioning** with modular router architecture  ### LLM & AI Features - **LangChain integration** for LLM orchestration and chain management - **LangGraph workflows** for advanced conversation logic - **Multiple LLM providers** with pluggable architecture (OpenAI, Anthropic, etc.) - **Prompt management** with storage and versioning - **Tool calling** with MCP (Model Context Protocol) integration - **Multi-turn context** management and conversation history - **Profile management** for LLM parameters (temperature, top_k, etc.)  ### Vector Store & Knowledge Base - **Multiple vector stores** (PGVector, Pinecone, Qdrant, ChromaDB) - **Document processing** with unstructured data support - **Semantic search** and retrieval-augmented generation (RAG) - **Chunking strategies** for optimal retrieval - **Embedding management** with multiple providers  ### Data & Analytics - **Comprehensive analytics** for conversations, usage, and performance - **Cost tracking** and token usage monitoring - **User behavior analytics** and system health metrics - **Export capabilities** for reporting and analysis  ## Authentication  All API endpoints (except health checks and documentation) require authentication. Use the `/api/v1/auth/login` endpoint to obtain access tokens.  ## Rate Limiting  API requests are rate-limited. Check response headers for current limits.  ## SDK  A Python SDK is available for easy integration. See the SDK documentation for details.  ## Support  - GitHub: https://github.com/lllucius/chatter - Documentation: https://github.com/lllucius/chatter#readme - Issues: https://github.com/lllucius/chatter/issues
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: support@chatter.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Response schema for test actions (start, pause, complete).
 * @export
 * @interface ABTestActionResponse
 */
export interface ABTestActionResponse {
    /**
     * Whether action was successful
     * @type {boolean}
     * @memberof ABTestActionResponse
     */
    'success': boolean;
    /**
     * Action result message
     * @type {string}
     * @memberof ABTestActionResponse
     */
    'message': string;
    /**
     * Test ID
     * @type {string}
     * @memberof ABTestActionResponse
     */
    'test_id': string;
    /**
     * New test status
     * @type {TestStatus}
     * @memberof ABTestActionResponse
     */
    'new_status': TestStatus;
}


/**
 * Request schema for creating an A/B test.
 * @export
 * @interface ABTestCreateRequest
 */
export interface ABTestCreateRequest {
    /**
     * Test name
     * @type {string}
     * @memberof ABTestCreateRequest
     */
    'name': string;
    /**
     * Test description
     * @type {string}
     * @memberof ABTestCreateRequest
     */
    'description': string;
    /**
     * Type of test
     * @type {TestType}
     * @memberof ABTestCreateRequest
     */
    'test_type': TestType;
    /**
     * Allocation strategy
     * @type {VariantAllocation}
     * @memberof ABTestCreateRequest
     */
    'allocation_strategy': VariantAllocation;
    /**
     * Test variants
     * @type {Array<TestVariant>}
     * @memberof ABTestCreateRequest
     */
    'variants': Array<TestVariant>;
    /**
     * Metrics to track
     * @type {Array<MetricType>}
     * @memberof ABTestCreateRequest
     */
    'metrics': Array<MetricType>;
    /**
     * Test duration in days
     * @type {number}
     * @memberof ABTestCreateRequest
     */
    'duration_days'?: number;
    /**
     * Minimum sample size
     * @type {number}
     * @memberof ABTestCreateRequest
     */
    'min_sample_size'?: number;
    /**
     * Statistical confidence level
     * @type {number}
     * @memberof ABTestCreateRequest
     */
    'confidence_level'?: number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ABTestCreateRequest
     */
    'target_audience'?: { [key: string]: any; } | null;
    /**
     * Percentage of traffic to include
     * @type {number}
     * @memberof ABTestCreateRequest
     */
    'traffic_percentage'?: number;
    /**
     * Test tags
     * @type {Array<string>}
     * @memberof ABTestCreateRequest
     */
    'tags'?: Array<string>;
    /**
     * Additional metadata
     * @type {{ [key: string]: any; }}
     * @memberof ABTestCreateRequest
     */
    'metadata'?: { [key: string]: any; };
}


/**
 * Response schema for test deletion.
 * @export
 * @interface ABTestDeleteResponse
 */
export interface ABTestDeleteResponse {
    /**
     * Whether deletion was successful
     * @type {boolean}
     * @memberof ABTestDeleteResponse
     */
    'success': boolean;
    /**
     * Deletion result message
     * @type {string}
     * @memberof ABTestDeleteResponse
     */
    'message': string;
}
/**
 * Response schema for A/B test list.
 * @export
 * @interface ABTestListResponse
 */
export interface ABTestListResponse {
    /**
     * List of tests
     * @type {Array<ABTestResponse>}
     * @memberof ABTestListResponse
     */
    'tests': Array<ABTestResponse>;
    /**
     * Total number of tests
     * @type {number}
     * @memberof ABTestListResponse
     */
    'total': number;
}
/**
 * Response schema for A/B test metrics.
 * @export
 * @interface ABTestMetricsResponse
 */
export interface ABTestMetricsResponse {
    /**
     * Test ID
     * @type {string}
     * @memberof ABTestMetricsResponse
     */
    'test_id': string;
    /**
     * Current metrics
     * @type {Array<TestMetric>}
     * @memberof ABTestMetricsResponse
     */
    'metrics': Array<TestMetric>;
    /**
     * Current participant count
     * @type {number}
     * @memberof ABTestMetricsResponse
     */
    'participant_count': number;
    /**
     * Last metrics update
     * @type {string}
     * @memberof ABTestMetricsResponse
     */
    'last_updated': string;
}
/**
 * Response schema for A/B test data.
 * @export
 * @interface ABTestResponse
 */
export interface ABTestResponse {
    /**
     * Test ID
     * @type {string}
     * @memberof ABTestResponse
     */
    'id': string;
    /**
     * Test name
     * @type {string}
     * @memberof ABTestResponse
     */
    'name': string;
    /**
     * Test description
     * @type {string}
     * @memberof ABTestResponse
     */
    'description': string;
    /**
     * Type of test
     * @type {TestType}
     * @memberof ABTestResponse
     */
    'test_type': TestType;
    /**
     * Test status
     * @type {TestStatus}
     * @memberof ABTestResponse
     */
    'status': TestStatus;
    /**
     * Allocation strategy
     * @type {VariantAllocation}
     * @memberof ABTestResponse
     */
    'allocation_strategy': VariantAllocation;
    /**
     * Test variants
     * @type {Array<TestVariant>}
     * @memberof ABTestResponse
     */
    'variants': Array<TestVariant>;
    /**
     * Metrics being tracked
     * @type {Array<MetricType>}
     * @memberof ABTestResponse
     */
    'metrics': Array<MetricType>;
    /**
     * Test duration in days
     * @type {number}
     * @memberof ABTestResponse
     */
    'duration_days': number;
    /**
     * Minimum sample size
     * @type {number}
     * @memberof ABTestResponse
     */
    'min_sample_size': number;
    /**
     * Statistical confidence level
     * @type {number}
     * @memberof ABTestResponse
     */
    'confidence_level': number;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ABTestResponse
     */
    'target_audience'?: { [key: string]: any; } | null;
    /**
     * Percentage of traffic included
     * @type {number}
     * @memberof ABTestResponse
     */
    'traffic_percentage': number;
    /**
     * 
     * @type {string}
     * @memberof ABTestResponse
     */
    'start_date'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ABTestResponse
     */
    'end_date'?: string | null;
    /**
     * Number of participants
     * @type {number}
     * @memberof ABTestResponse
     */
    'participant_count'?: number;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof ABTestResponse
     */
    'created_at': string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof ABTestResponse
     */
    'updated_at': string;
    /**
     * Creator
     * @type {string}
     * @memberof ABTestResponse
     */
    'created_by': string;
    /**
     * Test tags
     * @type {Array<string>}
     * @memberof ABTestResponse
     */
    'tags': Array<string>;
    /**
     * Additional metadata
     * @type {{ [key: string]: any; }}
     * @memberof ABTestResponse
     */
    'metadata': { [key: string]: any; };
}


/**
 * Response schema for A/B test results.
 * @export
 * @interface ABTestResultsResponse
 */
export interface ABTestResultsResponse {
    /**
     * Test ID
     * @type {string}
     * @memberof ABTestResultsResponse
     */
    'test_id': string;
    /**
     * Test name
     * @type {string}
     * @memberof ABTestResultsResponse
     */
    'test_name': string;
    /**
     * Test status
     * @type {TestStatus}
     * @memberof ABTestResultsResponse
     */
    'status': TestStatus;
    /**
     * Metric results by variant
     * @type {Array<TestMetric>}
     * @memberof ABTestResultsResponse
     */
    'metrics': Array<TestMetric>;
    /**
     * Statistical significance by metric
     * @type {{ [key: string]: boolean; }}
     * @memberof ABTestResultsResponse
     */
    'statistical_significance': { [key: string]: boolean; };
    /**
     * Confidence intervals
     * @type {{ [key: string]: { [key: string]: Array<number>; }; }}
     * @memberof ABTestResultsResponse
     */
    'confidence_intervals': { [key: string]: { [key: string]: Array<number>; }; };
    /**
     * 
     * @type {string}
     * @memberof ABTestResultsResponse
     */
    'winning_variant'?: string | null;
    /**
     * Action recommendation
     * @type {string}
     * @memberof ABTestResultsResponse
     */
    'recommendation': string;
    /**
     * Results generation timestamp
     * @type {string}
     * @memberof ABTestResultsResponse
     */
    'generated_at': string;
    /**
     * Total sample size
     * @type {number}
     * @memberof ABTestResultsResponse
     */
    'sample_size': number;
    /**
     * Test duration so far
     * @type {number}
     * @memberof ABTestResultsResponse
     */
    'duration_days': number;
}


/**
 * Request schema for updating an A/B test.
 * @export
 * @interface ABTestUpdateRequest
 */
export interface ABTestUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ABTestUpdateRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ABTestUpdateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {TestStatus}
     * @memberof ABTestUpdateRequest
     */
    'status'?: TestStatus | null;
    /**
     * 
     * @type {number}
     * @memberof ABTestUpdateRequest
     */
    'duration_days'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ABTestUpdateRequest
     */
    'min_sample_size'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ABTestUpdateRequest
     */
    'confidence_level'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ABTestUpdateRequest
     */
    'traffic_percentage'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ABTestUpdateRequest
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ABTestUpdateRequest
     */
    'metadata'?: { [key: string]: any; } | null;
}


/**
 * Schema for API key creation.
 * @export
 * @interface APIKeyCreate
 */
export interface APIKeyCreate {
    /**
     * API key name
     * @type {string}
     * @memberof APIKeyCreate
     */
    'name': string;
}
/**
 * Schema for API key response.
 * @export
 * @interface APIKeyResponse
 */
export interface APIKeyResponse {
    /**
     * User ID
     * @type {string}
     * @memberof APIKeyResponse
     */
    'id': string;
    /**
     * API key
     * @type {string}
     * @memberof APIKeyResponse
     */
    'api_key': string;
    /**
     * API key name
     * @type {string}
     * @memberof APIKeyResponse
     */
    'api_key_name': string;
    /**
     * Creation date
     * @type {string}
     * @memberof APIKeyResponse
     */
    'created_at': string;
}
/**
 * Schema for API key revoke response.
 * @export
 * @interface APIKeyRevokeResponse
 */
export interface APIKeyRevokeResponse {
    /**
     * Success message
     * @type {string}
     * @memberof APIKeyRevokeResponse
     */
    'message': string;
}
/**
 * Schema for account deactivation response.
 * @export
 * @interface AccountDeactivateResponse
 */
export interface AccountDeactivateResponse {
    /**
     * Success message
     * @type {string}
     * @memberof AccountDeactivateResponse
     */
    'message': string;
}
/**
 * Agent capability definition.
 * @export
 * @interface AgentCapability
 */
export interface AgentCapability {
    /**
     * 
     * @type {string}
     * @memberof AgentCapability
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof AgentCapability
     */
    'description': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgentCapability
     */
    'required_tools'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgentCapability
     */
    'required_models'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof AgentCapability
     */
    'confidence_threshold'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AgentCapability
     */
    'enabled'?: boolean;
}
/**
 * Request schema for creating an agent.
 * @export
 * @interface AgentCreateRequest
 */
export interface AgentCreateRequest {
    /**
     * Agent name
     * @type {string}
     * @memberof AgentCreateRequest
     */
    'name': string;
    /**
     * Agent description
     * @type {string}
     * @memberof AgentCreateRequest
     */
    'description': string;
    /**
     * Type of agent
     * @type {AgentType}
     * @memberof AgentCreateRequest
     */
    'agent_type': AgentType;
    /**
     * System prompt for the agent
     * @type {string}
     * @memberof AgentCreateRequest
     */
    'system_prompt': string;
    /**
     * Agent personality traits
     * @type {Array<string>}
     * @memberof AgentCreateRequest
     */
    'personality_traits'?: Array<string>;
    /**
     * Knowledge domains
     * @type {Array<string>}
     * @memberof AgentCreateRequest
     */
    'knowledge_domains'?: Array<string>;
    /**
     * Response style
     * @type {string}
     * @memberof AgentCreateRequest
     */
    'response_style'?: string;
    /**
     * Agent capabilities
     * @type {Array<AgentCapability>}
     * @memberof AgentCreateRequest
     */
    'capabilities'?: Array<AgentCapability>;
    /**
     * Available tools
     * @type {Array<string>}
     * @memberof AgentCreateRequest
     */
    'available_tools'?: Array<string>;
    /**
     * Primary LLM provider
     * @type {string}
     * @memberof AgentCreateRequest
     */
    'primary_llm'?: string;
    /**
     * Fallback LLM provider
     * @type {string}
     * @memberof AgentCreateRequest
     */
    'fallback_llm'?: string;
    /**
     * Temperature for responses
     * @type {number}
     * @memberof AgentCreateRequest
     */
    'temperature'?: number;
    /**
     * Maximum tokens
     * @type {number}
     * @memberof AgentCreateRequest
     */
    'max_tokens'?: number;
    /**
     * Maximum conversation length
     * @type {number}
     * @memberof AgentCreateRequest
     */
    'max_conversation_length'?: number;
    /**
     * Context window size
     * @type {number}
     * @memberof AgentCreateRequest
     */
    'context_window_size'?: number;
    /**
     * Response timeout in seconds
     * @type {number}
     * @memberof AgentCreateRequest
     */
    'response_timeout'?: number;
    /**
     * Enable learning from feedback
     * @type {boolean}
     * @memberof AgentCreateRequest
     */
    'learning_enabled'?: boolean;
    /**
     * Weight for feedback learning
     * @type {number}
     * @memberof AgentCreateRequest
     */
    'feedback_weight'?: number;
    /**
     * Adaptation threshold
     * @type {number}
     * @memberof AgentCreateRequest
     */
    'adaptation_threshold'?: number;
    /**
     * Agent tags
     * @type {Array<string>}
     * @memberof AgentCreateRequest
     */
    'tags'?: Array<string>;
    /**
     * Additional metadata
     * @type {{ [key: string]: any; }}
     * @memberof AgentCreateRequest
     */
    'metadata'?: { [key: string]: any; };
}


/**
 * Response schema for agent deletion.
 * @export
 * @interface AgentDeleteResponse
 */
export interface AgentDeleteResponse {
    /**
     * Whether deletion was successful
     * @type {boolean}
     * @memberof AgentDeleteResponse
     */
    'success': boolean;
    /**
     * Deletion result message
     * @type {string}
     * @memberof AgentDeleteResponse
     */
    'message': string;
}
/**
 * Request schema for interacting with an agent.
 * @export
 * @interface AgentInteractRequest
 */
export interface AgentInteractRequest {
    /**
     * Message to send to the agent
     * @type {string}
     * @memberof AgentInteractRequest
     */
    'message': string;
    /**
     * Conversation ID
     * @type {string}
     * @memberof AgentInteractRequest
     */
    'conversation_id': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AgentInteractRequest
     */
    'context'?: { [key: string]: any; } | null;
}
/**
 * Response schema for agent interaction.
 * @export
 * @interface AgentInteractResponse
 */
export interface AgentInteractResponse {
    /**
     * Agent ID
     * @type {string}
     * @memberof AgentInteractResponse
     */
    'agent_id': string;
    /**
     * Agent response
     * @type {string}
     * @memberof AgentInteractResponse
     */
    'response': string;
    /**
     * Conversation ID
     * @type {string}
     * @memberof AgentInteractResponse
     */
    'conversation_id': string;
    /**
     * Tools used in response
     * @type {Array<string>}
     * @memberof AgentInteractResponse
     */
    'tools_used': Array<string>;
    /**
     * Confidence score
     * @type {number}
     * @memberof AgentInteractResponse
     */
    'confidence_score': number;
    /**
     * Response time in seconds
     * @type {number}
     * @memberof AgentInteractResponse
     */
    'response_time': number;
    /**
     * Response timestamp
     * @type {string}
     * @memberof AgentInteractResponse
     */
    'timestamp': string;
}
/**
 * Response schema for agent list.
 * @export
 * @interface AgentListResponse
 */
export interface AgentListResponse {
    /**
     * List of agents
     * @type {Array<AgentResponse>}
     * @memberof AgentListResponse
     */
    'agents': Array<AgentResponse>;
    /**
     * Total number of agents
     * @type {number}
     * @memberof AgentListResponse
     */
    'total': number;
}
/**
 * Response schema for agent data.
 * @export
 * @interface AgentResponse
 */
export interface AgentResponse {
    /**
     * Agent ID
     * @type {string}
     * @memberof AgentResponse
     */
    'id': string;
    /**
     * Agent name
     * @type {string}
     * @memberof AgentResponse
     */
    'name': string;
    /**
     * Agent description
     * @type {string}
     * @memberof AgentResponse
     */
    'description': string;
    /**
     * Type of agent
     * @type {AgentType}
     * @memberof AgentResponse
     */
    'agent_type': AgentType;
    /**
     * Agent status
     * @type {AgentStatus}
     * @memberof AgentResponse
     */
    'status': AgentStatus;
    /**
     * System prompt
     * @type {string}
     * @memberof AgentResponse
     */
    'system_prompt': string;
    /**
     * Agent personality traits
     * @type {Array<string>}
     * @memberof AgentResponse
     */
    'personality_traits': Array<string>;
    /**
     * Knowledge domains
     * @type {Array<string>}
     * @memberof AgentResponse
     */
    'knowledge_domains': Array<string>;
    /**
     * Response style
     * @type {string}
     * @memberof AgentResponse
     */
    'response_style': string;
    /**
     * Agent capabilities
     * @type {Array<AgentCapability>}
     * @memberof AgentResponse
     */
    'capabilities': Array<AgentCapability>;
    /**
     * Available tools
     * @type {Array<string>}
     * @memberof AgentResponse
     */
    'available_tools': Array<string>;
    /**
     * Primary LLM provider
     * @type {string}
     * @memberof AgentResponse
     */
    'primary_llm': string;
    /**
     * Fallback LLM provider
     * @type {string}
     * @memberof AgentResponse
     */
    'fallback_llm': string;
    /**
     * Temperature for responses
     * @type {number}
     * @memberof AgentResponse
     */
    'temperature': number;
    /**
     * Maximum tokens
     * @type {number}
     * @memberof AgentResponse
     */
    'max_tokens': number;
    /**
     * Maximum conversation length
     * @type {number}
     * @memberof AgentResponse
     */
    'max_conversation_length': number;
    /**
     * Context window size
     * @type {number}
     * @memberof AgentResponse
     */
    'context_window_size': number;
    /**
     * Response timeout in seconds
     * @type {number}
     * @memberof AgentResponse
     */
    'response_timeout': number;
    /**
     * Learning enabled
     * @type {boolean}
     * @memberof AgentResponse
     */
    'learning_enabled': boolean;
    /**
     * Feedback weight
     * @type {number}
     * @memberof AgentResponse
     */
    'feedback_weight': number;
    /**
     * Adaptation threshold
     * @type {number}
     * @memberof AgentResponse
     */
    'adaptation_threshold': number;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof AgentResponse
     */
    'created_at': string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof AgentResponse
     */
    'updated_at': string;
    /**
     * Creator
     * @type {string}
     * @memberof AgentResponse
     */
    'created_by': string;
    /**
     * Agent tags
     * @type {Array<string>}
     * @memberof AgentResponse
     */
    'tags': Array<string>;
    /**
     * Additional metadata
     * @type {{ [key: string]: any; }}
     * @memberof AgentResponse
     */
    'metadata': { [key: string]: any; };
}


/**
 * Response schema for agent statistics.
 * @export
 * @interface AgentStatsResponse
 */
export interface AgentStatsResponse {
    /**
     * Total number of agents
     * @type {number}
     * @memberof AgentStatsResponse
     */
    'total_agents': number;
    /**
     * Number of active agents
     * @type {number}
     * @memberof AgentStatsResponse
     */
    'active_agents': number;
    /**
     * Agents by type
     * @type {{ [key: string]: number; }}
     * @memberof AgentStatsResponse
     */
    'agent_types': { [key: string]: number; };
    /**
     * Total interactions across all agents
     * @type {number}
     * @memberof AgentStatsResponse
     */
    'total_interactions': number;
}
/**
 * Agent status.
 * @export
 * @enum {string}
 */

export const AgentStatus = {
    active: 'active',
    inactive: 'inactive',
    training: 'training',
    error: 'error',
    maintenance: 'maintenance'
} as const;

export type AgentStatus = typeof AgentStatus[keyof typeof AgentStatus];


/**
 * Types of AI agents.
 * @export
 * @enum {string}
 */

export const AgentType = {
    conversational: 'conversational',
    task_oriented: 'task_oriented',
    analytical: 'analytical',
    creative: 'creative',
    research: 'research',
    support: 'support',
    specialist: 'specialist'
} as const;

export type AgentType = typeof AgentType[keyof typeof AgentType];


/**
 * Request schema for updating an agent.
 * @export
 * @interface AgentUpdateRequest
 */
export interface AgentUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentUpdateRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AgentUpdateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AgentUpdateRequest
     */
    'system_prompt'?: string | null;
    /**
     * 
     * @type {AgentStatus}
     * @memberof AgentUpdateRequest
     */
    'status'?: AgentStatus | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgentUpdateRequest
     */
    'personality_traits'?: Array<string> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgentUpdateRequest
     */
    'knowledge_domains'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof AgentUpdateRequest
     */
    'response_style'?: string | null;
    /**
     * 
     * @type {Array<AgentCapability>}
     * @memberof AgentUpdateRequest
     */
    'capabilities'?: Array<AgentCapability> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgentUpdateRequest
     */
    'available_tools'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof AgentUpdateRequest
     */
    'primary_llm'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AgentUpdateRequest
     */
    'fallback_llm'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AgentUpdateRequest
     */
    'temperature'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AgentUpdateRequest
     */
    'max_tokens'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AgentUpdateRequest
     */
    'max_conversation_length'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AgentUpdateRequest
     */
    'context_window_size'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AgentUpdateRequest
     */
    'response_timeout'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof AgentUpdateRequest
     */
    'learning_enabled'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof AgentUpdateRequest
     */
    'feedback_weight'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof AgentUpdateRequest
     */
    'adaptation_threshold'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof AgentUpdateRequest
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof AgentUpdateRequest
     */
    'metadata'?: { [key: string]: any; } | null;
}


/**
 * Schema for available providers response.
 * @export
 * @interface AvailableProvidersResponse
 */
export interface AvailableProvidersResponse {
    /**
     * Available LLM providers with their configurations
     * @type {{ [key: string]: any; }}
     * @memberof AvailableProvidersResponse
     */
    'providers': { [key: string]: any; };
    /**
     * Total number of available providers
     * @type {number}
     * @memberof AvailableProvidersResponse
     */
    'total_providers': number;
    /**
     * Features supported by each provider
     * @type {{ [key: string]: Array<string>; }}
     * @memberof AvailableProvidersResponse
     */
    'supported_features': { [key: string]: Array<string>; };
}
/**
 * Schema for individual available tool.
 * @export
 * @interface AvailableToolResponse
 */
export interface AvailableToolResponse {
    /**
     * Tool name
     * @type {string}
     * @memberof AvailableToolResponse
     */
    'name': string;
    /**
     * Tool description
     * @type {string}
     * @memberof AvailableToolResponse
     */
    'description': string;
    /**
     * Tool type (mcp, builtin)
     * @type {string}
     * @memberof AvailableToolResponse
     */
    'type': string;
    /**
     * Tool arguments schema
     * @type {{ [key: string]: any; }}
     * @memberof AvailableToolResponse
     */
    'args_schema': { [key: string]: any; };
}
/**
 * Schema for available tools response.
 * @export
 * @interface AvailableToolsResponse
 */
export interface AvailableToolsResponse {
    /**
     * Available tools
     * @type {Array<AvailableToolResponse>}
     * @memberof AvailableToolsResponse
     */
    'tools': Array<AvailableToolResponse>;
}
/**
 * Response schema for backup list.
 * @export
 * @interface BackupListResponse
 */
export interface BackupListResponse {
    /**
     * List of backups
     * @type {Array<BackupResponse>}
     * @memberof BackupListResponse
     */
    'backups': Array<BackupResponse>;
    /**
     * Total number of backups
     * @type {number}
     * @memberof BackupListResponse
     */
    'total': number;
}
/**
 * Request schema for creating a backup via API.
 * @export
 * @interface BackupRequest
 */
export interface BackupRequest {
    /**
     * Backup type
     * @type {BackupType}
     * @memberof BackupRequest
     */
    'backup_type'?: BackupType;
    /**
     * 
     * @type {string}
     * @memberof BackupRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BackupRequest
     */
    'description'?: string | null;
    /**
     * Include uploaded files
     * @type {boolean}
     * @memberof BackupRequest
     */
    'include_files'?: boolean;
    /**
     * Include system logs
     * @type {boolean}
     * @memberof BackupRequest
     */
    'include_logs'?: boolean;
    /**
     * Compress backup
     * @type {boolean}
     * @memberof BackupRequest
     */
    'compress'?: boolean;
    /**
     * Encrypt backup
     * @type {boolean}
     * @memberof BackupRequest
     */
    'encrypt'?: boolean;
    /**
     * Backup retention in days
     * @type {number}
     * @memberof BackupRequest
     */
    'retention_days'?: number;
}


/**
 * Response schema for backup data.
 * @export
 * @interface BackupResponse
 */
export interface BackupResponse {
    /**
     * Backup ID
     * @type {string}
     * @memberof BackupResponse
     */
    'id': string;
    /**
     * Backup name
     * @type {string}
     * @memberof BackupResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof BackupResponse
     */
    'description'?: string | null;
    /**
     * Backup type
     * @type {BackupType}
     * @memberof BackupResponse
     */
    'backup_type': BackupType;
    /**
     * Backup status
     * @type {string}
     * @memberof BackupResponse
     */
    'status': string;
    /**
     * 
     * @type {number}
     * @memberof BackupResponse
     */
    'file_size'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BackupResponse
     */
    'compressed_size'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof BackupResponse
     */
    'record_count'?: number | null;
    /**
     * Backup creation timestamp
     * @type {string}
     * @memberof BackupResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof BackupResponse
     */
    'completed_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BackupResponse
     */
    'expires_at'?: string | null;
    /**
     * Whether backup is encrypted
     * @type {boolean}
     * @memberof BackupResponse
     */
    'encrypted': boolean;
    /**
     * Whether backup is compressed
     * @type {boolean}
     * @memberof BackupResponse
     */
    'compressed': boolean;
    /**
     * Backup metadata
     * @type {{ [key: string]: any; }}
     * @memberof BackupResponse
     */
    'metadata': { [key: string]: any; };
}


/**
 * Types of backups.
 * @export
 * @enum {string}
 */

export const BackupType = {
    full: 'full',
    incremental: 'incremental',
    differential: 'differential'
} as const;

export type BackupType = typeof BackupType[keyof typeof BackupType];


/**
 * Schema for bulk operation results.
 * @export
 * @interface BulkOperationResult
 */
export interface BulkOperationResult {
    /**
     * Total servers requested
     * @type {number}
     * @memberof BulkOperationResult
     */
    'total_requested': number;
    /**
     * Successfully processed
     * @type {number}
     * @memberof BulkOperationResult
     */
    'successful': number;
    /**
     * Failed to process
     * @type {number}
     * @memberof BulkOperationResult
     */
    'failed': number;
    /**
     * Detailed results
     * @type {Array<{ [key: string]: any; } | null>}
     * @memberof BulkOperationResult
     */
    'results': Array<{ [key: string]: any; } | null>;
    /**
     * Error messages
     * @type {Array<string>}
     * @memberof BulkOperationResult
     */
    'errors'?: Array<string>;
}
/**
 * Schema for bulk operations on tool servers.
 * @export
 * @interface BulkToolServerOperation
 */
export interface BulkToolServerOperation {
    /**
     * List of server IDs
     * @type {Array<string>}
     * @memberof BulkToolServerOperation
     */
    'server_ids': Array<string>;
    /**
     * Operation to perform
     * @type {string}
     * @memberof BulkToolServerOperation
     */
    'operation': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof BulkToolServerOperation
     */
    'parameters'?: { [key: string]: any; } | null;
}
/**
 * Schema for chat request.
 * @export
 * @interface ChatRequest
 */
export interface ChatRequest {
    /**
     * User message
     * @type {string}
     * @memberof ChatRequest
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof ChatRequest
     */
    'conversation_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ChatRequest
     */
    'profile_id'?: string | null;
    /**
     * Enable streaming response
     * @type {boolean}
     * @memberof ChatRequest
     */
    'stream'?: boolean;
    /**
     * Workflow type: plain, rag, tools, or full (rag + tools)
     * @type {string}
     * @memberof ChatRequest
     */
    'workflow'?: ChatRequestWorkflow;
    /**
     * 
     * @type {string}
     * @memberof ChatRequest
     */
    'provider'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ChatRequest
     */
    'temperature'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ChatRequest
     */
    'max_tokens'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ChatRequest
     */
    'enable_retrieval'?: boolean | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ChatRequest
     */
    'document_ids'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ChatRequest
     */
    'system_prompt_override'?: string | null;
}

export const ChatRequestWorkflow = {
    plain: 'plain',
    rag: 'rag',
    tools: 'tools',
    full: 'full'
} as const;

export type ChatRequestWorkflow = typeof ChatRequestWorkflow[keyof typeof ChatRequestWorkflow];

/**
 * Schema for chat response.
 * @export
 * @interface ChatResponse
 */
export interface ChatResponse {
    /**
     * Conversation ID
     * @type {string}
     * @memberof ChatResponse
     */
    'conversation_id': string;
    /**
     * Assistant response message
     * @type {object}
     * @memberof ChatResponse
     */
    'message': object;
    /**
     * Updated conversation
     * @type {object}
     * @memberof ChatResponse
     */
    'conversation': object;
}
/**
 * Schema for creating a conversation.
 * @export
 * @interface ConversationCreate
 */
export interface ConversationCreate {
    /**
     * Conversation title
     * @type {string}
     * @memberof ConversationCreate
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ConversationCreate
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationCreate
     */
    'profile_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationCreate
     */
    'system_prompt'?: string | null;
    /**
     * Enable document retrieval
     * @type {boolean}
     * @memberof ConversationCreate
     */
    'enable_retrieval'?: boolean;
}
/**
 * Schema for conversation delete response.
 * @export
 * @interface ConversationDeleteResponse
 */
export interface ConversationDeleteResponse {
    /**
     * Success message
     * @type {string}
     * @memberof ConversationDeleteResponse
     */
    'message': string;
}
/**
 * Schema for conversation response.
 * @export
 * @interface ConversationResponse
 */
export interface ConversationResponse {
    /**
     * Conversation title
     * @type {string}
     * @memberof ConversationResponse
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ConversationResponse
     */
    'description'?: string | null;
    /**
     * Conversation ID
     * @type {string}
     * @memberof ConversationResponse
     */
    'id': string;
    /**
     * User ID
     * @type {string}
     * @memberof ConversationResponse
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof ConversationResponse
     */
    'profile_id'?: string | null;
    /**
     * Conversation status
     * @type {ConversationStatus}
     * @memberof ConversationResponse
     */
    'status': ConversationStatus;
    /**
     * 
     * @type {string}
     * @memberof ConversationResponse
     */
    'llm_provider'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationResponse
     */
    'llm_model'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ConversationResponse
     */
    'temperature'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ConversationResponse
     */
    'max_tokens'?: number | null;
    /**
     * Retrieval enabled
     * @type {boolean}
     * @memberof ConversationResponse
     */
    'enable_retrieval': boolean;
    /**
     * Number of messages
     * @type {number}
     * @memberof ConversationResponse
     */
    'message_count': number;
    /**
     * Total tokens used
     * @type {number}
     * @memberof ConversationResponse
     */
    'total_tokens': number;
    /**
     * Total cost
     * @type {number}
     * @memberof ConversationResponse
     */
    'total_cost': number;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof ConversationResponse
     */
    'created_at': string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof ConversationResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof ConversationResponse
     */
    'last_message_at'?: string | null;
}


/**
 * Schema for conversation search response.
 * @export
 * @interface ConversationSearchResponse
 */
export interface ConversationSearchResponse {
    /**
     * Conversations
     * @type {Array<ConversationResponse>}
     * @memberof ConversationSearchResponse
     */
    'conversations': Array<ConversationResponse>;
    /**
     * Total number of conversations
     * @type {number}
     * @memberof ConversationSearchResponse
     */
    'total': number;
    /**
     * Request limit
     * @type {number}
     * @memberof ConversationSearchResponse
     */
    'limit': number;
    /**
     * Request offset
     * @type {number}
     * @memberof ConversationSearchResponse
     */
    'offset': number;
}
/**
 * Schema for conversation statistics response.
 * @export
 * @interface ConversationStatsResponse
 */
export interface ConversationStatsResponse {
    /**
     * Total number of conversations
     * @type {number}
     * @memberof ConversationStatsResponse
     */
    'total_conversations': number;
    /**
     * Conversations grouped by status
     * @type {{ [key: string]: number; }}
     * @memberof ConversationStatsResponse
     */
    'conversations_by_status': { [key: string]: number; };
    /**
     * Total number of messages
     * @type {number}
     * @memberof ConversationStatsResponse
     */
    'total_messages': number;
    /**
     * Messages grouped by role
     * @type {{ [key: string]: number; }}
     * @memberof ConversationStatsResponse
     */
    'messages_by_role': { [key: string]: number; };
    /**
     * Average messages per conversation
     * @type {number}
     * @memberof ConversationStatsResponse
     */
    'avg_messages_per_conversation': number;
    /**
     * Total tokens used
     * @type {number}
     * @memberof ConversationStatsResponse
     */
    'total_tokens_used': number;
    /**
     * Total cost incurred
     * @type {number}
     * @memberof ConversationStatsResponse
     */
    'total_cost': number;
    /**
     * Average response time in milliseconds
     * @type {number}
     * @memberof ConversationStatsResponse
     */
    'avg_response_time_ms': number;
    /**
     * Conversations by date
     * @type {{ [key: string]: number; }}
     * @memberof ConversationStatsResponse
     */
    'conversations_by_date': { [key: string]: number; };
    /**
     * Most active hours
     * @type {{ [key: string]: number; }}
     * @memberof ConversationStatsResponse
     */
    'most_active_hours': { [key: string]: number; };
    /**
     * Popular LLM models
     * @type {{ [key: string]: number; }}
     * @memberof ConversationStatsResponse
     */
    'popular_models': { [key: string]: number; };
    /**
     * Popular LLM providers
     * @type {{ [key: string]: number; }}
     * @memberof ConversationStatsResponse
     */
    'popular_providers': { [key: string]: number; };
}
/**
 * Enumeration for conversation status.
 * @export
 * @enum {string}
 */

export const ConversationStatus = {
    active: 'active',
    archived: 'archived',
    deleted: 'deleted'
} as const;

export type ConversationStatus = typeof ConversationStatus[keyof typeof ConversationStatus];


/**
 * Schema for updating a conversation.
 * @export
 * @interface ConversationUpdate
 */
export interface ConversationUpdate {
    /**
     * 
     * @type {string}
     * @memberof ConversationUpdate
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {ConversationStatus}
     * @memberof ConversationUpdate
     */
    'status'?: ConversationStatus | null;
}


/**
 * Schema for conversation with messages.
 * @export
 * @interface ConversationWithMessages
 */
export interface ConversationWithMessages {
    /**
     * Conversation title
     * @type {string}
     * @memberof ConversationWithMessages
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ConversationWithMessages
     */
    'description'?: string | null;
    /**
     * Conversation ID
     * @type {string}
     * @memberof ConversationWithMessages
     */
    'id': string;
    /**
     * User ID
     * @type {string}
     * @memberof ConversationWithMessages
     */
    'user_id': string;
    /**
     * 
     * @type {string}
     * @memberof ConversationWithMessages
     */
    'profile_id'?: string | null;
    /**
     * Conversation status
     * @type {ConversationStatus}
     * @memberof ConversationWithMessages
     */
    'status': ConversationStatus;
    /**
     * 
     * @type {string}
     * @memberof ConversationWithMessages
     */
    'llm_provider'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ConversationWithMessages
     */
    'llm_model'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ConversationWithMessages
     */
    'temperature'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ConversationWithMessages
     */
    'max_tokens'?: number | null;
    /**
     * Retrieval enabled
     * @type {boolean}
     * @memberof ConversationWithMessages
     */
    'enable_retrieval': boolean;
    /**
     * Number of messages
     * @type {number}
     * @memberof ConversationWithMessages
     */
    'message_count': number;
    /**
     * Total tokens used
     * @type {number}
     * @memberof ConversationWithMessages
     */
    'total_tokens': number;
    /**
     * Total cost
     * @type {number}
     * @memberof ConversationWithMessages
     */
    'total_cost': number;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof ConversationWithMessages
     */
    'created_at': string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof ConversationWithMessages
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof ConversationWithMessages
     */
    'last_message_at'?: string | null;
    /**
     * Conversation messages
     * @type {Array<MessageResponse>}
     * @memberof ConversationWithMessages
     */
    'messages'?: Array<MessageResponse>;
}


/**
 * Schema for analytics dashboard response.
 * @export
 * @interface DashboardResponse
 */
export interface DashboardResponse {
    /**
     * Conversation statistics
     * @type {ConversationStatsResponse}
     * @memberof DashboardResponse
     */
    'conversation_stats': ConversationStatsResponse;
    /**
     * Usage metrics
     * @type {UsageMetricsResponse}
     * @memberof DashboardResponse
     */
    'usage_metrics': UsageMetricsResponse;
    /**
     * Performance metrics
     * @type {PerformanceMetricsResponse}
     * @memberof DashboardResponse
     */
    'performance_metrics': PerformanceMetricsResponse;
    /**
     * Document analytics
     * @type {DocumentAnalyticsResponse}
     * @memberof DashboardResponse
     */
    'document_analytics': DocumentAnalyticsResponse;
    /**
     * System health metrics
     * @type {SystemAnalyticsResponse}
     * @memberof DashboardResponse
     */
    'system_health': SystemAnalyticsResponse;
    /**
     * Custom metrics
     * @type {Array<{ [key: string]: any; } | null>}
     * @memberof DashboardResponse
     */
    'custom_metrics': Array<{ [key: string]: any; } | null>;
    /**
     * Dashboard generation time
     * @type {string}
     * @memberof DashboardResponse
     */
    'generated_at': string;
}
/**
 * Supported data formats.
 * @export
 * @enum {string}
 */

export const DataFormat = {
    json: 'json',
    csv: 'csv',
    xml: 'xml',
    parquet: 'parquet',
    sql: 'sql'
} as const;

export type DataFormat = typeof DataFormat[keyof typeof DataFormat];


/**
 * Schema for document analytics response.
 * @export
 * @interface DocumentAnalyticsResponse
 */
export interface DocumentAnalyticsResponse {
    /**
     * Total number of documents
     * @type {number}
     * @memberof DocumentAnalyticsResponse
     */
    'total_documents': number;
    /**
     * Documents by processing status
     * @type {{ [key: string]: number; }}
     * @memberof DocumentAnalyticsResponse
     */
    'documents_by_status': { [key: string]: number; };
    /**
     * Documents by file type
     * @type {{ [key: string]: number; }}
     * @memberof DocumentAnalyticsResponse
     */
    'documents_by_type': { [key: string]: number; };
    /**
     * Average processing time
     * @type {number}
     * @memberof DocumentAnalyticsResponse
     */
    'avg_processing_time_seconds': number;
    /**
     * Processing success rate
     * @type {number}
     * @memberof DocumentAnalyticsResponse
     */
    'processing_success_rate': number;
    /**
     * Total number of chunks
     * @type {number}
     * @memberof DocumentAnalyticsResponse
     */
    'total_chunks': number;
    /**
     * Average chunks per document
     * @type {number}
     * @memberof DocumentAnalyticsResponse
     */
    'avg_chunks_per_document': number;
    /**
     * Total storage used
     * @type {number}
     * @memberof DocumentAnalyticsResponse
     */
    'total_storage_bytes': number;
    /**
     * Average document size
     * @type {number}
     * @memberof DocumentAnalyticsResponse
     */
    'avg_document_size_bytes': number;
    /**
     * Storage usage by document type
     * @type {{ [key: string]: number; }}
     * @memberof DocumentAnalyticsResponse
     */
    'storage_by_type': { [key: string]: number; };
    /**
     * Total number of searches
     * @type {number}
     * @memberof DocumentAnalyticsResponse
     */
    'total_searches': number;
    /**
     * Average search results returned
     * @type {number}
     * @memberof DocumentAnalyticsResponse
     */
    'avg_search_results': number;
    /**
     * Popular search terms
     * @type {{ [key: string]: number; }}
     * @memberof DocumentAnalyticsResponse
     */
    'popular_search_terms': { [key: string]: number; };
    /**
     * Total document views
     * @type {number}
     * @memberof DocumentAnalyticsResponse
     */
    'total_views': number;
    /**
     * Most viewed documents
     * @type {Array<{ [key: string]: any; } | null>}
     * @memberof DocumentAnalyticsResponse
     */
    'most_viewed_documents': Array<{ [key: string]: any; } | null>;
    /**
     * Documents by access level
     * @type {{ [key: string]: number; }}
     * @memberof DocumentAnalyticsResponse
     */
    'documents_by_access_level': { [key: string]: number; };
}
/**
 * Schema for document chunk response.
 * @export
 * @interface DocumentChunkResponse
 */
export interface DocumentChunkResponse {
    /**
     * Chunk ID
     * @type {string}
     * @memberof DocumentChunkResponse
     */
    'id': string;
    /**
     * Document ID
     * @type {string}
     * @memberof DocumentChunkResponse
     */
    'document_id': string;
    /**
     * Chunk content
     * @type {string}
     * @memberof DocumentChunkResponse
     */
    'content': string;
    /**
     * Chunk index
     * @type {number}
     * @memberof DocumentChunkResponse
     */
    'chunk_index': number;
    /**
     * 
     * @type {number}
     * @memberof DocumentChunkResponse
     */
    'start_char'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentChunkResponse
     */
    'end_char'?: number | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DocumentChunkResponse
     */
    'extra_metadata'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentChunkResponse
     */
    'token_count'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentChunkResponse
     */
    'language'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentChunkResponse
     */
    'embedding_model'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentChunkResponse
     */
    'embedding_provider'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentChunkResponse
     */
    'embedding_created_at'?: string | null;
    /**
     * Content hash
     * @type {string}
     * @memberof DocumentChunkResponse
     */
    'content_hash': string;
    /**
     * Whether chunk has embedding
     * @type {boolean}
     * @memberof DocumentChunkResponse
     */
    'has_embedding': boolean;
    /**
     * Creation time
     * @type {string}
     * @memberof DocumentChunkResponse
     */
    'created_at': string;
    /**
     * Last update time
     * @type {string}
     * @memberof DocumentChunkResponse
     */
    'updated_at': string;
}
/**
 * Schema for document chunks response with pagination.
 * @export
 * @interface DocumentChunksResponse
 */
export interface DocumentChunksResponse {
    /**
     * List of document chunks
     * @type {Array<DocumentChunkResponse>}
     * @memberof DocumentChunksResponse
     */
    'chunks': Array<DocumentChunkResponse>;
    /**
     * Total number of chunks
     * @type {number}
     * @memberof DocumentChunksResponse
     */
    'total_count': number;
    /**
     * Applied limit
     * @type {number}
     * @memberof DocumentChunksResponse
     */
    'limit': number;
    /**
     * Applied offset
     * @type {number}
     * @memberof DocumentChunksResponse
     */
    'offset': number;
}
/**
 * Schema for document list response.
 * @export
 * @interface DocumentListResponse
 */
export interface DocumentListResponse {
    /**
     * List of documents
     * @type {Array<DocumentResponse>}
     * @memberof DocumentListResponse
     */
    'documents': Array<DocumentResponse>;
    /**
     * Total number of documents
     * @type {number}
     * @memberof DocumentListResponse
     */
    'total_count': number;
    /**
     * Applied limit
     * @type {number}
     * @memberof DocumentListResponse
     */
    'limit': number;
    /**
     * Applied offset
     * @type {number}
     * @memberof DocumentListResponse
     */
    'offset': number;
}
/**
 * Schema for document processing request.
 * @export
 * @interface DocumentProcessingRequest
 */
export interface DocumentProcessingRequest {
    /**
     * Force reprocessing
     * @type {boolean}
     * @memberof DocumentProcessingRequest
     */
    'reprocess'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DocumentProcessingRequest
     */
    'chunk_size'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DocumentProcessingRequest
     */
    'chunk_overlap'?: number | null;
    /**
     * Generate embeddings for chunks
     * @type {boolean}
     * @memberof DocumentProcessingRequest
     */
    'generate_embeddings'?: boolean;
}
/**
 * Schema for document processing response.
 * @export
 * @interface DocumentProcessingResponse
 */
export interface DocumentProcessingResponse {
    /**
     * Document ID
     * @type {string}
     * @memberof DocumentProcessingResponse
     */
    'document_id': string;
    /**
     * Processing status
     * @type {DocumentStatus}
     * @memberof DocumentProcessingResponse
     */
    'status': DocumentStatus;
    /**
     * Status message
     * @type {string}
     * @memberof DocumentProcessingResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof DocumentProcessingResponse
     */
    'processing_started_at'?: string | null;
}


/**
 * Schema for document response.
 * @export
 * @interface DocumentResponse
 */
export interface DocumentResponse {
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentResponse
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DocumentResponse
     */
    'extra_metadata'?: { [key: string]: any; } | null;
    /**
     * Whether document is public
     * @type {boolean}
     * @memberof DocumentResponse
     */
    'is_public'?: boolean;
    /**
     * Document ID
     * @type {string}
     * @memberof DocumentResponse
     */
    'id': string;
    /**
     * Owner user ID
     * @type {string}
     * @memberof DocumentResponse
     */
    'owner_id': string;
    /**
     * Document filename
     * @type {string}
     * @memberof DocumentResponse
     */
    'filename': string;
    /**
     * Original filename
     * @type {string}
     * @memberof DocumentResponse
     */
    'original_filename': string;
    /**
     * File size in bytes
     * @type {number}
     * @memberof DocumentResponse
     */
    'file_size': number;
    /**
     * File hash (SHA-256)
     * @type {string}
     * @memberof DocumentResponse
     */
    'file_hash': string;
    /**
     * MIME type
     * @type {string}
     * @memberof DocumentResponse
     */
    'mime_type': string;
    /**
     * Document type
     * @type {DocumentType}
     * @memberof DocumentResponse
     */
    'document_type': DocumentType;
    /**
     * Processing status
     * @type {DocumentStatus}
     * @memberof DocumentResponse
     */
    'status': DocumentStatus;
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    'processing_started_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    'processing_completed_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    'processing_error'?: string | null;
    /**
     * Chunk size
     * @type {number}
     * @memberof DocumentResponse
     */
    'chunk_size': number;
    /**
     * Chunk overlap
     * @type {number}
     * @memberof DocumentResponse
     */
    'chunk_overlap': number;
    /**
     * Number of chunks
     * @type {number}
     * @memberof DocumentResponse
     */
    'chunk_count': number;
    /**
     * Document version
     * @type {number}
     * @memberof DocumentResponse
     */
    'version': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    'parent_document_id'?: string | null;
    /**
     * View count
     * @type {number}
     * @memberof DocumentResponse
     */
    'view_count': number;
    /**
     * Search count
     * @type {number}
     * @memberof DocumentResponse
     */
    'search_count': number;
    /**
     * 
     * @type {string}
     * @memberof DocumentResponse
     */
    'last_accessed_at'?: string | null;
    /**
     * Creation time
     * @type {string}
     * @memberof DocumentResponse
     */
    'created_at': string;
    /**
     * Last update time
     * @type {string}
     * @memberof DocumentResponse
     */
    'updated_at': string;
}


/**
 * Schema for document search request.
 * @export
 * @interface DocumentSearchRequest
 */
export interface DocumentSearchRequest {
    /**
     * Search query
     * @type {string}
     * @memberof DocumentSearchRequest
     */
    'query': string;
    /**
     * Maximum number of results
     * @type {number}
     * @memberof DocumentSearchRequest
     */
    'limit'?: number;
    /**
     * Minimum similarity score
     * @type {number}
     * @memberof DocumentSearchRequest
     */
    'score_threshold'?: number;
    /**
     * 
     * @type {Array<DocumentType>}
     * @memberof DocumentSearchRequest
     */
    'document_types'?: Array<DocumentType> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentSearchRequest
     */
    'tags'?: Array<string> | null;
    /**
     * Include document content in results
     * @type {boolean}
     * @memberof DocumentSearchRequest
     */
    'include_content'?: boolean;
}
/**
 * Schema for document search response.
 * @export
 * @interface DocumentSearchResponse
 */
export interface DocumentSearchResponse {
    /**
     * Search results
     * @type {Array<DocumentSearchResult>}
     * @memberof DocumentSearchResponse
     */
    'results': Array<DocumentSearchResult>;
    /**
     * Total number of matching results
     * @type {number}
     * @memberof DocumentSearchResponse
     */
    'total_results': number;
    /**
     * Original search query
     * @type {string}
     * @memberof DocumentSearchResponse
     */
    'query': string;
    /**
     * Applied score threshold
     * @type {number}
     * @memberof DocumentSearchResponse
     */
    'score_threshold': number;
}
/**
 * Schema for document search result.
 * @export
 * @interface DocumentSearchResult
 */
export interface DocumentSearchResult {
    /**
     * Document ID
     * @type {string}
     * @memberof DocumentSearchResult
     */
    'document_id': string;
    /**
     * Chunk ID
     * @type {string}
     * @memberof DocumentSearchResult
     */
    'chunk_id': string;
    /**
     * Similarity score
     * @type {number}
     * @memberof DocumentSearchResult
     */
    'score': number;
    /**
     * Matching content
     * @type {string}
     * @memberof DocumentSearchResult
     */
    'content': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DocumentSearchResult
     */
    'metadata'?: { [key: string]: any; } | null;
    /**
     * Document information
     * @type {DocumentResponse}
     * @memberof DocumentSearchResult
     */
    'document': DocumentResponse;
}
/**
 * Schema for document statistics response.
 * @export
 * @interface DocumentStatsResponse
 */
export interface DocumentStatsResponse {
    /**
     * Total number of documents
     * @type {number}
     * @memberof DocumentStatsResponse
     */
    'total_documents': number;
    /**
     * Total number of chunks
     * @type {number}
     * @memberof DocumentStatsResponse
     */
    'total_chunks': number;
    /**
     * Total size in bytes
     * @type {number}
     * @memberof DocumentStatsResponse
     */
    'total_size_bytes': number;
    /**
     * Documents grouped by status
     * @type {{ [key: string]: number; }}
     * @memberof DocumentStatsResponse
     */
    'documents_by_status': { [key: string]: number; };
    /**
     * Documents grouped by type
     * @type {{ [key: string]: number; }}
     * @memberof DocumentStatsResponse
     */
    'documents_by_type': { [key: string]: number; };
    /**
     * Processing statistics
     * @type {{ [key: string]: any; }}
     * @memberof DocumentStatsResponse
     */
    'processing_stats': { [key: string]: any; };
}
/**
 * Enumeration for document processing status.
 * @export
 * @enum {string}
 */

export const DocumentStatus = {
    pending: 'pending',
    processing: 'processing',
    processed: 'processed',
    failed: 'failed',
    archived: 'archived'
} as const;

export type DocumentStatus = typeof DocumentStatus[keyof typeof DocumentStatus];


/**
 * Enumeration for document types.
 * @export
 * @enum {string}
 */

export const DocumentType = {
    pdf: 'pdf',
    text: 'text',
    markdown: 'markdown',
    html: 'html',
    doc: 'doc',
    docx: 'docx',
    rtf: 'rtf',
    odt: 'odt',
    csv: 'csv',
    json: 'json',
    xml: 'xml',
    other: 'other'
} as const;

export type DocumentType = typeof DocumentType[keyof typeof DocumentType];


/**
 * Schema for updating a document.
 * @export
 * @interface DocumentUpdate
 */
export interface DocumentUpdate {
    /**
     * 
     * @type {string}
     * @memberof DocumentUpdate
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DocumentUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof DocumentUpdate
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DocumentUpdate
     */
    'extra_metadata'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {boolean}
     * @memberof DocumentUpdate
     */
    'is_public'?: boolean | null;
}
/**
 * Request schema for data export API.
 * @export
 * @interface ExportDataRequest
 */
export interface ExportDataRequest {
    /**
     * Export scope
     * @type {ExportScope}
     * @memberof ExportDataRequest
     */
    'scope': ExportScope;
    /**
     * Export format
     * @type {DataFormat}
     * @memberof ExportDataRequest
     */
    'format'?: DataFormat;
    /**
     * 
     * @type {string}
     * @memberof ExportDataRequest
     */
    'user_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExportDataRequest
     */
    'conversation_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExportDataRequest
     */
    'date_from'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExportDataRequest
     */
    'date_to'?: string | null;
    /**
     * Include metadata
     * @type {boolean}
     * @memberof ExportDataRequest
     */
    'include_metadata'?: boolean;
    /**
     * Compress export file
     * @type {boolean}
     * @memberof ExportDataRequest
     */
    'compress'?: boolean;
    /**
     * Encrypt export file
     * @type {boolean}
     * @memberof ExportDataRequest
     */
    'encrypt'?: boolean;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ExportDataRequest
     */
    'custom_query'?: { [key: string]: any; } | null;
}


/**
 * Response schema for data export.
 * @export
 * @interface ExportDataResponse
 */
export interface ExportDataResponse {
    /**
     * Export ID
     * @type {string}
     * @memberof ExportDataResponse
     */
    'export_id': string;
    /**
     * Export status
     * @type {string}
     * @memberof ExportDataResponse
     */
    'status': string;
    /**
     * 
     * @type {string}
     * @memberof ExportDataResponse
     */
    'download_url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ExportDataResponse
     */
    'file_size'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ExportDataResponse
     */
    'record_count'?: number | null;
    /**
     * Export creation timestamp
     * @type {string}
     * @memberof ExportDataResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof ExportDataResponse
     */
    'completed_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ExportDataResponse
     */
    'expires_at'?: string | null;
}
/**
 * Data export scope.
 * @export
 * @enum {string}
 */

export const ExportScope = {
    user: 'user',
    conversation: 'conversation',
    document: 'document',
    analytics: 'analytics',
    full: 'full',
    custom: 'custom'
} as const;

export type ExportScope = typeof ExportScope[keyof typeof ExportScope];


/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * Schema for health check response.
 * @export
 * @interface HealthCheckResponse
 */
export interface HealthCheckResponse {
    /**
     * Health status
     * @type {string}
     * @memberof HealthCheckResponse
     */
    'status': string;
    /**
     * Service name
     * @type {string}
     * @memberof HealthCheckResponse
     */
    'service': string;
    /**
     * Service version
     * @type {string}
     * @memberof HealthCheckResponse
     */
    'version': string;
    /**
     * Environment
     * @type {string}
     * @memberof HealthCheckResponse
     */
    'environment': string;
}
/**
 * Response schema for job actions.
 * @export
 * @interface JobActionResponse
 */
export interface JobActionResponse {
    /**
     * Whether action was successful
     * @type {boolean}
     * @memberof JobActionResponse
     */
    'success': boolean;
    /**
     * Action result message
     * @type {string}
     * @memberof JobActionResponse
     */
    'message': string;
    /**
     * Job ID
     * @type {string}
     * @memberof JobActionResponse
     */
    'job_id': string;
}
/**
 * Request schema for creating a job.
 * @export
 * @interface JobCreateRequest
 */
export interface JobCreateRequest {
    /**
     * Job name
     * @type {string}
     * @memberof JobCreateRequest
     */
    'name': string;
    /**
     * Function to execute
     * @type {string}
     * @memberof JobCreateRequest
     */
    'function_name': string;
    /**
     * Function arguments
     * @type {Array<any>}
     * @memberof JobCreateRequest
     */
    'args'?: Array<any>;
    /**
     * Function keyword arguments
     * @type {{ [key: string]: any; }}
     * @memberof JobCreateRequest
     */
    'kwargs'?: { [key: string]: any; };
    /**
     * Job priority
     * @type {JobPriority}
     * @memberof JobCreateRequest
     */
    'priority'?: JobPriority;
    /**
     * Maximum retry attempts
     * @type {number}
     * @memberof JobCreateRequest
     */
    'max_retries'?: number;
    /**
     * 
     * @type {string}
     * @memberof JobCreateRequest
     */
    'schedule_at'?: string | null;
}


/**
 * Response schema for job list.
 * @export
 * @interface JobListResponse
 */
export interface JobListResponse {
    /**
     * List of jobs
     * @type {Array<JobResponse>}
     * @memberof JobListResponse
     */
    'jobs': Array<JobResponse>;
    /**
     * Total number of jobs
     * @type {number}
     * @memberof JobListResponse
     */
    'total': number;
}
/**
 * Job priority levels.
 * @export
 * @enum {string}
 */

export const JobPriority = {
    low: 'low',
    normal: 'normal',
    high: 'high',
    critical: 'critical'
} as const;

export type JobPriority = typeof JobPriority[keyof typeof JobPriority];


/**
 * Response schema for job data.
 * @export
 * @interface JobResponse
 */
export interface JobResponse {
    /**
     * Job ID
     * @type {string}
     * @memberof JobResponse
     */
    'id': string;
    /**
     * Job name
     * @type {string}
     * @memberof JobResponse
     */
    'name': string;
    /**
     * Function name
     * @type {string}
     * @memberof JobResponse
     */
    'function_name': string;
    /**
     * Job priority
     * @type {JobPriority}
     * @memberof JobResponse
     */
    'priority': JobPriority;
    /**
     * Job status
     * @type {JobStatus}
     * @memberof JobResponse
     */
    'status': JobStatus;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof JobResponse
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'started_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'completed_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'scheduled_at'?: string | null;
    /**
     * Number of retry attempts
     * @type {number}
     * @memberof JobResponse
     */
    'retry_count': number;
    /**
     * Maximum retry attempts
     * @type {number}
     * @memberof JobResponse
     */
    'max_retries': number;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'error_message'?: string | null;
    /**
     * Job result if completed
     * @type {}
     * @memberof JobResponse
     */
    'result'?:  | null;
    /**
     * Job progress percentage
     * @type {number}
     * @memberof JobResponse
     */
    'progress'?: number;
    /**
     * 
     * @type {string}
     * @memberof JobResponse
     */
    'progress_message'?: string | null;
}


/**
 * Response schema for job statistics.
 * @export
 * @interface JobStatsResponse
 */
export interface JobStatsResponse {
    /**
     * Total number of jobs
     * @type {number}
     * @memberof JobStatsResponse
     */
    'total_jobs': number;
    /**
     * Number of pending jobs
     * @type {number}
     * @memberof JobStatsResponse
     */
    'pending_jobs': number;
    /**
     * Number of running jobs
     * @type {number}
     * @memberof JobStatsResponse
     */
    'running_jobs': number;
    /**
     * Number of completed jobs
     * @type {number}
     * @memberof JobStatsResponse
     */
    'completed_jobs': number;
    /**
     * Number of failed jobs
     * @type {number}
     * @memberof JobStatsResponse
     */
    'failed_jobs': number;
    /**
     * Current queue size
     * @type {number}
     * @memberof JobStatsResponse
     */
    'queue_size': number;
    /**
     * Number of active workers
     * @type {number}
     * @memberof JobStatsResponse
     */
    'active_workers': number;
}
/**
 * Job execution status.
 * @export
 * @enum {string}
 */

export const JobStatus = {
    pending: 'pending',
    running: 'running',
    completed: 'completed',
    failed: 'failed',
    cancelled: 'cancelled',
    retrying: 'retrying'
} as const;

export type JobStatus = typeof JobStatus[keyof typeof JobStatus];


/**
 * Schema for logout response.
 * @export
 * @interface LogoutResponse
 */
export interface LogoutResponse {
    /**
     * Success message
     * @type {string}
     * @memberof LogoutResponse
     */
    'message': string;
}
/**
 * Schema for MCP status response.
 * @export
 * @interface McpStatusResponse
 */
export interface McpStatusResponse {
    /**
     * MCP service status
     * @type {string}
     * @memberof McpStatusResponse
     */
    'status': string;
    /**
     * Connected servers
     * @type {Array<{ [key: string]: any; } | null>}
     * @memberof McpStatusResponse
     */
    'servers': Array<{ [key: string]: any; } | null>;
    /**
     * 
     * @type {string}
     * @memberof McpStatusResponse
     */
    'last_check'?: string | null;
    /**
     * Any error messages
     * @type {Array<string>}
     * @memberof McpStatusResponse
     */
    'errors'?: Array<string>;
}
/**
 * Schema for creating a message.
 * @export
 * @interface MessageCreate
 */
export interface MessageCreate {
    /**
     * Message role
     * @type {MessageRole}
     * @memberof MessageCreate
     */
    'role': MessageRole;
    /**
     * Message content
     * @type {string}
     * @memberof MessageCreate
     */
    'content': string;
}


/**
 * Schema for message response.
 * @export
 * @interface MessageResponse
 */
export interface MessageResponse {
    /**
     * Message role
     * @type {MessageRole}
     * @memberof MessageResponse
     */
    'role': MessageRole;
    /**
     * Message content
     * @type {string}
     * @memberof MessageResponse
     */
    'content': string;
    /**
     * Message ID
     * @type {string}
     * @memberof MessageResponse
     */
    'id': string;
    /**
     * Conversation ID
     * @type {string}
     * @memberof MessageResponse
     */
    'conversation_id': string;
    /**
     * Message sequence number
     * @type {number}
     * @memberof MessageResponse
     */
    'sequence_number': number;
    /**
     * 
     * @type {number}
     * @memberof MessageResponse
     */
    'prompt_tokens'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MessageResponse
     */
    'completion_tokens'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MessageResponse
     */
    'total_tokens'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof MessageResponse
     */
    'model_used'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof MessageResponse
     */
    'provider_used'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof MessageResponse
     */
    'response_time_ms'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof MessageResponse
     */
    'cost'?: number | null;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof MessageResponse
     */
    'created_at': string;
}


/**
 * Enumeration for message roles.
 * @export
 * @enum {string}
 */

export const MessageRole = {
    user: 'user',
    assistant: 'assistant',
    system: 'system',
    tool: 'tool'
} as const;

export type MessageRole = typeof MessageRole[keyof typeof MessageRole];


/**
 * Types of metrics to track.
 * @export
 * @enum {string}
 */

export const MetricType = {
    response_time: 'response_time',
    user_satisfaction: 'user_satisfaction',
    accuracy: 'accuracy',
    engagement: 'engagement',
    conversion: 'conversion',
    error_rate: 'error_rate',
    token_usage: 'token_usage',
    custom: 'custom'
} as const;

export type MetricType = typeof MetricType[keyof typeof MetricType];


/**
 * Schema for password change.
 * @export
 * @interface PasswordChange
 */
export interface PasswordChange {
    /**
     * Current password
     * @type {string}
     * @memberof PasswordChange
     */
    'current_password': string;
    /**
     * New password
     * @type {string}
     * @memberof PasswordChange
     */
    'new_password': string;
}
/**
 * Schema for password change response.
 * @export
 * @interface PasswordChangeResponse
 */
export interface PasswordChangeResponse {
    /**
     * Success message
     * @type {string}
     * @memberof PasswordChangeResponse
     */
    'message': string;
}
/**
 * Schema for password reset confirmation response.
 * @export
 * @interface PasswordResetConfirmResponse
 */
export interface PasswordResetConfirmResponse {
    /**
     * Success message
     * @type {string}
     * @memberof PasswordResetConfirmResponse
     */
    'message': string;
}
/**
 * Schema for password reset request response.
 * @export
 * @interface PasswordResetRequestResponse
 */
export interface PasswordResetRequestResponse {
    /**
     * Success message
     * @type {string}
     * @memberof PasswordResetRequestResponse
     */
    'message': string;
}
/**
 * Schema for performance metrics response.
 * @export
 * @interface PerformanceMetricsResponse
 */
export interface PerformanceMetricsResponse {
    /**
     * Average response time
     * @type {number}
     * @memberof PerformanceMetricsResponse
     */
    'avg_response_time_ms': number;
    /**
     * Median response time
     * @type {number}
     * @memberof PerformanceMetricsResponse
     */
    'median_response_time_ms': number;
    /**
     * 95th percentile response time
     * @type {number}
     * @memberof PerformanceMetricsResponse
     */
    'p95_response_time_ms': number;
    /**
     * 99th percentile response time
     * @type {number}
     * @memberof PerformanceMetricsResponse
     */
    'p99_response_time_ms': number;
    /**
     * Average requests per minute
     * @type {number}
     * @memberof PerformanceMetricsResponse
     */
    'requests_per_minute': number;
    /**
     * Average tokens per minute
     * @type {number}
     * @memberof PerformanceMetricsResponse
     */
    'tokens_per_minute': number;
    /**
     * Total number of errors
     * @type {number}
     * @memberof PerformanceMetricsResponse
     */
    'total_errors': number;
    /**
     * Error rate percentage
     * @type {number}
     * @memberof PerformanceMetricsResponse
     */
    'error_rate': number;
    /**
     * Errors grouped by type
     * @type {{ [key: string]: number; }}
     * @memberof PerformanceMetricsResponse
     */
    'errors_by_type': { [key: string]: number; };
    /**
     * Performance metrics by model
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof PerformanceMetricsResponse
     */
    'performance_by_model': { [key: string]: { [key: string]: number; }; };
    /**
     * Performance metrics by provider
     * @type {{ [key: string]: { [key: string]: number; }; }}
     * @memberof PerformanceMetricsResponse
     */
    'performance_by_provider': { [key: string]: { [key: string]: number; }; };
    /**
     * Average database response time
     * @type {number}
     * @memberof PerformanceMetricsResponse
     */
    'database_response_time_ms': number;
    /**
     * Average vector search time
     * @type {number}
     * @memberof PerformanceMetricsResponse
     */
    'vector_search_time_ms': number;
    /**
     * Average embedding generation time
     * @type {number}
     * @memberof PerformanceMetricsResponse
     */
    'embedding_generation_time_ms': number;
}
/**
 * Response schema for plugin actions.
 * @export
 * @interface PluginActionResponse
 */
export interface PluginActionResponse {
    /**
     * Whether action was successful
     * @type {boolean}
     * @memberof PluginActionResponse
     */
    'success': boolean;
    /**
     * Action result message
     * @type {string}
     * @memberof PluginActionResponse
     */
    'message': string;
    /**
     * Plugin ID
     * @type {string}
     * @memberof PluginActionResponse
     */
    'plugin_id': string;
}
/**
 * Response schema for plugin deletion.
 * @export
 * @interface PluginDeleteResponse
 */
export interface PluginDeleteResponse {
    /**
     * Whether deletion was successful
     * @type {boolean}
     * @memberof PluginDeleteResponse
     */
    'success': boolean;
    /**
     * Deletion result message
     * @type {string}
     * @memberof PluginDeleteResponse
     */
    'message': string;
}
/**
 * Request schema for installing a plugin.
 * @export
 * @interface PluginInstallRequest
 */
export interface PluginInstallRequest {
    /**
     * Path to plugin file or directory
     * @type {string}
     * @memberof PluginInstallRequest
     */
    'plugin_path': string;
    /**
     * Enable plugin after installation
     * @type {boolean}
     * @memberof PluginInstallRequest
     */
    'enable_on_install'?: boolean;
}
/**
 * Response schema for plugin list.
 * @export
 * @interface PluginListResponse
 */
export interface PluginListResponse {
    /**
     * List of plugins
     * @type {Array<PluginResponse>}
     * @memberof PluginListResponse
     */
    'plugins': Array<PluginResponse>;
    /**
     * Total number of plugins
     * @type {number}
     * @memberof PluginListResponse
     */
    'total': number;
}
/**
 * Response schema for plugin data.
 * @export
 * @interface PluginResponse
 */
export interface PluginResponse {
    /**
     * Plugin ID
     * @type {string}
     * @memberof PluginResponse
     */
    'id': string;
    /**
     * Plugin name
     * @type {string}
     * @memberof PluginResponse
     */
    'name': string;
    /**
     * Plugin version
     * @type {string}
     * @memberof PluginResponse
     */
    'version': string;
    /**
     * Plugin description
     * @type {string}
     * @memberof PluginResponse
     */
    'description': string;
    /**
     * Plugin author
     * @type {string}
     * @memberof PluginResponse
     */
    'author': string;
    /**
     * Plugin type
     * @type {PluginType}
     * @memberof PluginResponse
     */
    'plugin_type': PluginType;
    /**
     * Plugin status
     * @type {PluginStatus}
     * @memberof PluginResponse
     */
    'status': PluginStatus;
    /**
     * Plugin entry point
     * @type {string}
     * @memberof PluginResponse
     */
    'entry_point': string;
    /**
     * Plugin capabilities
     * @type {Array<{ [key: string]: any; } | null>}
     * @memberof PluginResponse
     */
    'capabilities': Array<{ [key: string]: any; } | null>;
    /**
     * Plugin dependencies
     * @type {Array<string>}
     * @memberof PluginResponse
     */
    'dependencies': Array<string>;
    /**
     * Required permissions
     * @type {Array<string>}
     * @memberof PluginResponse
     */
    'permissions': Array<string>;
    /**
     * Whether plugin is enabled
     * @type {boolean}
     * @memberof PluginResponse
     */
    'enabled': boolean;
    /**
     * 
     * @type {string}
     * @memberof PluginResponse
     */
    'error_message'?: string | null;
    /**
     * Installation timestamp
     * @type {string}
     * @memberof PluginResponse
     */
    'installed_at': string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof PluginResponse
     */
    'updated_at': string;
    /**
     * Additional metadata
     * @type {{ [key: string]: any; }}
     * @memberof PluginResponse
     */
    'metadata': { [key: string]: any; };
}


/**
 * Plugin status.
 * @export
 * @enum {string}
 */

export const PluginStatus = {
    installed: 'installed',
    active: 'active',
    inactive: 'inactive',
    error: 'error',
    updating: 'updating'
} as const;

export type PluginStatus = typeof PluginStatus[keyof typeof PluginStatus];


/**
 * Types of plugins.
 * @export
 * @enum {string}
 */

export const PluginType = {
    tool: 'tool',
    workflow: 'workflow',
    integration: 'integration',
    middleware: 'middleware',
    handler: 'handler',
    extension: 'extension'
} as const;

export type PluginType = typeof PluginType[keyof typeof PluginType];


/**
 * Request schema for updating a plugin.
 * @export
 * @interface PluginUpdateRequest
 */
export interface PluginUpdateRequest {
    /**
     * 
     * @type {boolean}
     * @memberof PluginUpdateRequest
     */
    'enabled'?: boolean | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PluginUpdateRequest
     */
    'configuration'?: { [key: string]: any; } | null;
}
/**
 * Schema for profile clone request.
 * @export
 * @interface ProfileCloneRequest
 */
export interface ProfileCloneRequest {
    /**
     * New profile name
     * @type {string}
     * @memberof ProfileCloneRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCloneRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {ProfileUpdate}
     * @memberof ProfileCloneRequest
     */
    'modifications'?: ProfileUpdate | null;
}
/**
 * Schema for creating a profile.
 * @export
 * @interface ProfileCreate
 */
export interface ProfileCreate {
    /**
     * Profile name
     * @type {string}
     * @memberof ProfileCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileCreate
     */
    'description'?: string | null;
    /**
     * Profile type
     * @type {ProfileType}
     * @memberof ProfileCreate
     */
    'profile_type'?: ProfileType;
    /**
     * LLM provider (openai, anthropic, etc.)
     * @type {string}
     * @memberof ProfileCreate
     */
    'llm_provider': string;
    /**
     * LLM model name
     * @type {string}
     * @memberof ProfileCreate
     */
    'llm_model': string;
    /**
     * Temperature for generation
     * @type {number}
     * @memberof ProfileCreate
     */
    'temperature'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProfileCreate
     */
    'top_p'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProfileCreate
     */
    'top_k'?: number | null;
    /**
     * Maximum tokens to generate
     * @type {number}
     * @memberof ProfileCreate
     */
    'max_tokens'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProfileCreate
     */
    'presence_penalty'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProfileCreate
     */
    'frequency_penalty'?: number | null;
    /**
     * Context window size
     * @type {number}
     * @memberof ProfileCreate
     */
    'context_window'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProfileCreate
     */
    'system_prompt'?: string | null;
    /**
     * Enable conversation memory
     * @type {boolean}
     * @memberof ProfileCreate
     */
    'memory_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProfileCreate
     */
    'memory_strategy'?: string | null;
    /**
     * Enable document retrieval
     * @type {boolean}
     * @memberof ProfileCreate
     */
    'enable_retrieval'?: boolean;
    /**
     * Number of documents to retrieve
     * @type {number}
     * @memberof ProfileCreate
     */
    'retrieval_limit'?: number;
    /**
     * Minimum retrieval score
     * @type {number}
     * @memberof ProfileCreate
     */
    'retrieval_score_threshold'?: number;
    /**
     * Enable tool calling
     * @type {boolean}
     * @memberof ProfileCreate
     */
    'enable_tools'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileCreate
     */
    'available_tools'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileCreate
     */
    'tool_choice'?: string | null;
    /**
     * Enable content filtering
     * @type {boolean}
     * @memberof ProfileCreate
     */
    'content_filter_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProfileCreate
     */
    'safety_level'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileCreate
     */
    'response_format'?: string | null;
    /**
     * Enable streaming responses
     * @type {boolean}
     * @memberof ProfileCreate
     */
    'stream_response'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProfileCreate
     */
    'seed'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileCreate
     */
    'stop_sequences'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ProfileCreate
     */
    'logit_bias'?: { [key: string]: number; } | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileCreate
     */
    'embedding_provider'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileCreate
     */
    'embedding_model'?: string | null;
    /**
     * Whether profile is public
     * @type {boolean}
     * @memberof ProfileCreate
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileCreate
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ProfileCreate
     */
    'extra_metadata'?: { [key: string]: any; } | null;
}


/**
 * Schema for profile delete response.
 * @export
 * @interface ProfileDeleteResponse
 */
export interface ProfileDeleteResponse {
    /**
     * Success message
     * @type {string}
     * @memberof ProfileDeleteResponse
     */
    'message': string;
}
/**
 * Schema for profile list response.
 * @export
 * @interface ProfileListResponse
 */
export interface ProfileListResponse {
    /**
     * List of profiles
     * @type {Array<ProfileResponse>}
     * @memberof ProfileListResponse
     */
    'profiles': Array<ProfileResponse>;
    /**
     * Total number of profiles
     * @type {number}
     * @memberof ProfileListResponse
     */
    'total_count': number;
    /**
     * Applied limit
     * @type {number}
     * @memberof ProfileListResponse
     */
    'limit': number;
    /**
     * Applied offset
     * @type {number}
     * @memberof ProfileListResponse
     */
    'offset': number;
}
/**
 * Schema for profile response.
 * @export
 * @interface ProfileResponse
 */
export interface ProfileResponse {
    /**
     * Profile name
     * @type {string}
     * @memberof ProfileResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'description'?: string | null;
    /**
     * Profile type
     * @type {ProfileType}
     * @memberof ProfileResponse
     */
    'profile_type'?: ProfileType;
    /**
     * LLM provider (openai, anthropic, etc.)
     * @type {string}
     * @memberof ProfileResponse
     */
    'llm_provider': string;
    /**
     * LLM model name
     * @type {string}
     * @memberof ProfileResponse
     */
    'llm_model': string;
    /**
     * Temperature for generation
     * @type {number}
     * @memberof ProfileResponse
     */
    'temperature'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProfileResponse
     */
    'top_p'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProfileResponse
     */
    'top_k'?: number | null;
    /**
     * Maximum tokens to generate
     * @type {number}
     * @memberof ProfileResponse
     */
    'max_tokens'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProfileResponse
     */
    'presence_penalty'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProfileResponse
     */
    'frequency_penalty'?: number | null;
    /**
     * Context window size
     * @type {number}
     * @memberof ProfileResponse
     */
    'context_window'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'system_prompt'?: string | null;
    /**
     * Enable conversation memory
     * @type {boolean}
     * @memberof ProfileResponse
     */
    'memory_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'memory_strategy'?: string | null;
    /**
     * Enable document retrieval
     * @type {boolean}
     * @memberof ProfileResponse
     */
    'enable_retrieval'?: boolean;
    /**
     * Number of documents to retrieve
     * @type {number}
     * @memberof ProfileResponse
     */
    'retrieval_limit'?: number;
    /**
     * Minimum retrieval score
     * @type {number}
     * @memberof ProfileResponse
     */
    'retrieval_score_threshold'?: number;
    /**
     * Enable tool calling
     * @type {boolean}
     * @memberof ProfileResponse
     */
    'enable_tools'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileResponse
     */
    'available_tools'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'tool_choice'?: string | null;
    /**
     * Enable content filtering
     * @type {boolean}
     * @memberof ProfileResponse
     */
    'content_filter_enabled'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'safety_level'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'response_format'?: string | null;
    /**
     * Enable streaming responses
     * @type {boolean}
     * @memberof ProfileResponse
     */
    'stream_response'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProfileResponse
     */
    'seed'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileResponse
     */
    'stop_sequences'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ProfileResponse
     */
    'logit_bias'?: { [key: string]: number; } | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'embedding_provider'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'embedding_model'?: string | null;
    /**
     * Whether profile is public
     * @type {boolean}
     * @memberof ProfileResponse
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileResponse
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ProfileResponse
     */
    'extra_metadata'?: { [key: string]: any; } | null;
    /**
     * Profile ID
     * @type {string}
     * @memberof ProfileResponse
     */
    'id': string;
    /**
     * Owner user ID
     * @type {string}
     * @memberof ProfileResponse
     */
    'owner_id': string;
    /**
     * Number of times used
     * @type {number}
     * @memberof ProfileResponse
     */
    'usage_count': number;
    /**
     * Total tokens used
     * @type {number}
     * @memberof ProfileResponse
     */
    'total_tokens_used': number;
    /**
     * Total cost incurred
     * @type {number}
     * @memberof ProfileResponse
     */
    'total_cost': number;
    /**
     * 
     * @type {string}
     * @memberof ProfileResponse
     */
    'last_used_at'?: string | null;
    /**
     * Creation time
     * @type {string}
     * @memberof ProfileResponse
     */
    'created_at': string;
    /**
     * Last update time
     * @type {string}
     * @memberof ProfileResponse
     */
    'updated_at': string;
}


/**
 * Schema for profile statistics response.
 * @export
 * @interface ProfileStatsResponse
 */
export interface ProfileStatsResponse {
    /**
     * Total number of profiles
     * @type {number}
     * @memberof ProfileStatsResponse
     */
    'total_profiles': number;
    /**
     * Profiles grouped by type
     * @type {{ [key: string]: number; }}
     * @memberof ProfileStatsResponse
     */
    'profiles_by_type': { [key: string]: number; };
    /**
     * Profiles grouped by LLM provider
     * @type {{ [key: string]: number; }}
     * @memberof ProfileStatsResponse
     */
    'profiles_by_provider': { [key: string]: number; };
    /**
     * Most frequently used profiles
     * @type {Array<ProfileResponse>}
     * @memberof ProfileStatsResponse
     */
    'most_used_profiles': Array<ProfileResponse>;
    /**
     * Recently created profiles
     * @type {Array<ProfileResponse>}
     * @memberof ProfileStatsResponse
     */
    'recent_profiles': Array<ProfileResponse>;
    /**
     * Usage statistics
     * @type {{ [key: string]: any; }}
     * @memberof ProfileStatsResponse
     */
    'usage_stats': { [key: string]: any; };
}
/**
 * Schema for profile test request.
 * @export
 * @interface ProfileTestRequest
 */
export interface ProfileTestRequest {
    /**
     * Test message
     * @type {string}
     * @memberof ProfileTestRequest
     */
    'test_message': string;
    /**
     * Include retrieval in test
     * @type {boolean}
     * @memberof ProfileTestRequest
     */
    'include_retrieval'?: boolean;
    /**
     * Include tools in test
     * @type {boolean}
     * @memberof ProfileTestRequest
     */
    'include_tools'?: boolean;
}
/**
 * Schema for profile test response.
 * @export
 * @interface ProfileTestResponse
 */
export interface ProfileTestResponse {
    /**
     * Profile ID
     * @type {string}
     * @memberof ProfileTestResponse
     */
    'profile_id': string;
    /**
     * Test message sent
     * @type {string}
     * @memberof ProfileTestResponse
     */
    'test_message': string;
    /**
     * Generated response
     * @type {string}
     * @memberof ProfileTestResponse
     */
    'response': string;
    /**
     * Token usage and cost information
     * @type {{ [key: string]: any; }}
     * @memberof ProfileTestResponse
     */
    'usage_info': { [key: string]: any; };
    /**
     * Response time in milliseconds
     * @type {number}
     * @memberof ProfileTestResponse
     */
    'response_time_ms': number;
    /**
     * 
     * @type {Array<{ [key: string]: any; } | null>}
     * @memberof ProfileTestResponse
     */
    'retrieval_results'?: Array<{ [key: string]: any; } | null> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileTestResponse
     */
    'tools_used'?: Array<string> | null;
}
/**
 * Enumeration for profile types.
 * @export
 * @enum {string}
 */

export const ProfileType = {
    conversational: 'conversational',
    analytical: 'analytical',
    creative: 'creative',
    technical: 'technical',
    custom: 'custom'
} as const;

export type ProfileType = typeof ProfileType[keyof typeof ProfileType];


/**
 * Schema for updating a profile.
 * @export
 * @interface ProfileUpdate
 */
export interface ProfileUpdate {
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdate
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {ProfileType}
     * @memberof ProfileUpdate
     */
    'profile_type'?: ProfileType | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdate
     */
    'llm_provider'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdate
     */
    'llm_model'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ProfileUpdate
     */
    'temperature'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProfileUpdate
     */
    'top_p'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProfileUpdate
     */
    'top_k'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProfileUpdate
     */
    'max_tokens'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProfileUpdate
     */
    'presence_penalty'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProfileUpdate
     */
    'frequency_penalty'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProfileUpdate
     */
    'context_window'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdate
     */
    'system_prompt'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileUpdate
     */
    'memory_enabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdate
     */
    'memory_strategy'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileUpdate
     */
    'enable_retrieval'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof ProfileUpdate
     */
    'retrieval_limit'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof ProfileUpdate
     */
    'retrieval_score_threshold'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileUpdate
     */
    'enable_tools'?: boolean | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileUpdate
     */
    'available_tools'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdate
     */
    'tool_choice'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileUpdate
     */
    'content_filter_enabled'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdate
     */
    'safety_level'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdate
     */
    'response_format'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileUpdate
     */
    'stream_response'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof ProfileUpdate
     */
    'seed'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileUpdate
     */
    'stop_sequences'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ProfileUpdate
     */
    'logit_bias'?: { [key: string]: number; } | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdate
     */
    'embedding_provider'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProfileUpdate
     */
    'embedding_model'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProfileUpdate
     */
    'is_public'?: boolean | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProfileUpdate
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ProfileUpdate
     */
    'extra_metadata'?: { [key: string]: any; } | null;
}


/**
 * Enumeration for prompt categories.
 * @export
 * @enum {string}
 */

export const PromptCategory = {
    general: 'general',
    creative: 'creative',
    analytical: 'analytical',
    technical: 'technical',
    educational: 'educational',
    business: 'business',
    coding: 'coding',
    custom: 'custom'
} as const;

export type PromptCategory = typeof PromptCategory[keyof typeof PromptCategory];


/**
 * Schema for prompt clone request.
 * @export
 * @interface PromptCloneRequest
 */
export interface PromptCloneRequest {
    /**
     * New prompt name
     * @type {string}
     * @memberof PromptCloneRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PromptCloneRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PromptCloneRequest
     */
    'modifications'?: { [key: string]: any; } | null;
}
/**
 * Schema for creating a prompt.
 * @export
 * @interface PromptCreate
 */
export interface PromptCreate {
    /**
     * Prompt name
     * @type {string}
     * @memberof PromptCreate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PromptCreate
     */
    'description'?: string | null;
    /**
     * Prompt type
     * @type {PromptType}
     * @memberof PromptCreate
     */
    'prompt_type'?: PromptType;
    /**
     * Prompt category
     * @type {PromptCategory}
     * @memberof PromptCreate
     */
    'category'?: PromptCategory;
    /**
     * Prompt content/template
     * @type {string}
     * @memberof PromptCreate
     */
    'content': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PromptCreate
     */
    'variables'?: Array<string> | null;
    /**
     * Template format (f-string, jinja2, mustache)
     * @type {string}
     * @memberof PromptCreate
     */
    'template_format'?: string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PromptCreate
     */
    'input_schema'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PromptCreate
     */
    'output_schema'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {number}
     * @memberof PromptCreate
     */
    'max_length'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PromptCreate
     */
    'min_length'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PromptCreate
     */
    'required_variables'?: Array<string> | null;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PromptCreate
     */
    'examples'?: Array<{ [key: string]: any; }> | null;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PromptCreate
     */
    'test_cases'?: Array<{ [key: string]: any; }> | null;
    /**
     * 
     * @type {number}
     * @memberof PromptCreate
     */
    'suggested_temperature'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PromptCreate
     */
    'suggested_max_tokens'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PromptCreate
     */
    'suggested_providers'?: Array<string> | null;
    /**
     * Whether this is a chain prompt
     * @type {boolean}
     * @memberof PromptCreate
     */
    'is_chain'?: boolean;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PromptCreate
     */
    'chain_steps'?: Array<{ [key: string]: any; }> | null;
    /**
     * 
     * @type {string}
     * @memberof PromptCreate
     */
    'parent_prompt_id'?: string | null;
    /**
     * Whether prompt is public
     * @type {boolean}
     * @memberof PromptCreate
     */
    'is_public'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof PromptCreate
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PromptCreate
     */
    'extra_metadata'?: { [key: string]: any; } | null;
}


/**
 * Schema for prompt delete response.
 * @export
 * @interface PromptDeleteResponse
 */
export interface PromptDeleteResponse {
    /**
     * Success message
     * @type {string}
     * @memberof PromptDeleteResponse
     */
    'message': string;
}
/**
 * Schema for prompt list response.
 * @export
 * @interface PromptListResponse
 */
export interface PromptListResponse {
    /**
     * List of prompts
     * @type {Array<PromptResponse>}
     * @memberof PromptListResponse
     */
    'prompts': Array<PromptResponse>;
    /**
     * Total number of prompts
     * @type {number}
     * @memberof PromptListResponse
     */
    'total_count': number;
    /**
     * Requested limit
     * @type {number}
     * @memberof PromptListResponse
     */
    'limit': number;
    /**
     * Requested offset
     * @type {number}
     * @memberof PromptListResponse
     */
    'offset': number;
}
/**
 * Schema for prompt response.
 * @export
 * @interface PromptResponse
 */
export interface PromptResponse {
    /**
     * Prompt ID
     * @type {string}
     * @memberof PromptResponse
     */
    'id': string;
    /**
     * Owner user ID
     * @type {string}
     * @memberof PromptResponse
     */
    'owner_id': string;
    /**
     * Prompt name
     * @type {string}
     * @memberof PromptResponse
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PromptResponse
     */
    'description'?: string | null;
    /**
     * Prompt type
     * @type {PromptType}
     * @memberof PromptResponse
     */
    'prompt_type': PromptType;
    /**
     * Prompt category
     * @type {PromptCategory}
     * @memberof PromptResponse
     */
    'category': PromptCategory;
    /**
     * Prompt content/template
     * @type {string}
     * @memberof PromptResponse
     */
    'content': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PromptResponse
     */
    'variables'?: Array<string> | null;
    /**
     * Template format
     * @type {string}
     * @memberof PromptResponse
     */
    'template_format': string;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PromptResponse
     */
    'input_schema'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PromptResponse
     */
    'output_schema'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {number}
     * @memberof PromptResponse
     */
    'max_length'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PromptResponse
     */
    'min_length'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PromptResponse
     */
    'required_variables'?: Array<string> | null;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PromptResponse
     */
    'examples'?: Array<{ [key: string]: any; }> | null;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PromptResponse
     */
    'test_cases'?: Array<{ [key: string]: any; }> | null;
    /**
     * 
     * @type {number}
     * @memberof PromptResponse
     */
    'suggested_temperature'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PromptResponse
     */
    'suggested_max_tokens'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PromptResponse
     */
    'suggested_providers'?: Array<string> | null;
    /**
     * Whether this is a chain prompt
     * @type {boolean}
     * @memberof PromptResponse
     */
    'is_chain': boolean;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PromptResponse
     */
    'chain_steps'?: Array<{ [key: string]: any; }> | null;
    /**
     * 
     * @type {string}
     * @memberof PromptResponse
     */
    'parent_prompt_id'?: string | null;
    /**
     * Prompt version
     * @type {number}
     * @memberof PromptResponse
     */
    'version': number;
    /**
     * Whether this is the latest version
     * @type {boolean}
     * @memberof PromptResponse
     */
    'is_latest': boolean;
    /**
     * 
     * @type {string}
     * @memberof PromptResponse
     */
    'changelog'?: string | null;
    /**
     * Whether prompt is public
     * @type {boolean}
     * @memberof PromptResponse
     */
    'is_public': boolean;
    /**
     * 
     * @type {number}
     * @memberof PromptResponse
     */
    'rating'?: number | null;
    /**
     * Number of ratings
     * @type {number}
     * @memberof PromptResponse
     */
    'rating_count': number;
    /**
     * Usage count
     * @type {number}
     * @memberof PromptResponse
     */
    'usage_count': number;
    /**
     * 
     * @type {number}
     * @memberof PromptResponse
     */
    'success_rate'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PromptResponse
     */
    'avg_response_time_ms'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PromptResponse
     */
    'last_used_at'?: string | null;
    /**
     * Total tokens used
     * @type {number}
     * @memberof PromptResponse
     */
    'total_tokens_used': number;
    /**
     * Total cost
     * @type {number}
     * @memberof PromptResponse
     */
    'total_cost': number;
    /**
     * 
     * @type {number}
     * @memberof PromptResponse
     */
    'avg_tokens_per_use'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PromptResponse
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PromptResponse
     */
    'extra_metadata'?: { [key: string]: any; } | null;
    /**
     * Content hash
     * @type {string}
     * @memberof PromptResponse
     */
    'content_hash': string;
    /**
     * 
     * @type {number}
     * @memberof PromptResponse
     */
    'estimated_tokens'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PromptResponse
     */
    'language'?: string | null;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof PromptResponse
     */
    'created_at': string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof PromptResponse
     */
    'updated_at': string;
}


/**
 * Schema for prompt statistics response.
 * @export
 * @interface PromptStatsResponse
 */
export interface PromptStatsResponse {
    /**
     * Total number of prompts
     * @type {number}
     * @memberof PromptStatsResponse
     */
    'total_prompts': number;
    /**
     * Prompts by type
     * @type {{ [key: string]: number; }}
     * @memberof PromptStatsResponse
     */
    'prompts_by_type': { [key: string]: number; };
    /**
     * Prompts by category
     * @type {{ [key: string]: number; }}
     * @memberof PromptStatsResponse
     */
    'prompts_by_category': { [key: string]: number; };
    /**
     * Most used prompts
     * @type {Array<PromptResponse>}
     * @memberof PromptStatsResponse
     */
    'most_used_prompts': Array<PromptResponse>;
    /**
     * Recently created prompts
     * @type {Array<PromptResponse>}
     * @memberof PromptStatsResponse
     */
    'recent_prompts': Array<PromptResponse>;
    /**
     * Usage statistics
     * @type {{ [key: string]: any; }}
     * @memberof PromptStatsResponse
     */
    'usage_stats': { [key: string]: any; };
}
/**
 * Schema for prompt test request.
 * @export
 * @interface PromptTestRequest
 */
export interface PromptTestRequest {
    /**
     * Variables to test with
     * @type {{ [key: string]: any; }}
     * @memberof PromptTestRequest
     */
    'variables': { [key: string]: any; };
    /**
     * Only validate, don\'t render
     * @type {boolean}
     * @memberof PromptTestRequest
     */
    'validate_only'?: boolean;
}
/**
 * Schema for prompt test response.
 * @export
 * @interface PromptTestResponse
 */
export interface PromptTestResponse {
    /**
     * 
     * @type {string}
     * @memberof PromptTestResponse
     */
    'rendered_content'?: string | null;
    /**
     * Validation results
     * @type {{ [key: string]: any; }}
     * @memberof PromptTestResponse
     */
    'validation_result': { [key: string]: any; };
    /**
     * 
     * @type {number}
     * @memberof PromptTestResponse
     */
    'estimated_tokens'?: number | null;
    /**
     * Test execution time
     * @type {number}
     * @memberof PromptTestResponse
     */
    'test_duration_ms': number;
}
/**
 * Enumeration for prompt types.
 * @export
 * @enum {string}
 */

export const PromptType = {
    system: 'system',
    user: 'user',
    assistant: 'assistant',
    chain: 'chain',
    template: 'template'
} as const;

export type PromptType = typeof PromptType[keyof typeof PromptType];


/**
 * Schema for updating a prompt.
 * @export
 * @interface PromptUpdate
 */
export interface PromptUpdate {
    /**
     * 
     * @type {string}
     * @memberof PromptUpdate
     */
    'name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PromptUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {PromptType}
     * @memberof PromptUpdate
     */
    'prompt_type'?: PromptType | null;
    /**
     * 
     * @type {PromptCategory}
     * @memberof PromptUpdate
     */
    'category'?: PromptCategory | null;
    /**
     * 
     * @type {string}
     * @memberof PromptUpdate
     */
    'content'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PromptUpdate
     */
    'variables'?: Array<string> | null;
    /**
     * 
     * @type {string}
     * @memberof PromptUpdate
     */
    'template_format'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PromptUpdate
     */
    'input_schema'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PromptUpdate
     */
    'output_schema'?: { [key: string]: any; } | null;
    /**
     * 
     * @type {number}
     * @memberof PromptUpdate
     */
    'max_length'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PromptUpdate
     */
    'min_length'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PromptUpdate
     */
    'required_variables'?: Array<string> | null;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PromptUpdate
     */
    'examples'?: Array<{ [key: string]: any; }> | null;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PromptUpdate
     */
    'test_cases'?: Array<{ [key: string]: any; }> | null;
    /**
     * 
     * @type {number}
     * @memberof PromptUpdate
     */
    'suggested_temperature'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof PromptUpdate
     */
    'suggested_max_tokens'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PromptUpdate
     */
    'suggested_providers'?: Array<string> | null;
    /**
     * 
     * @type {boolean}
     * @memberof PromptUpdate
     */
    'is_chain'?: boolean | null;
    /**
     * 
     * @type {Array<{ [key: string]: any; }>}
     * @memberof PromptUpdate
     */
    'chain_steps'?: Array<{ [key: string]: any; }> | null;
    /**
     * 
     * @type {string}
     * @memberof PromptUpdate
     */
    'parent_prompt_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof PromptUpdate
     */
    'is_public'?: boolean | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof PromptUpdate
     */
    'tags'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof PromptUpdate
     */
    'extra_metadata'?: { [key: string]: any; } | null;
}


/**
 * Schema for readiness check response.
 * @export
 * @interface ReadinessCheckResponse
 */
export interface ReadinessCheckResponse {
    /**
     * Readiness status
     * @type {string}
     * @memberof ReadinessCheckResponse
     */
    'status': string;
    /**
     * Service name
     * @type {string}
     * @memberof ReadinessCheckResponse
     */
    'service': string;
    /**
     * Service version
     * @type {string}
     * @memberof ReadinessCheckResponse
     */
    'version': string;
    /**
     * Environment
     * @type {string}
     * @memberof ReadinessCheckResponse
     */
    'environment': string;
    /**
     * Health check results
     * @type {{ [key: string]: any; }}
     * @memberof ReadinessCheckResponse
     */
    'checks': { [key: string]: any; };
}
/**
 * Request schema for restoring from backup.
 * @export
 * @interface RestoreRequest
 */
export interface RestoreRequest {
    /**
     * Backup ID to restore from
     * @type {string}
     * @memberof RestoreRequest
     */
    'backup_id': string;
    /**
     * Restore options
     * @type {{ [key: string]: any; }}
     * @memberof RestoreRequest
     */
    'restore_options'?: { [key: string]: any; };
    /**
     * Create backup before restore
     * @type {boolean}
     * @memberof RestoreRequest
     */
    'create_backup_before_restore'?: boolean;
    /**
     * Verify backup integrity before restore
     * @type {boolean}
     * @memberof RestoreRequest
     */
    'verify_integrity'?: boolean;
}
/**
 * Response schema for restore operation.
 * @export
 * @interface RestoreResponse
 */
export interface RestoreResponse {
    /**
     * Restore operation ID
     * @type {string}
     * @memberof RestoreResponse
     */
    'restore_id': string;
    /**
     * Source backup ID
     * @type {string}
     * @memberof RestoreResponse
     */
    'backup_id': string;
    /**
     * Restore status
     * @type {string}
     * @memberof RestoreResponse
     */
    'status': string;
    /**
     * Restore progress percentage
     * @type {number}
     * @memberof RestoreResponse
     */
    'progress'?: number;
    /**
     * Number of records restored
     * @type {number}
     * @memberof RestoreResponse
     */
    'records_restored'?: number;
    /**
     * Restore start timestamp
     * @type {string}
     * @memberof RestoreResponse
     */
    'started_at': string;
    /**
     * 
     * @type {string}
     * @memberof RestoreResponse
     */
    'completed_at'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof RestoreResponse
     */
    'error_message'?: string | null;
}
/**
 * Response schema for SSE service statistics.
 * @export
 * @interface SSEStatsResponse
 */
export interface SSEStatsResponse {
    /**
     * Total active connections
     * @type {number}
     * @memberof SSEStatsResponse
     */
    'total_connections': number;
    /**
     * Your active connections
     * @type {number}
     * @memberof SSEStatsResponse
     */
    'your_connections': number;
}
/**
 * Enumeration for server status.
 * @export
 * @enum {string}
 */

export const ServerStatus = {
    enabled: 'enabled',
    disabled: 'disabled',
    error: 'error',
    starting: 'starting',
    stopping: 'stopping'
} as const;

export type ServerStatus = typeof ServerStatus[keyof typeof ServerStatus];


/**
 * Schema for server tool response.
 * @export
 * @interface ServerToolResponse
 */
export interface ServerToolResponse {
    /**
     * Tool name
     * @type {string}
     * @memberof ServerToolResponse
     */
    'name': string;
    /**
     * Display name
     * @type {string}
     * @memberof ServerToolResponse
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof ServerToolResponse
     */
    'description'?: string | null;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof ServerToolResponse
     */
    'args_schema'?: { [key: string]: any; } | null;
    /**
     * Bypass when tool is unavailable
     * @type {boolean}
     * @memberof ServerToolResponse
     */
    'bypass_when_unavailable'?: boolean;
    /**
     * Tool ID
     * @type {string}
     * @memberof ServerToolResponse
     */
    'id': string;
    /**
     * Server ID
     * @type {string}
     * @memberof ServerToolResponse
     */
    'server_id': string;
    /**
     * Tool status
     * @type {ToolStatus}
     * @memberof ServerToolResponse
     */
    'status': ToolStatus;
    /**
     * Tool availability
     * @type {boolean}
     * @memberof ServerToolResponse
     */
    'is_available': boolean;
    /**
     * Total number of calls
     * @type {number}
     * @memberof ServerToolResponse
     */
    'total_calls': number;
    /**
     * Total number of errors
     * @type {number}
     * @memberof ServerToolResponse
     */
    'total_errors': number;
    /**
     * 
     * @type {string}
     * @memberof ServerToolResponse
     */
    'last_called'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ServerToolResponse
     */
    'last_error'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ServerToolResponse
     */
    'avg_response_time_ms'?: number | null;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof ServerToolResponse
     */
    'created_at': string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof ServerToolResponse
     */
    'updated_at': string;
}


/**
 * Schema for server tools response with pagination.
 * @export
 * @interface ServerToolsResponse
 */
export interface ServerToolsResponse {
    /**
     * List of server tools
     * @type {Array<ServerToolResponse>}
     * @memberof ServerToolsResponse
     */
    'tools': Array<ServerToolResponse>;
    /**
     * Total number of tools
     * @type {number}
     * @memberof ServerToolsResponse
     */
    'total_count': number;
    /**
     * Applied limit
     * @type {number}
     * @memberof ServerToolsResponse
     */
    'limit': number;
    /**
     * Applied offset
     * @type {number}
     * @memberof ServerToolsResponse
     */
    'offset': number;
}
/**
 * Response schema for storage statistics.
 * @export
 * @interface StorageStatsResponse
 */
export interface StorageStatsResponse {
    /**
     * Total storage used in bytes
     * @type {number}
     * @memberof StorageStatsResponse
     */
    'total_size': number;
    /**
     * Database size in bytes
     * @type {number}
     * @memberof StorageStatsResponse
     */
    'database_size': number;
    /**
     * Uploaded files size in bytes
     * @type {number}
     * @memberof StorageStatsResponse
     */
    'files_size': number;
    /**
     * Backups size in bytes
     * @type {number}
     * @memberof StorageStatsResponse
     */
    'backups_size': number;
    /**
     * Exports size in bytes
     * @type {number}
     * @memberof StorageStatsResponse
     */
    'exports_size': number;
    /**
     * Total number of records
     * @type {number}
     * @memberof StorageStatsResponse
     */
    'total_records': number;
    /**
     * Total number of files
     * @type {number}
     * @memberof StorageStatsResponse
     */
    'total_files': number;
    /**
     * Total number of backups
     * @type {number}
     * @memberof StorageStatsResponse
     */
    'total_backups': number;
    /**
     * Storage usage by data type
     * @type {{ [key: string]: number; }}
     * @memberof StorageStatsResponse
     */
    'storage_by_type': { [key: string]: number; };
    /**
     * Storage usage by user
     * @type {{ [key: string]: number; }}
     * @memberof StorageStatsResponse
     */
    'storage_by_user': { [key: string]: number; };
    /**
     * Storage growth rate in MB per day
     * @type {number}
     * @memberof StorageStatsResponse
     */
    'growth_rate_mb_per_day': number;
    /**
     * Projected size in 30 days
     * @type {number}
     * @memberof StorageStatsResponse
     */
    'projected_size_30_days': number;
    /**
     * Statistics last updated timestamp
     * @type {string}
     * @memberof StorageStatsResponse
     */
    'last_updated': string;
}
/**
 * Schema for system analytics response.
 * @export
 * @interface SystemAnalyticsResponse
 */
export interface SystemAnalyticsResponse {
    /**
     * Total number of users
     * @type {number}
     * @memberof SystemAnalyticsResponse
     */
    'total_users': number;
    /**
     * Active users today
     * @type {number}
     * @memberof SystemAnalyticsResponse
     */
    'active_users_today': number;
    /**
     * Active users this week
     * @type {number}
     * @memberof SystemAnalyticsResponse
     */
    'active_users_week': number;
    /**
     * Active users this month
     * @type {number}
     * @memberof SystemAnalyticsResponse
     */
    'active_users_month': number;
    /**
     * System uptime in seconds
     * @type {number}
     * @memberof SystemAnalyticsResponse
     */
    'system_uptime_seconds': number;
    /**
     * Average CPU usage percentage
     * @type {number}
     * @memberof SystemAnalyticsResponse
     */
    'avg_cpu_usage': number;
    /**
     * Average memory usage percentage
     * @type {number}
     * @memberof SystemAnalyticsResponse
     */
    'avg_memory_usage': number;
    /**
     * Current database connections
     * @type {number}
     * @memberof SystemAnalyticsResponse
     */
    'database_connections': number;
    /**
     * Total API requests
     * @type {number}
     * @memberof SystemAnalyticsResponse
     */
    'total_api_requests': number;
    /**
     * Requests by endpoint
     * @type {{ [key: string]: number; }}
     * @memberof SystemAnalyticsResponse
     */
    'requests_per_endpoint': { [key: string]: number; };
    /**
     * Average API response time
     * @type {number}
     * @memberof SystemAnalyticsResponse
     */
    'avg_api_response_time': number;
    /**
     * API error rate
     * @type {number}
     * @memberof SystemAnalyticsResponse
     */
    'api_error_rate': number;
    /**
     * Total storage usage
     * @type {number}
     * @memberof SystemAnalyticsResponse
     */
    'storage_usage_bytes': number;
    /**
     * Vector database size
     * @type {number}
     * @memberof SystemAnalyticsResponse
     */
    'vector_database_size_bytes': number;
    /**
     * Cache hit rate
     * @type {number}
     * @memberof SystemAnalyticsResponse
     */
    'cache_hit_rate': number;
}
/**
 * Response schema for test event.
 * @export
 * @interface TestEventResponse
 */
export interface TestEventResponse {
    /**
     * Response message
     * @type {string}
     * @memberof TestEventResponse
     */
    'message': string;
    /**
     * Generated event ID
     * @type {string}
     * @memberof TestEventResponse
     */
    'event_id': string;
}
/**
 * Test metric data.
 * @export
 * @interface TestMetric
 */
export interface TestMetric {
    /**
     * Type of metric
     * @type {MetricType}
     * @memberof TestMetric
     */
    'metric_type': MetricType;
    /**
     * Variant name
     * @type {string}
     * @memberof TestMetric
     */
    'variant_name': string;
    /**
     * Metric value
     * @type {number}
     * @memberof TestMetric
     */
    'value': number;
    /**
     * Sample size
     * @type {number}
     * @memberof TestMetric
     */
    'sample_size': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof TestMetric
     */
    'confidence_interval'?: Array<number> | null;
}


/**
 * A/B test status.
 * @export
 * @enum {string}
 */

export const TestStatus = {
    draft: 'draft',
    running: 'running',
    paused: 'paused',
    completed: 'completed',
    cancelled: 'cancelled'
} as const;

export type TestStatus = typeof TestStatus[keyof typeof TestStatus];


/**
 * Types of A/B tests.
 * @export
 * @enum {string}
 */

export const TestType = {
    prompt: 'prompt',
    model: 'model',
    parameter: 'parameter',
    workflow: 'workflow',
    template: 'template'
} as const;

export type TestType = typeof TestType[keyof typeof TestType];


/**
 * Test variant definition.
 * @export
 * @interface TestVariant
 */
export interface TestVariant {
    /**
     * Variant name
     * @type {string}
     * @memberof TestVariant
     */
    'name': string;
    /**
     * Variant description
     * @type {string}
     * @memberof TestVariant
     */
    'description': string;
    /**
     * Variant configuration
     * @type {{ [key: string]: any; }}
     * @memberof TestVariant
     */
    'configuration': { [key: string]: any; };
    /**
     * Variant weight for allocation
     * @type {number}
     * @memberof TestVariant
     */
    'weight'?: number;
}
/**
 * Schema for token refresh request.
 * @export
 * @interface TokenRefresh
 */
export interface TokenRefresh {
    /**
     * Refresh token
     * @type {string}
     * @memberof TokenRefresh
     */
    'refresh_token': string;
}
/**
 * Schema for token refresh response.
 * @export
 * @interface TokenRefreshResponse
 */
export interface TokenRefreshResponse {
    /**
     * New access token
     * @type {string}
     * @memberof TokenRefreshResponse
     */
    'access_token': string;
    /**
     * New refresh token
     * @type {string}
     * @memberof TokenRefreshResponse
     */
    'refresh_token': string;
    /**
     * Token type
     * @type {string}
     * @memberof TokenRefreshResponse
     */
    'token_type'?: string;
    /**
     * Token expiration time in seconds
     * @type {number}
     * @memberof TokenRefreshResponse
     */
    'expires_in': number;
}
/**
 * Schema for authentication token response.
 * @export
 * @interface TokenResponse
 */
export interface TokenResponse {
    /**
     * JWT access token
     * @type {string}
     * @memberof TokenResponse
     */
    'access_token': string;
    /**
     * JWT refresh token
     * @type {string}
     * @memberof TokenResponse
     */
    'refresh_token': string;
    /**
     * Token type
     * @type {string}
     * @memberof TokenResponse
     */
    'token_type'?: string;
    /**
     * Token expiration time in seconds
     * @type {number}
     * @memberof TokenResponse
     */
    'expires_in': number;
    /**
     * User information
     * @type {UserResponse}
     * @memberof TokenResponse
     */
    'user': UserResponse;
}
/**
 * Schema for tool operation response.
 * @export
 * @interface ToolOperationResponse
 */
export interface ToolOperationResponse {
    /**
     * Operation success status
     * @type {boolean}
     * @memberof ToolOperationResponse
     */
    'success': boolean;
    /**
     * Operation result message
     * @type {string}
     * @memberof ToolOperationResponse
     */
    'message': string;
}
/**
 * Schema for creating a tool server.
 * @export
 * @interface ToolServerCreate
 */
export interface ToolServerCreate {
    /**
     * Server name
     * @type {string}
     * @memberof ToolServerCreate
     */
    'name': string;
    /**
     * Display name
     * @type {string}
     * @memberof ToolServerCreate
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof ToolServerCreate
     */
    'description'?: string | null;
    /**
     * Command to start server
     * @type {string}
     * @memberof ToolServerCreate
     */
    'command': string;
    /**
     * Command arguments
     * @type {Array<string>}
     * @memberof ToolServerCreate
     */
    'args'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ToolServerCreate
     */
    'env'?: { [key: string]: string; } | null;
    /**
     * Auto-start server on system startup
     * @type {boolean}
     * @memberof ToolServerCreate
     */
    'auto_start'?: boolean;
    /**
     * Auto-update server capabilities
     * @type {boolean}
     * @memberof ToolServerCreate
     */
    'auto_update'?: boolean;
    /**
     * Maximum consecutive failures before disabling
     * @type {number}
     * @memberof ToolServerCreate
     */
    'max_failures'?: number;
}
/**
 * Schema for tool server delete response.
 * @export
 * @interface ToolServerDeleteResponse
 */
export interface ToolServerDeleteResponse {
    /**
     * Success message
     * @type {string}
     * @memberof ToolServerDeleteResponse
     */
    'message': string;
}
/**
 * Schema for tool server health check.
 * @export
 * @interface ToolServerHealthCheck
 */
export interface ToolServerHealthCheck {
    /**
     * Server ID
     * @type {string}
     * @memberof ToolServerHealthCheck
     */
    'server_id': string;
    /**
     * Server name
     * @type {string}
     * @memberof ToolServerHealthCheck
     */
    'server_name': string;
    /**
     * Server status
     * @type {ServerStatus}
     * @memberof ToolServerHealthCheck
     */
    'status': ServerStatus;
    /**
     * Whether server is running
     * @type {boolean}
     * @memberof ToolServerHealthCheck
     */
    'is_running': boolean;
    /**
     * Whether server is responsive
     * @type {boolean}
     * @memberof ToolServerHealthCheck
     */
    'is_responsive': boolean;
    /**
     * Number of available tools
     * @type {number}
     * @memberof ToolServerHealthCheck
     */
    'tools_count': number;
    /**
     * Last health check time
     * @type {string}
     * @memberof ToolServerHealthCheck
     */
    'last_check': string;
    /**
     * 
     * @type {string}
     * @memberof ToolServerHealthCheck
     */
    'error_message'?: string | null;
}


/**
 * Schema for tool server metrics.
 * @export
 * @interface ToolServerMetrics
 */
export interface ToolServerMetrics {
    /**
     * Server ID
     * @type {string}
     * @memberof ToolServerMetrics
     */
    'server_id': string;
    /**
     * Server name
     * @type {string}
     * @memberof ToolServerMetrics
     */
    'server_name': string;
    /**
     * Server status
     * @type {ServerStatus}
     * @memberof ToolServerMetrics
     */
    'status': ServerStatus;
    /**
     * Total number of tools
     * @type {number}
     * @memberof ToolServerMetrics
     */
    'total_tools': number;
    /**
     * Number of enabled tools
     * @type {number}
     * @memberof ToolServerMetrics
     */
    'enabled_tools': number;
    /**
     * Total tool calls
     * @type {number}
     * @memberof ToolServerMetrics
     */
    'total_calls': number;
    /**
     * Total errors
     * @type {number}
     * @memberof ToolServerMetrics
     */
    'total_errors': number;
    /**
     * Success rate
     * @type {number}
     * @memberof ToolServerMetrics
     */
    'success_rate': number;
    /**
     * 
     * @type {number}
     * @memberof ToolServerMetrics
     */
    'avg_response_time_ms'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof ToolServerMetrics
     */
    'last_activity'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof ToolServerMetrics
     */
    'uptime_percentage'?: number | null;
}


/**
 * Schema for tool server operation response.
 * @export
 * @interface ToolServerOperationResponse
 */
export interface ToolServerOperationResponse {
    /**
     * Operation success status
     * @type {boolean}
     * @memberof ToolServerOperationResponse
     */
    'success': boolean;
    /**
     * Operation result message
     * @type {string}
     * @memberof ToolServerOperationResponse
     */
    'message': string;
}
/**
 * Schema for tool server response.
 * @export
 * @interface ToolServerResponse
 */
export interface ToolServerResponse {
    /**
     * Server name
     * @type {string}
     * @memberof ToolServerResponse
     */
    'name': string;
    /**
     * Display name
     * @type {string}
     * @memberof ToolServerResponse
     */
    'display_name': string;
    /**
     * 
     * @type {string}
     * @memberof ToolServerResponse
     */
    'description'?: string | null;
    /**
     * Command to start server
     * @type {string}
     * @memberof ToolServerResponse
     */
    'command': string;
    /**
     * Command arguments
     * @type {Array<string>}
     * @memberof ToolServerResponse
     */
    'args'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ToolServerResponse
     */
    'env'?: { [key: string]: string; } | null;
    /**
     * Auto-start server on system startup
     * @type {boolean}
     * @memberof ToolServerResponse
     */
    'auto_start'?: boolean;
    /**
     * Auto-update server capabilities
     * @type {boolean}
     * @memberof ToolServerResponse
     */
    'auto_update'?: boolean;
    /**
     * Maximum consecutive failures before disabling
     * @type {number}
     * @memberof ToolServerResponse
     */
    'max_failures'?: number;
    /**
     * Server ID
     * @type {string}
     * @memberof ToolServerResponse
     */
    'id': string;
    /**
     * Server status
     * @type {ServerStatus}
     * @memberof ToolServerResponse
     */
    'status': ServerStatus;
    /**
     * Whether server is built-in
     * @type {boolean}
     * @memberof ToolServerResponse
     */
    'is_builtin': boolean;
    /**
     * 
     * @type {string}
     * @memberof ToolServerResponse
     */
    'last_health_check'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ToolServerResponse
     */
    'last_startup_success'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ToolServerResponse
     */
    'last_startup_error'?: string | null;
    /**
     * Consecutive failure count
     * @type {number}
     * @memberof ToolServerResponse
     */
    'consecutive_failures': number;
    /**
     * Creation timestamp
     * @type {string}
     * @memberof ToolServerResponse
     */
    'created_at': string;
    /**
     * Last update timestamp
     * @type {string}
     * @memberof ToolServerResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof ToolServerResponse
     */
    'created_by'?: string | null;
    /**
     * Server tools
     * @type {Array<ServerToolResponse>}
     * @memberof ToolServerResponse
     */
    'tools'?: Array<ServerToolResponse>;
}


/**
 * Schema for updating a tool server.
 * @export
 * @interface ToolServerUpdate
 */
export interface ToolServerUpdate {
    /**
     * 
     * @type {string}
     * @memberof ToolServerUpdate
     */
    'display_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ToolServerUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ToolServerUpdate
     */
    'command'?: string | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof ToolServerUpdate
     */
    'args'?: Array<string> | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ToolServerUpdate
     */
    'env'?: { [key: string]: string; } | null;
    /**
     * 
     * @type {boolean}
     * @memberof ToolServerUpdate
     */
    'auto_start'?: boolean | null;
    /**
     * 
     * @type {boolean}
     * @memberof ToolServerUpdate
     */
    'auto_update'?: boolean | null;
    /**
     * 
     * @type {number}
     * @memberof ToolServerUpdate
     */
    'max_failures'?: number | null;
}
/**
 * Enumeration for tool status.
 * @export
 * @enum {string}
 */

export const ToolStatus = {
    enabled: 'enabled',
    disabled: 'disabled',
    unavailable: 'unavailable',
    error: 'error'
} as const;

export type ToolStatus = typeof ToolStatus[keyof typeof ToolStatus];


/**
 * Schema for usage metrics response.
 * @export
 * @interface UsageMetricsResponse
 */
export interface UsageMetricsResponse {
    /**
     * Total prompt tokens
     * @type {number}
     * @memberof UsageMetricsResponse
     */
    'total_prompt_tokens': number;
    /**
     * Total completion tokens
     * @type {number}
     * @memberof UsageMetricsResponse
     */
    'total_completion_tokens': number;
    /**
     * Total tokens used
     * @type {number}
     * @memberof UsageMetricsResponse
     */
    'total_tokens': number;
    /**
     * Token usage by model
     * @type {{ [key: string]: number; }}
     * @memberof UsageMetricsResponse
     */
    'tokens_by_model': { [key: string]: number; };
    /**
     * Token usage by provider
     * @type {{ [key: string]: number; }}
     * @memberof UsageMetricsResponse
     */
    'tokens_by_provider': { [key: string]: number; };
    /**
     * Total cost
     * @type {number}
     * @memberof UsageMetricsResponse
     */
    'total_cost': number;
    /**
     * Cost by model
     * @type {{ [key: string]: number; }}
     * @memberof UsageMetricsResponse
     */
    'cost_by_model': { [key: string]: number; };
    /**
     * Cost by provider
     * @type {{ [key: string]: number; }}
     * @memberof UsageMetricsResponse
     */
    'cost_by_provider': { [key: string]: number; };
    /**
     * Daily token usage
     * @type {{ [key: string]: number; }}
     * @memberof UsageMetricsResponse
     */
    'daily_usage': { [key: string]: number; };
    /**
     * Daily cost
     * @type {{ [key: string]: number; }}
     * @memberof UsageMetricsResponse
     */
    'daily_cost': { [key: string]: number; };
    /**
     * Average response time
     * @type {number}
     * @memberof UsageMetricsResponse
     */
    'avg_response_time': number;
    /**
     * Response times by model
     * @type {{ [key: string]: number; }}
     * @memberof UsageMetricsResponse
     */
    'response_times_by_model': { [key: string]: number; };
    /**
     * Number of active days
     * @type {number}
     * @memberof UsageMetricsResponse
     */
    'active_days': number;
    /**
     * Peak usage hour
     * @type {number}
     * @memberof UsageMetricsResponse
     */
    'peak_usage_hour': number;
    /**
     * Average conversations per day
     * @type {number}
     * @memberof UsageMetricsResponse
     */
    'conversations_per_day': number;
}
/**
 * Schema for user registration.
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * User email address
     * @type {string}
     * @memberof UserCreate
     */
    'email': string;
    /**
     * Username
     * @type {string}
     * @memberof UserCreate
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'full_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'bio'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'avatar_url'?: string | null;
    /**
     * Password
     * @type {string}
     * @memberof UserCreate
     */
    'password': string;
}
/**
 * Schema for user login.
 * @export
 * @interface UserLogin
 */
export interface UserLogin {
    /**
     * Username
     * @type {string}
     * @memberof UserLogin
     */
    'username': string;
    /**
     * Password
     * @type {string}
     * @memberof UserLogin
     */
    'password': string;
}
/**
 * Schema for user response.
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * User email address
     * @type {string}
     * @memberof UserResponse
     */
    'email': string;
    /**
     * Username
     * @type {string}
     * @memberof UserResponse
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'full_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'bio'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'avatar_url'?: string | null;
    /**
     * User ID
     * @type {string}
     * @memberof UserResponse
     */
    'id': string;
    /**
     * Is user active
     * @type {boolean}
     * @memberof UserResponse
     */
    'is_active': boolean;
    /**
     * Is user email verified
     * @type {boolean}
     * @memberof UserResponse
     */
    'is_verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'default_llm_provider'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'default_profile_id'?: string | null;
    /**
     * Account creation date
     * @type {string}
     * @memberof UserResponse
     */
    'created_at': string;
    /**
     * Last update date
     * @type {string}
     * @memberof UserResponse
     */
    'updated_at': string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'last_login_at'?: string | null;
}
/**
 * Schema for user profile updates.
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'full_name'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'bio'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'avatar_url'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'default_llm_provider'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'default_profile_id'?: string | null;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<ValidationErrorLocInner>}
     * @memberof ValidationError
     */
    'loc': Array<ValidationErrorLocInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}
/**
 * 
 * @export
 * @interface ValidationErrorLocInner
 */
export interface ValidationErrorLocInner {
}
/**
 * Variant allocation strategies.
 * @export
 * @enum {string}
 */

export const VariantAllocation = {
    equal: 'equal',
    weighted: 'weighted',
    gradual_rollout: 'gradual_rollout',
    user_attribute: 'user_attribute'
} as const;

export type VariantAllocation = typeof VariantAllocation[keyof typeof VariantAllocation];



/**
 * ABTestingApi - axios parameter creator
 * @export
 */
export const ABTestingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Complete an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action result
         * @summary Complete Ab Test
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeAbTestApiV1AbTestsTestIdCompletePost: async (testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('completeAbTestApiV1AbTestsTestIdCompletePost', 'testId', testId)
            const localVarPath = `/api/v1/ab-tests/{test_id}/complete`
                .replace(`{${"test_id"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new A/B test.  Args:     test_data: A/B test creation data     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Created test data
         * @summary Create Ab Test
         * @param {ABTestCreateRequest} aBTestCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAbTestApiV1AbTestsPost: async (aBTestCreateRequest: ABTestCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aBTestCreateRequest' is not null or undefined
            assertParamExists('createAbTestApiV1AbTestsPost', 'aBTestCreateRequest', aBTestCreateRequest)
            const localVarPath = `/api/v1/ab-tests/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aBTestCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Deletion result
         * @summary Delete Ab Test
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAbTestApiV1AbTestsTestIdDelete: async (testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('deleteAbTestApiV1AbTestsTestIdDelete', 'testId', testId)
            const localVarPath = `/api/v1/ab-tests/{test_id}`
                .replace(`{${"test_id"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * End A/B test and declare winner.  Args:     test_id: A/B test ID     winner_variant: Winning variant identifier     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action response
         * @summary End Ab Test
         * @param {string} testId 
         * @param {string} winnerVariant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endAbTestApiV1AbTestsTestIdEndPost: async (testId: string, winnerVariant: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('endAbTestApiV1AbTestsTestIdEndPost', 'testId', testId)
            // verify required parameter 'winnerVariant' is not null or undefined
            assertParamExists('endAbTestApiV1AbTestsTestIdEndPost', 'winnerVariant', winnerVariant)
            const localVarPath = `/api/v1/ab-tests/{test_id}/end`
                .replace(`{${"test_id"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (winnerVariant !== undefined) {
                localVarQueryParameter['winner_variant'] = winnerVariant;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get A/B test by ID.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     A/B test data
         * @summary Get Ab Test
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbTestApiV1AbTestsTestIdGet: async (testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getAbTestApiV1AbTestsTestIdGet', 'testId', testId)
            const localVarPath = `/api/v1/ab-tests/{test_id}`
                .replace(`{${"test_id"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current A/B test metrics.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Current test metrics
         * @summary Get Ab Test Metrics
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbTestMetricsApiV1AbTestsTestIdMetricsGet: async (testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getAbTestMetricsApiV1AbTestsTestIdMetricsGet', 'testId', testId)
            const localVarPath = `/api/v1/ab-tests/{test_id}/metrics`
                .replace(`{${"test_id"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get A/B test performance results by variant.  Args:     test_id: A/B test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Performance results per variant
         * @summary Get Ab Test Performance
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbTestPerformanceApiV1AbTestsTestIdPerformanceGet: async (testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getAbTestPerformanceApiV1AbTestsTestIdPerformanceGet', 'testId', testId)
            const localVarPath = `/api/v1/ab-tests/{test_id}/performance`
                .replace(`{${"test_id"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get A/B test results and analysis.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Test results and analysis
         * @summary Get Ab Test Results
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbTestResultsApiV1AbTestsTestIdResultsGet: async (testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('getAbTestResultsApiV1AbTestsTestIdResultsGet', 'testId', testId)
            const localVarPath = `/api/v1/ab-tests/{test_id}/results`
                .replace(`{${"test_id"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List A/B tests with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     List of A/B tests
         * @summary List Ab Tests
         * @param {TestStatus | null} [status] 
         * @param {TestType | null} [testType] 
         * @param {Array<string> | null} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAbTestsApiV1AbTestsGet: async (status?: TestStatus | null, testType?: TestType | null, requestBody?: Array<string> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ab-tests/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (testType !== undefined) {
                localVarQueryParameter['test_type'] = testType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pause an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action result
         * @summary Pause Ab Test
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseAbTestApiV1AbTestsTestIdPausePost: async (testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('pauseAbTestApiV1AbTestsTestIdPausePost', 'testId', testId)
            const localVarPath = `/api/v1/ab-tests/{test_id}/pause`
                .replace(`{${"test_id"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action result
         * @summary Start Ab Test
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startAbTestApiV1AbTestsTestIdStartPost: async (testId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('startAbTestApiV1AbTestsTestIdStartPost', 'testId', testId)
            const localVarPath = `/api/v1/ab-tests/{test_id}/start`
                .replace(`{${"test_id"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an A/B test.  Args:     test_id: Test ID     test_data: Test update data     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Updated test data
         * @summary Update Ab Test
         * @param {string} testId 
         * @param {ABTestUpdateRequest} aBTestUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAbTestApiV1AbTestsTestIdPut: async (testId: string, aBTestUpdateRequest: ABTestUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'testId' is not null or undefined
            assertParamExists('updateAbTestApiV1AbTestsTestIdPut', 'testId', testId)
            // verify required parameter 'aBTestUpdateRequest' is not null or undefined
            assertParamExists('updateAbTestApiV1AbTestsTestIdPut', 'aBTestUpdateRequest', aBTestUpdateRequest)
            const localVarPath = `/api/v1/ab-tests/{test_id}`
                .replace(`{${"test_id"}}`, encodeURIComponent(String(testId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aBTestUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ABTestingApi - functional programming interface
 * @export
 */
export const ABTestingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ABTestingApiAxiosParamCreator(configuration)
    return {
        /**
         * Complete an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action result
         * @summary Complete Ab Test
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async completeAbTestApiV1AbTestsTestIdCompletePost(testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ABTestActionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.completeAbTestApiV1AbTestsTestIdCompletePost(testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ABTestingApi.completeAbTestApiV1AbTestsTestIdCompletePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new A/B test.  Args:     test_data: A/B test creation data     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Created test data
         * @summary Create Ab Test
         * @param {ABTestCreateRequest} aBTestCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAbTestApiV1AbTestsPost(aBTestCreateRequest: ABTestCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ABTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAbTestApiV1AbTestsPost(aBTestCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ABTestingApi.createAbTestApiV1AbTestsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Deletion result
         * @summary Delete Ab Test
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAbTestApiV1AbTestsTestIdDelete(testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ABTestDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAbTestApiV1AbTestsTestIdDelete(testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ABTestingApi.deleteAbTestApiV1AbTestsTestIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * End A/B test and declare winner.  Args:     test_id: A/B test ID     winner_variant: Winning variant identifier     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action response
         * @summary End Ab Test
         * @param {string} testId 
         * @param {string} winnerVariant 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endAbTestApiV1AbTestsTestIdEndPost(testId: string, winnerVariant: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ABTestActionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endAbTestApiV1AbTestsTestIdEndPost(testId, winnerVariant, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ABTestingApi.endAbTestApiV1AbTestsTestIdEndPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get A/B test by ID.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     A/B test data
         * @summary Get Ab Test
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAbTestApiV1AbTestsTestIdGet(testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ABTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAbTestApiV1AbTestsTestIdGet(testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ABTestingApi.getAbTestApiV1AbTestsTestIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current A/B test metrics.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Current test metrics
         * @summary Get Ab Test Metrics
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAbTestMetricsApiV1AbTestsTestIdMetricsGet(testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ABTestMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAbTestMetricsApiV1AbTestsTestIdMetricsGet(testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ABTestingApi.getAbTestMetricsApiV1AbTestsTestIdMetricsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get A/B test performance results by variant.  Args:     test_id: A/B test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Performance results per variant
         * @summary Get Ab Test Performance
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAbTestPerformanceApiV1AbTestsTestIdPerformanceGet(testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAbTestPerformanceApiV1AbTestsTestIdPerformanceGet(testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ABTestingApi.getAbTestPerformanceApiV1AbTestsTestIdPerformanceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get A/B test results and analysis.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Test results and analysis
         * @summary Get Ab Test Results
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAbTestResultsApiV1AbTestsTestIdResultsGet(testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ABTestResultsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAbTestResultsApiV1AbTestsTestIdResultsGet(testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ABTestingApi.getAbTestResultsApiV1AbTestsTestIdResultsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List A/B tests with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     List of A/B tests
         * @summary List Ab Tests
         * @param {TestStatus | null} [status] 
         * @param {TestType | null} [testType] 
         * @param {Array<string> | null} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAbTestsApiV1AbTestsGet(status?: TestStatus | null, testType?: TestType | null, requestBody?: Array<string> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ABTestListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAbTestsApiV1AbTestsGet(status, testType, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ABTestingApi.listAbTestsApiV1AbTestsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Pause an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action result
         * @summary Pause Ab Test
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pauseAbTestApiV1AbTestsTestIdPausePost(testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ABTestActionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pauseAbTestApiV1AbTestsTestIdPausePost(testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ABTestingApi.pauseAbTestApiV1AbTestsTestIdPausePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action result
         * @summary Start Ab Test
         * @param {string} testId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startAbTestApiV1AbTestsTestIdStartPost(testId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ABTestActionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startAbTestApiV1AbTestsTestIdStartPost(testId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ABTestingApi.startAbTestApiV1AbTestsTestIdStartPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an A/B test.  Args:     test_id: Test ID     test_data: Test update data     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Updated test data
         * @summary Update Ab Test
         * @param {string} testId 
         * @param {ABTestUpdateRequest} aBTestUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAbTestApiV1AbTestsTestIdPut(testId: string, aBTestUpdateRequest: ABTestUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ABTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAbTestApiV1AbTestsTestIdPut(testId, aBTestUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ABTestingApi.updateAbTestApiV1AbTestsTestIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ABTestingApi - factory interface
 * @export
 */
export const ABTestingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ABTestingApiFp(configuration)
    return {
        /**
         * Complete an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action result
         * @summary Complete Ab Test
         * @param {ABTestingApiCompleteAbTestApiV1AbTestsTestIdCompletePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeAbTestApiV1AbTestsTestIdCompletePost(requestParameters: ABTestingApiCompleteAbTestApiV1AbTestsTestIdCompletePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestActionResponse> {
            return localVarFp.completeAbTestApiV1AbTestsTestIdCompletePost(requestParameters.testId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new A/B test.  Args:     test_data: A/B test creation data     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Created test data
         * @summary Create Ab Test
         * @param {ABTestingApiCreateAbTestApiV1AbTestsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAbTestApiV1AbTestsPost(requestParameters: ABTestingApiCreateAbTestApiV1AbTestsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestResponse> {
            return localVarFp.createAbTestApiV1AbTestsPost(requestParameters.aBTestCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Deletion result
         * @summary Delete Ab Test
         * @param {ABTestingApiDeleteAbTestApiV1AbTestsTestIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAbTestApiV1AbTestsTestIdDelete(requestParameters: ABTestingApiDeleteAbTestApiV1AbTestsTestIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestDeleteResponse> {
            return localVarFp.deleteAbTestApiV1AbTestsTestIdDelete(requestParameters.testId, options).then((request) => request(axios, basePath));
        },
        /**
         * End A/B test and declare winner.  Args:     test_id: A/B test ID     winner_variant: Winning variant identifier     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action response
         * @summary End Ab Test
         * @param {ABTestingApiEndAbTestApiV1AbTestsTestIdEndPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endAbTestApiV1AbTestsTestIdEndPost(requestParameters: ABTestingApiEndAbTestApiV1AbTestsTestIdEndPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestActionResponse> {
            return localVarFp.endAbTestApiV1AbTestsTestIdEndPost(requestParameters.testId, requestParameters.winnerVariant, options).then((request) => request(axios, basePath));
        },
        /**
         * Get A/B test by ID.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     A/B test data
         * @summary Get Ab Test
         * @param {ABTestingApiGetAbTestApiV1AbTestsTestIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbTestApiV1AbTestsTestIdGet(requestParameters: ABTestingApiGetAbTestApiV1AbTestsTestIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestResponse> {
            return localVarFp.getAbTestApiV1AbTestsTestIdGet(requestParameters.testId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get current A/B test metrics.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Current test metrics
         * @summary Get Ab Test Metrics
         * @param {ABTestingApiGetAbTestMetricsApiV1AbTestsTestIdMetricsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbTestMetricsApiV1AbTestsTestIdMetricsGet(requestParameters: ABTestingApiGetAbTestMetricsApiV1AbTestsTestIdMetricsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestMetricsResponse> {
            return localVarFp.getAbTestMetricsApiV1AbTestsTestIdMetricsGet(requestParameters.testId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get A/B test performance results by variant.  Args:     test_id: A/B test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Performance results per variant
         * @summary Get Ab Test Performance
         * @param {ABTestingApiGetAbTestPerformanceApiV1AbTestsTestIdPerformanceGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbTestPerformanceApiV1AbTestsTestIdPerformanceGet(requestParameters: ABTestingApiGetAbTestPerformanceApiV1AbTestsTestIdPerformanceGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getAbTestPerformanceApiV1AbTestsTestIdPerformanceGet(requestParameters.testId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get A/B test results and analysis.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Test results and analysis
         * @summary Get Ab Test Results
         * @param {ABTestingApiGetAbTestResultsApiV1AbTestsTestIdResultsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAbTestResultsApiV1AbTestsTestIdResultsGet(requestParameters: ABTestingApiGetAbTestResultsApiV1AbTestsTestIdResultsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestResultsResponse> {
            return localVarFp.getAbTestResultsApiV1AbTestsTestIdResultsGet(requestParameters.testId, options).then((request) => request(axios, basePath));
        },
        /**
         * List A/B tests with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     List of A/B tests
         * @summary List Ab Tests
         * @param {ABTestingApiListAbTestsApiV1AbTestsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAbTestsApiV1AbTestsGet(requestParameters: ABTestingApiListAbTestsApiV1AbTestsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ABTestListResponse> {
            return localVarFp.listAbTestsApiV1AbTestsGet(requestParameters.status, requestParameters.testType, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Pause an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action result
         * @summary Pause Ab Test
         * @param {ABTestingApiPauseAbTestApiV1AbTestsTestIdPausePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseAbTestApiV1AbTestsTestIdPausePost(requestParameters: ABTestingApiPauseAbTestApiV1AbTestsTestIdPausePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestActionResponse> {
            return localVarFp.pauseAbTestApiV1AbTestsTestIdPausePost(requestParameters.testId, options).then((request) => request(axios, basePath));
        },
        /**
         * Start an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action result
         * @summary Start Ab Test
         * @param {ABTestingApiStartAbTestApiV1AbTestsTestIdStartPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startAbTestApiV1AbTestsTestIdStartPost(requestParameters: ABTestingApiStartAbTestApiV1AbTestsTestIdStartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestActionResponse> {
            return localVarFp.startAbTestApiV1AbTestsTestIdStartPost(requestParameters.testId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an A/B test.  Args:     test_id: Test ID     test_data: Test update data     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Updated test data
         * @summary Update Ab Test
         * @param {ABTestingApiUpdateAbTestApiV1AbTestsTestIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAbTestApiV1AbTestsTestIdPut(requestParameters: ABTestingApiUpdateAbTestApiV1AbTestsTestIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestResponse> {
            return localVarFp.updateAbTestApiV1AbTestsTestIdPut(requestParameters.testId, requestParameters.aBTestUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ABTestingApi - interface
 * @export
 * @interface ABTestingApi
 */
export interface ABTestingApiInterface {
    /**
     * Complete an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action result
     * @summary Complete Ab Test
     * @param {ABTestingApiCompleteAbTestApiV1AbTestsTestIdCompletePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApiInterface
     */
    completeAbTestApiV1AbTestsTestIdCompletePost(requestParameters: ABTestingApiCompleteAbTestApiV1AbTestsTestIdCompletePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestActionResponse>;

    /**
     * Create a new A/B test.  Args:     test_data: A/B test creation data     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Created test data
     * @summary Create Ab Test
     * @param {ABTestingApiCreateAbTestApiV1AbTestsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApiInterface
     */
    createAbTestApiV1AbTestsPost(requestParameters: ABTestingApiCreateAbTestApiV1AbTestsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestResponse>;

    /**
     * Delete an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Deletion result
     * @summary Delete Ab Test
     * @param {ABTestingApiDeleteAbTestApiV1AbTestsTestIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApiInterface
     */
    deleteAbTestApiV1AbTestsTestIdDelete(requestParameters: ABTestingApiDeleteAbTestApiV1AbTestsTestIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestDeleteResponse>;

    /**
     * End A/B test and declare winner.  Args:     test_id: A/B test ID     winner_variant: Winning variant identifier     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action response
     * @summary End Ab Test
     * @param {ABTestingApiEndAbTestApiV1AbTestsTestIdEndPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApiInterface
     */
    endAbTestApiV1AbTestsTestIdEndPost(requestParameters: ABTestingApiEndAbTestApiV1AbTestsTestIdEndPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestActionResponse>;

    /**
     * Get A/B test by ID.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     A/B test data
     * @summary Get Ab Test
     * @param {ABTestingApiGetAbTestApiV1AbTestsTestIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApiInterface
     */
    getAbTestApiV1AbTestsTestIdGet(requestParameters: ABTestingApiGetAbTestApiV1AbTestsTestIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestResponse>;

    /**
     * Get current A/B test metrics.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Current test metrics
     * @summary Get Ab Test Metrics
     * @param {ABTestingApiGetAbTestMetricsApiV1AbTestsTestIdMetricsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApiInterface
     */
    getAbTestMetricsApiV1AbTestsTestIdMetricsGet(requestParameters: ABTestingApiGetAbTestMetricsApiV1AbTestsTestIdMetricsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestMetricsResponse>;

    /**
     * Get A/B test performance results by variant.  Args:     test_id: A/B test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Performance results per variant
     * @summary Get Ab Test Performance
     * @param {ABTestingApiGetAbTestPerformanceApiV1AbTestsTestIdPerformanceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApiInterface
     */
    getAbTestPerformanceApiV1AbTestsTestIdPerformanceGet(requestParameters: ABTestingApiGetAbTestPerformanceApiV1AbTestsTestIdPerformanceGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

    /**
     * Get A/B test results and analysis.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Test results and analysis
     * @summary Get Ab Test Results
     * @param {ABTestingApiGetAbTestResultsApiV1AbTestsTestIdResultsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApiInterface
     */
    getAbTestResultsApiV1AbTestsTestIdResultsGet(requestParameters: ABTestingApiGetAbTestResultsApiV1AbTestsTestIdResultsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestResultsResponse>;

    /**
     * List A/B tests with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     List of A/B tests
     * @summary List Ab Tests
     * @param {ABTestingApiListAbTestsApiV1AbTestsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApiInterface
     */
    listAbTestsApiV1AbTestsGet(requestParameters?: ABTestingApiListAbTestsApiV1AbTestsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestListResponse>;

    /**
     * Pause an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action result
     * @summary Pause Ab Test
     * @param {ABTestingApiPauseAbTestApiV1AbTestsTestIdPausePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApiInterface
     */
    pauseAbTestApiV1AbTestsTestIdPausePost(requestParameters: ABTestingApiPauseAbTestApiV1AbTestsTestIdPausePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestActionResponse>;

    /**
     * Start an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action result
     * @summary Start Ab Test
     * @param {ABTestingApiStartAbTestApiV1AbTestsTestIdStartPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApiInterface
     */
    startAbTestApiV1AbTestsTestIdStartPost(requestParameters: ABTestingApiStartAbTestApiV1AbTestsTestIdStartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestActionResponse>;

    /**
     * Update an A/B test.  Args:     test_id: Test ID     test_data: Test update data     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Updated test data
     * @summary Update Ab Test
     * @param {ABTestingApiUpdateAbTestApiV1AbTestsTestIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApiInterface
     */
    updateAbTestApiV1AbTestsTestIdPut(requestParameters: ABTestingApiUpdateAbTestApiV1AbTestsTestIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ABTestResponse>;

}

/**
 * Request parameters for completeAbTestApiV1AbTestsTestIdCompletePost operation in ABTestingApi.
 * @export
 * @interface ABTestingApiCompleteAbTestApiV1AbTestsTestIdCompletePostRequest
 */
export interface ABTestingApiCompleteAbTestApiV1AbTestsTestIdCompletePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ABTestingApiCompleteAbTestApiV1AbTestsTestIdCompletePost
     */
    readonly testId: string
}

/**
 * Request parameters for createAbTestApiV1AbTestsPost operation in ABTestingApi.
 * @export
 * @interface ABTestingApiCreateAbTestApiV1AbTestsPostRequest
 */
export interface ABTestingApiCreateAbTestApiV1AbTestsPostRequest {
    /**
     * 
     * @type {ABTestCreateRequest}
     * @memberof ABTestingApiCreateAbTestApiV1AbTestsPost
     */
    readonly aBTestCreateRequest: ABTestCreateRequest
}

/**
 * Request parameters for deleteAbTestApiV1AbTestsTestIdDelete operation in ABTestingApi.
 * @export
 * @interface ABTestingApiDeleteAbTestApiV1AbTestsTestIdDeleteRequest
 */
export interface ABTestingApiDeleteAbTestApiV1AbTestsTestIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ABTestingApiDeleteAbTestApiV1AbTestsTestIdDelete
     */
    readonly testId: string
}

/**
 * Request parameters for endAbTestApiV1AbTestsTestIdEndPost operation in ABTestingApi.
 * @export
 * @interface ABTestingApiEndAbTestApiV1AbTestsTestIdEndPostRequest
 */
export interface ABTestingApiEndAbTestApiV1AbTestsTestIdEndPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ABTestingApiEndAbTestApiV1AbTestsTestIdEndPost
     */
    readonly testId: string

    /**
     * 
     * @type {string}
     * @memberof ABTestingApiEndAbTestApiV1AbTestsTestIdEndPost
     */
    readonly winnerVariant: string
}

/**
 * Request parameters for getAbTestApiV1AbTestsTestIdGet operation in ABTestingApi.
 * @export
 * @interface ABTestingApiGetAbTestApiV1AbTestsTestIdGetRequest
 */
export interface ABTestingApiGetAbTestApiV1AbTestsTestIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ABTestingApiGetAbTestApiV1AbTestsTestIdGet
     */
    readonly testId: string
}

/**
 * Request parameters for getAbTestMetricsApiV1AbTestsTestIdMetricsGet operation in ABTestingApi.
 * @export
 * @interface ABTestingApiGetAbTestMetricsApiV1AbTestsTestIdMetricsGetRequest
 */
export interface ABTestingApiGetAbTestMetricsApiV1AbTestsTestIdMetricsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ABTestingApiGetAbTestMetricsApiV1AbTestsTestIdMetricsGet
     */
    readonly testId: string
}

/**
 * Request parameters for getAbTestPerformanceApiV1AbTestsTestIdPerformanceGet operation in ABTestingApi.
 * @export
 * @interface ABTestingApiGetAbTestPerformanceApiV1AbTestsTestIdPerformanceGetRequest
 */
export interface ABTestingApiGetAbTestPerformanceApiV1AbTestsTestIdPerformanceGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ABTestingApiGetAbTestPerformanceApiV1AbTestsTestIdPerformanceGet
     */
    readonly testId: string
}

/**
 * Request parameters for getAbTestResultsApiV1AbTestsTestIdResultsGet operation in ABTestingApi.
 * @export
 * @interface ABTestingApiGetAbTestResultsApiV1AbTestsTestIdResultsGetRequest
 */
export interface ABTestingApiGetAbTestResultsApiV1AbTestsTestIdResultsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ABTestingApiGetAbTestResultsApiV1AbTestsTestIdResultsGet
     */
    readonly testId: string
}

/**
 * Request parameters for listAbTestsApiV1AbTestsGet operation in ABTestingApi.
 * @export
 * @interface ABTestingApiListAbTestsApiV1AbTestsGetRequest
 */
export interface ABTestingApiListAbTestsApiV1AbTestsGetRequest {
    /**
     * 
     * @type {TestStatus}
     * @memberof ABTestingApiListAbTestsApiV1AbTestsGet
     */
    readonly status?: TestStatus | null

    /**
     * 
     * @type {TestType}
     * @memberof ABTestingApiListAbTestsApiV1AbTestsGet
     */
    readonly testType?: TestType | null

    /**
     * 
     * @type {Array<string>}
     * @memberof ABTestingApiListAbTestsApiV1AbTestsGet
     */
    readonly requestBody?: Array<string> | null
}

/**
 * Request parameters for pauseAbTestApiV1AbTestsTestIdPausePost operation in ABTestingApi.
 * @export
 * @interface ABTestingApiPauseAbTestApiV1AbTestsTestIdPausePostRequest
 */
export interface ABTestingApiPauseAbTestApiV1AbTestsTestIdPausePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ABTestingApiPauseAbTestApiV1AbTestsTestIdPausePost
     */
    readonly testId: string
}

/**
 * Request parameters for startAbTestApiV1AbTestsTestIdStartPost operation in ABTestingApi.
 * @export
 * @interface ABTestingApiStartAbTestApiV1AbTestsTestIdStartPostRequest
 */
export interface ABTestingApiStartAbTestApiV1AbTestsTestIdStartPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ABTestingApiStartAbTestApiV1AbTestsTestIdStartPost
     */
    readonly testId: string
}

/**
 * Request parameters for updateAbTestApiV1AbTestsTestIdPut operation in ABTestingApi.
 * @export
 * @interface ABTestingApiUpdateAbTestApiV1AbTestsTestIdPutRequest
 */
export interface ABTestingApiUpdateAbTestApiV1AbTestsTestIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ABTestingApiUpdateAbTestApiV1AbTestsTestIdPut
     */
    readonly testId: string

    /**
     * 
     * @type {ABTestUpdateRequest}
     * @memberof ABTestingApiUpdateAbTestApiV1AbTestsTestIdPut
     */
    readonly aBTestUpdateRequest: ABTestUpdateRequest
}

/**
 * ABTestingApi - object-oriented interface
 * @export
 * @class ABTestingApi
 * @extends {BaseAPI}
 */
export class ABTestingApi extends BaseAPI implements ABTestingApiInterface {
    /**
     * Complete an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action result
     * @summary Complete Ab Test
     * @param {ABTestingApiCompleteAbTestApiV1AbTestsTestIdCompletePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApi
     */
    public completeAbTestApiV1AbTestsTestIdCompletePost(requestParameters: ABTestingApiCompleteAbTestApiV1AbTestsTestIdCompletePostRequest, options?: RawAxiosRequestConfig) {
        return ABTestingApiFp(this.configuration).completeAbTestApiV1AbTestsTestIdCompletePost(requestParameters.testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new A/B test.  Args:     test_data: A/B test creation data     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Created test data
     * @summary Create Ab Test
     * @param {ABTestingApiCreateAbTestApiV1AbTestsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApi
     */
    public createAbTestApiV1AbTestsPost(requestParameters: ABTestingApiCreateAbTestApiV1AbTestsPostRequest, options?: RawAxiosRequestConfig) {
        return ABTestingApiFp(this.configuration).createAbTestApiV1AbTestsPost(requestParameters.aBTestCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Deletion result
     * @summary Delete Ab Test
     * @param {ABTestingApiDeleteAbTestApiV1AbTestsTestIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApi
     */
    public deleteAbTestApiV1AbTestsTestIdDelete(requestParameters: ABTestingApiDeleteAbTestApiV1AbTestsTestIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return ABTestingApiFp(this.configuration).deleteAbTestApiV1AbTestsTestIdDelete(requestParameters.testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * End A/B test and declare winner.  Args:     test_id: A/B test ID     winner_variant: Winning variant identifier     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action response
     * @summary End Ab Test
     * @param {ABTestingApiEndAbTestApiV1AbTestsTestIdEndPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApi
     */
    public endAbTestApiV1AbTestsTestIdEndPost(requestParameters: ABTestingApiEndAbTestApiV1AbTestsTestIdEndPostRequest, options?: RawAxiosRequestConfig) {
        return ABTestingApiFp(this.configuration).endAbTestApiV1AbTestsTestIdEndPost(requestParameters.testId, requestParameters.winnerVariant, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get A/B test by ID.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     A/B test data
     * @summary Get Ab Test
     * @param {ABTestingApiGetAbTestApiV1AbTestsTestIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApi
     */
    public getAbTestApiV1AbTestsTestIdGet(requestParameters: ABTestingApiGetAbTestApiV1AbTestsTestIdGetRequest, options?: RawAxiosRequestConfig) {
        return ABTestingApiFp(this.configuration).getAbTestApiV1AbTestsTestIdGet(requestParameters.testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current A/B test metrics.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Current test metrics
     * @summary Get Ab Test Metrics
     * @param {ABTestingApiGetAbTestMetricsApiV1AbTestsTestIdMetricsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApi
     */
    public getAbTestMetricsApiV1AbTestsTestIdMetricsGet(requestParameters: ABTestingApiGetAbTestMetricsApiV1AbTestsTestIdMetricsGetRequest, options?: RawAxiosRequestConfig) {
        return ABTestingApiFp(this.configuration).getAbTestMetricsApiV1AbTestsTestIdMetricsGet(requestParameters.testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get A/B test performance results by variant.  Args:     test_id: A/B test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Performance results per variant
     * @summary Get Ab Test Performance
     * @param {ABTestingApiGetAbTestPerformanceApiV1AbTestsTestIdPerformanceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApi
     */
    public getAbTestPerformanceApiV1AbTestsTestIdPerformanceGet(requestParameters: ABTestingApiGetAbTestPerformanceApiV1AbTestsTestIdPerformanceGetRequest, options?: RawAxiosRequestConfig) {
        return ABTestingApiFp(this.configuration).getAbTestPerformanceApiV1AbTestsTestIdPerformanceGet(requestParameters.testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get A/B test results and analysis.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Test results and analysis
     * @summary Get Ab Test Results
     * @param {ABTestingApiGetAbTestResultsApiV1AbTestsTestIdResultsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApi
     */
    public getAbTestResultsApiV1AbTestsTestIdResultsGet(requestParameters: ABTestingApiGetAbTestResultsApiV1AbTestsTestIdResultsGetRequest, options?: RawAxiosRequestConfig) {
        return ABTestingApiFp(this.configuration).getAbTestResultsApiV1AbTestsTestIdResultsGet(requestParameters.testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List A/B tests with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     List of A/B tests
     * @summary List Ab Tests
     * @param {ABTestingApiListAbTestsApiV1AbTestsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApi
     */
    public listAbTestsApiV1AbTestsGet(requestParameters: ABTestingApiListAbTestsApiV1AbTestsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ABTestingApiFp(this.configuration).listAbTestsApiV1AbTestsGet(requestParameters.status, requestParameters.testType, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Pause an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action result
     * @summary Pause Ab Test
     * @param {ABTestingApiPauseAbTestApiV1AbTestsTestIdPausePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApi
     */
    public pauseAbTestApiV1AbTestsTestIdPausePost(requestParameters: ABTestingApiPauseAbTestApiV1AbTestsTestIdPausePostRequest, options?: RawAxiosRequestConfig) {
        return ABTestingApiFp(this.configuration).pauseAbTestApiV1AbTestsTestIdPausePost(requestParameters.testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start an A/B test.  Args:     test_id: Test ID     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Action result
     * @summary Start Ab Test
     * @param {ABTestingApiStartAbTestApiV1AbTestsTestIdStartPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApi
     */
    public startAbTestApiV1AbTestsTestIdStartPost(requestParameters: ABTestingApiStartAbTestApiV1AbTestsTestIdStartPostRequest, options?: RawAxiosRequestConfig) {
        return ABTestingApiFp(this.configuration).startAbTestApiV1AbTestsTestIdStartPost(requestParameters.testId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an A/B test.  Args:     test_id: Test ID     test_data: Test update data     current_user: Current authenticated user     ab_test_manager: A/B test manager instance  Returns:     Updated test data
     * @summary Update Ab Test
     * @param {ABTestingApiUpdateAbTestApiV1AbTestsTestIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ABTestingApi
     */
    public updateAbTestApiV1AbTestsTestIdPut(requestParameters: ABTestingApiUpdateAbTestApiV1AbTestsTestIdPutRequest, options?: RawAxiosRequestConfig) {
        return ABTestingApiFp(this.configuration).updateAbTestApiV1AbTestsTestIdPut(requestParameters.testId, requestParameters.aBTestUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AgentsApi - axios parameter creator
 * @export
 */
export const AgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new agent.  Args:     agent_data: Agent creation data     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Created agent data
         * @summary Create Agent
         * @param {AgentCreateRequest} agentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgentApiV1AgentsPost: async (agentCreateRequest: AgentCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentCreateRequest' is not null or undefined
            assertParamExists('createAgentApiV1AgentsPost', 'agentCreateRequest', agentCreateRequest)
            const localVarPath = `/api/v1/agents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an agent.  Args:     agent_id: Agent ID     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Deletion result
         * @summary Delete Agent
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgentApiV1AgentsAgentIdDelete: async (agentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('deleteAgentApiV1AgentsAgentIdDelete', 'agentId', agentId)
            const localVarPath = `/api/v1/agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get agent by ID.  Args:     agent_id: Agent ID     request: Get request parameters     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Agent data
         * @summary Get Agent
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentApiV1AgentsAgentIdGet: async (agentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('getAgentApiV1AgentsAgentIdGet', 'agentId', agentId)
            const localVarPath = `/api/v1/agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get agent statistics.  Args:     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Agent statistics
         * @summary Get Agent Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentStatsApiV1AgentsStatsOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/agents/stats/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a message to an agent and get a response.  Args:     agent_id: Agent ID     interaction_data: Interaction data     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Agent response
         * @summary Interact With Agent
         * @param {string} agentId 
         * @param {AgentInteractRequest} agentInteractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interactWithAgentApiV1AgentsAgentIdInteractPost: async (agentId: string, agentInteractRequest: AgentInteractRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('interactWithAgentApiV1AgentsAgentIdInteractPost', 'agentId', agentId)
            // verify required parameter 'agentInteractRequest' is not null or undefined
            assertParamExists('interactWithAgentApiV1AgentsAgentIdInteractPost', 'agentInteractRequest', agentInteractRequest)
            const localVarPath = `/api/v1/agents/{agent_id}/interact`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentInteractRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all agents with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     List of agents
         * @summary List Agents
         * @param {AgentType | null} [agentType] 
         * @param {AgentStatus | null} [status] 
         * @param {Array<string> | null} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsApiV1AgentsGet: async (agentType?: AgentType | null, status?: AgentStatus | null, requestBody?: Array<string> | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/agents/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (agentType !== undefined) {
                localVarQueryParameter['agent_type'] = agentType;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an agent.  Args:     agent_id: Agent ID     agent_data: Agent update data     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Updated agent data
         * @summary Update Agent
         * @param {string} agentId 
         * @param {AgentUpdateRequest} agentUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgentApiV1AgentsAgentIdPut: async (agentId: string, agentUpdateRequest: AgentUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('updateAgentApiV1AgentsAgentIdPut', 'agentId', agentId)
            // verify required parameter 'agentUpdateRequest' is not null or undefined
            assertParamExists('updateAgentApiV1AgentsAgentIdPut', 'agentUpdateRequest', agentUpdateRequest)
            const localVarPath = `/api/v1/agents/{agent_id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgentsApi - functional programming interface
 * @export
 */
export const AgentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new agent.  Args:     agent_data: Agent creation data     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Created agent data
         * @summary Create Agent
         * @param {AgentCreateRequest} agentCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAgentApiV1AgentsPost(agentCreateRequest: AgentCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAgentApiV1AgentsPost(agentCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.createAgentApiV1AgentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an agent.  Args:     agent_id: Agent ID     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Deletion result
         * @summary Delete Agent
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAgentApiV1AgentsAgentIdDelete(agentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAgentApiV1AgentsAgentIdDelete(agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.deleteAgentApiV1AgentsAgentIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get agent by ID.  Args:     agent_id: Agent ID     request: Get request parameters     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Agent data
         * @summary Get Agent
         * @param {string} agentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgentApiV1AgentsAgentIdGet(agentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgentApiV1AgentsAgentIdGet(agentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.getAgentApiV1AgentsAgentIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get agent statistics.  Args:     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Agent statistics
         * @summary Get Agent Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgentStatsApiV1AgentsStatsOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgentStatsApiV1AgentsStatsOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.getAgentStatsApiV1AgentsStatsOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Send a message to an agent and get a response.  Args:     agent_id: Agent ID     interaction_data: Interaction data     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Agent response
         * @summary Interact With Agent
         * @param {string} agentId 
         * @param {AgentInteractRequest} agentInteractRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interactWithAgentApiV1AgentsAgentIdInteractPost(agentId: string, agentInteractRequest: AgentInteractRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentInteractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interactWithAgentApiV1AgentsAgentIdInteractPost(agentId, agentInteractRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.interactWithAgentApiV1AgentsAgentIdInteractPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all agents with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     List of agents
         * @summary List Agents
         * @param {AgentType | null} [agentType] 
         * @param {AgentStatus | null} [status] 
         * @param {Array<string> | null} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAgentsApiV1AgentsGet(agentType?: AgentType | null, status?: AgentStatus | null, requestBody?: Array<string> | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAgentsApiV1AgentsGet(agentType, status, requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.listAgentsApiV1AgentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update an agent.  Args:     agent_id: Agent ID     agent_data: Agent update data     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Updated agent data
         * @summary Update Agent
         * @param {string} agentId 
         * @param {AgentUpdateRequest} agentUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAgentApiV1AgentsAgentIdPut(agentId: string, agentUpdateRequest: AgentUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAgentApiV1AgentsAgentIdPut(agentId, agentUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgentsApi.updateAgentApiV1AgentsAgentIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AgentsApi - factory interface
 * @export
 */
export const AgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgentsApiFp(configuration)
    return {
        /**
         * Create a new agent.  Args:     agent_data: Agent creation data     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Created agent data
         * @summary Create Agent
         * @param {AgentsApiCreateAgentApiV1AgentsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgentApiV1AgentsPost(requestParameters: AgentsApiCreateAgentApiV1AgentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentResponse> {
            return localVarFp.createAgentApiV1AgentsPost(requestParameters.agentCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an agent.  Args:     agent_id: Agent ID     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Deletion result
         * @summary Delete Agent
         * @param {AgentsApiDeleteAgentApiV1AgentsAgentIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgentApiV1AgentsAgentIdDelete(requestParameters: AgentsApiDeleteAgentApiV1AgentsAgentIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentDeleteResponse> {
            return localVarFp.deleteAgentApiV1AgentsAgentIdDelete(requestParameters.agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get agent by ID.  Args:     agent_id: Agent ID     request: Get request parameters     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Agent data
         * @summary Get Agent
         * @param {AgentsApiGetAgentApiV1AgentsAgentIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentApiV1AgentsAgentIdGet(requestParameters: AgentsApiGetAgentApiV1AgentsAgentIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentResponse> {
            return localVarFp.getAgentApiV1AgentsAgentIdGet(requestParameters.agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get agent statistics.  Args:     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Agent statistics
         * @summary Get Agent Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgentStatsApiV1AgentsStatsOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<AgentStatsResponse> {
            return localVarFp.getAgentStatsApiV1AgentsStatsOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Send a message to an agent and get a response.  Args:     agent_id: Agent ID     interaction_data: Interaction data     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Agent response
         * @summary Interact With Agent
         * @param {AgentsApiInteractWithAgentApiV1AgentsAgentIdInteractPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interactWithAgentApiV1AgentsAgentIdInteractPost(requestParameters: AgentsApiInteractWithAgentApiV1AgentsAgentIdInteractPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentInteractResponse> {
            return localVarFp.interactWithAgentApiV1AgentsAgentIdInteractPost(requestParameters.agentId, requestParameters.agentInteractRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List all agents with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     List of agents
         * @summary List Agents
         * @param {AgentsApiListAgentsApiV1AgentsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAgentsApiV1AgentsGet(requestParameters: AgentsApiListAgentsApiV1AgentsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<AgentListResponse> {
            return localVarFp.listAgentsApiV1AgentsGet(requestParameters.agentType, requestParameters.status, requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an agent.  Args:     agent_id: Agent ID     agent_data: Agent update data     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Updated agent data
         * @summary Update Agent
         * @param {AgentsApiUpdateAgentApiV1AgentsAgentIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgentApiV1AgentsAgentIdPut(requestParameters: AgentsApiUpdateAgentApiV1AgentsAgentIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentResponse> {
            return localVarFp.updateAgentApiV1AgentsAgentIdPut(requestParameters.agentId, requestParameters.agentUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgentsApi - interface
 * @export
 * @interface AgentsApi
 */
export interface AgentsApiInterface {
    /**
     * Create a new agent.  Args:     agent_data: Agent creation data     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Created agent data
     * @summary Create Agent
     * @param {AgentsApiCreateAgentApiV1AgentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApiInterface
     */
    createAgentApiV1AgentsPost(requestParameters: AgentsApiCreateAgentApiV1AgentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentResponse>;

    /**
     * Delete an agent.  Args:     agent_id: Agent ID     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Deletion result
     * @summary Delete Agent
     * @param {AgentsApiDeleteAgentApiV1AgentsAgentIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApiInterface
     */
    deleteAgentApiV1AgentsAgentIdDelete(requestParameters: AgentsApiDeleteAgentApiV1AgentsAgentIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentDeleteResponse>;

    /**
     * Get agent by ID.  Args:     agent_id: Agent ID     request: Get request parameters     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Agent data
     * @summary Get Agent
     * @param {AgentsApiGetAgentApiV1AgentsAgentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApiInterface
     */
    getAgentApiV1AgentsAgentIdGet(requestParameters: AgentsApiGetAgentApiV1AgentsAgentIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentResponse>;

    /**
     * Get agent statistics.  Args:     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Agent statistics
     * @summary Get Agent Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApiInterface
     */
    getAgentStatsApiV1AgentsStatsOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<AgentStatsResponse>;

    /**
     * Send a message to an agent and get a response.  Args:     agent_id: Agent ID     interaction_data: Interaction data     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Agent response
     * @summary Interact With Agent
     * @param {AgentsApiInteractWithAgentApiV1AgentsAgentIdInteractPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApiInterface
     */
    interactWithAgentApiV1AgentsAgentIdInteractPost(requestParameters: AgentsApiInteractWithAgentApiV1AgentsAgentIdInteractPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentInteractResponse>;

    /**
     * List all agents with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     List of agents
     * @summary List Agents
     * @param {AgentsApiListAgentsApiV1AgentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApiInterface
     */
    listAgentsApiV1AgentsGet(requestParameters?: AgentsApiListAgentsApiV1AgentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentListResponse>;

    /**
     * Update an agent.  Args:     agent_id: Agent ID     agent_data: Agent update data     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Updated agent data
     * @summary Update Agent
     * @param {AgentsApiUpdateAgentApiV1AgentsAgentIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApiInterface
     */
    updateAgentApiV1AgentsAgentIdPut(requestParameters: AgentsApiUpdateAgentApiV1AgentsAgentIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<AgentResponse>;

}

/**
 * Request parameters for createAgentApiV1AgentsPost operation in AgentsApi.
 * @export
 * @interface AgentsApiCreateAgentApiV1AgentsPostRequest
 */
export interface AgentsApiCreateAgentApiV1AgentsPostRequest {
    /**
     * 
     * @type {AgentCreateRequest}
     * @memberof AgentsApiCreateAgentApiV1AgentsPost
     */
    readonly agentCreateRequest: AgentCreateRequest
}

/**
 * Request parameters for deleteAgentApiV1AgentsAgentIdDelete operation in AgentsApi.
 * @export
 * @interface AgentsApiDeleteAgentApiV1AgentsAgentIdDeleteRequest
 */
export interface AgentsApiDeleteAgentApiV1AgentsAgentIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiDeleteAgentApiV1AgentsAgentIdDelete
     */
    readonly agentId: string
}

/**
 * Request parameters for getAgentApiV1AgentsAgentIdGet operation in AgentsApi.
 * @export
 * @interface AgentsApiGetAgentApiV1AgentsAgentIdGetRequest
 */
export interface AgentsApiGetAgentApiV1AgentsAgentIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiGetAgentApiV1AgentsAgentIdGet
     */
    readonly agentId: string
}

/**
 * Request parameters for interactWithAgentApiV1AgentsAgentIdInteractPost operation in AgentsApi.
 * @export
 * @interface AgentsApiInteractWithAgentApiV1AgentsAgentIdInteractPostRequest
 */
export interface AgentsApiInteractWithAgentApiV1AgentsAgentIdInteractPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiInteractWithAgentApiV1AgentsAgentIdInteractPost
     */
    readonly agentId: string

    /**
     * 
     * @type {AgentInteractRequest}
     * @memberof AgentsApiInteractWithAgentApiV1AgentsAgentIdInteractPost
     */
    readonly agentInteractRequest: AgentInteractRequest
}

/**
 * Request parameters for listAgentsApiV1AgentsGet operation in AgentsApi.
 * @export
 * @interface AgentsApiListAgentsApiV1AgentsGetRequest
 */
export interface AgentsApiListAgentsApiV1AgentsGetRequest {
    /**
     * 
     * @type {AgentType}
     * @memberof AgentsApiListAgentsApiV1AgentsGet
     */
    readonly agentType?: AgentType | null

    /**
     * 
     * @type {AgentStatus}
     * @memberof AgentsApiListAgentsApiV1AgentsGet
     */
    readonly status?: AgentStatus | null

    /**
     * 
     * @type {Array<string>}
     * @memberof AgentsApiListAgentsApiV1AgentsGet
     */
    readonly requestBody?: Array<string> | null
}

/**
 * Request parameters for updateAgentApiV1AgentsAgentIdPut operation in AgentsApi.
 * @export
 * @interface AgentsApiUpdateAgentApiV1AgentsAgentIdPutRequest
 */
export interface AgentsApiUpdateAgentApiV1AgentsAgentIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof AgentsApiUpdateAgentApiV1AgentsAgentIdPut
     */
    readonly agentId: string

    /**
     * 
     * @type {AgentUpdateRequest}
     * @memberof AgentsApiUpdateAgentApiV1AgentsAgentIdPut
     */
    readonly agentUpdateRequest: AgentUpdateRequest
}

/**
 * AgentsApi - object-oriented interface
 * @export
 * @class AgentsApi
 * @extends {BaseAPI}
 */
export class AgentsApi extends BaseAPI implements AgentsApiInterface {
    /**
     * Create a new agent.  Args:     agent_data: Agent creation data     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Created agent data
     * @summary Create Agent
     * @param {AgentsApiCreateAgentApiV1AgentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public createAgentApiV1AgentsPost(requestParameters: AgentsApiCreateAgentApiV1AgentsPostRequest, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).createAgentApiV1AgentsPost(requestParameters.agentCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an agent.  Args:     agent_id: Agent ID     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Deletion result
     * @summary Delete Agent
     * @param {AgentsApiDeleteAgentApiV1AgentsAgentIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public deleteAgentApiV1AgentsAgentIdDelete(requestParameters: AgentsApiDeleteAgentApiV1AgentsAgentIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).deleteAgentApiV1AgentsAgentIdDelete(requestParameters.agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get agent by ID.  Args:     agent_id: Agent ID     request: Get request parameters     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Agent data
     * @summary Get Agent
     * @param {AgentsApiGetAgentApiV1AgentsAgentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public getAgentApiV1AgentsAgentIdGet(requestParameters: AgentsApiGetAgentApiV1AgentsAgentIdGetRequest, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).getAgentApiV1AgentsAgentIdGet(requestParameters.agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get agent statistics.  Args:     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Agent statistics
     * @summary Get Agent Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public getAgentStatsApiV1AgentsStatsOverviewGet(options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).getAgentStatsApiV1AgentsStatsOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Send a message to an agent and get a response.  Args:     agent_id: Agent ID     interaction_data: Interaction data     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Agent response
     * @summary Interact With Agent
     * @param {AgentsApiInteractWithAgentApiV1AgentsAgentIdInteractPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public interactWithAgentApiV1AgentsAgentIdInteractPost(requestParameters: AgentsApiInteractWithAgentApiV1AgentsAgentIdInteractPostRequest, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).interactWithAgentApiV1AgentsAgentIdInteractPost(requestParameters.agentId, requestParameters.agentInteractRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all agents with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     List of agents
     * @summary List Agents
     * @param {AgentsApiListAgentsApiV1AgentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public listAgentsApiV1AgentsGet(requestParameters: AgentsApiListAgentsApiV1AgentsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).listAgentsApiV1AgentsGet(requestParameters.agentType, requestParameters.status, requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an agent.  Args:     agent_id: Agent ID     agent_data: Agent update data     current_user: Current authenticated user     agent_manager: Agent manager instance  Returns:     Updated agent data
     * @summary Update Agent
     * @param {AgentsApiUpdateAgentApiV1AgentsAgentIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgentsApi
     */
    public updateAgentApiV1AgentsAgentIdPut(requestParameters: AgentsApiUpdateAgentApiV1AgentsAgentIdPutRequest, options?: RawAxiosRequestConfig) {
        return AgentsApiFp(this.configuration).updateAgentApiV1AgentsAgentIdPut(requestParameters.agentId, requestParameters.agentUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AnalyticsApi - axios parameter creator
 * @export
 */
export const AnalyticsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Export analytics reports.  Args:     format: Export format     metrics: List of metrics to export     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Exported analytics report
         * @summary Export Analytics
         * @param {Array<string>} metrics List of metrics to export
         * @param {string} [format] Export format (json, csv, xlsx)
         * @param {string | null} [startDate] Start date for analytics
         * @param {string | null} [endDate] End date for analytics
         * @param {string} [period] Predefined period (1h, 24h, 7d, 30d, 90d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportAnalyticsApiV1AnalyticsExportPost: async (metrics: Array<string>, format?: string, startDate?: string | null, endDate?: string | null, period?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metrics' is not null or undefined
            assertParamExists('exportAnalyticsApiV1AnalyticsExportPost', 'metrics', metrics)
            const localVarPath = `/api/v1/analytics/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (format !== undefined) {
                localVarQueryParameter['format'] = format;
            }

            if (metrics) {
                localVarQueryParameter['metrics'] = metrics;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get conversation statistics.  Args:     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Conversation statistics
         * @summary Get Conversation Stats
         * @param {string | null} [startDate] Start date for analytics
         * @param {string | null} [endDate] End date for analytics
         * @param {string} [period] Predefined period (1h, 24h, 7d, 30d, 90d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationStatsApiV1AnalyticsConversationsGet: async (startDate?: string | null, endDate?: string | null, period?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/analytics/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get comprehensive dashboard data.  Args:     request: Dashboard request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Complete dashboard data
         * @summary Get Dashboard
         * @param {string | null} [startDate] Start date for analytics
         * @param {string | null} [endDate] End date for analytics
         * @param {string} [period] Predefined period (1h, 24h, 7d, 30d, 90d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardApiV1AnalyticsDashboardGet: async (startDate?: string | null, endDate?: string | null, period?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/analytics/dashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get document analytics.  Args:     request: Document analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Document analytics
         * @summary Get Document Analytics
         * @param {string | null} [startDate] Start date for analytics
         * @param {string | null} [endDate] End date for analytics
         * @param {string} [period] Predefined period (1h, 24h, 7d, 30d, 90d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentAnalyticsApiV1AnalyticsDocumentsGet: async (startDate?: string | null, endDate?: string | null, period?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/analytics/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get performance metrics.  Args:     request: Performance metrics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Performance metrics
         * @summary Get Performance Metrics
         * @param {string | null} [startDate] Start date for analytics
         * @param {string | null} [endDate] End date for analytics
         * @param {string} [period] Predefined period (1h, 24h, 7d, 30d, 90d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerformanceMetricsApiV1AnalyticsPerformanceGet: async (startDate?: string | null, endDate?: string | null, period?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/analytics/performance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get system analytics.  Args:     request: System analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     System analytics
         * @summary Get System Analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemAnalyticsApiV1AnalyticsSystemGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/analytics/system`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get tool server analytics.  Args:     request: Tool server analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Tool server analytics data
         * @summary Get Tool Server Analytics
         * @param {string | null} [startDate] Start date for analytics
         * @param {string | null} [endDate] End date for analytics
         * @param {string} [period] Predefined period (1h, 24h, 7d, 30d, 90d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolServerAnalyticsApiV1AnalyticsToolserversGet: async (startDate?: string | null, endDate?: string | null, period?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/analytics/toolservers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get usage metrics.  Args:     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Usage metrics
         * @summary Get Usage Metrics
         * @param {string | null} [startDate] Start date for analytics
         * @param {string | null} [endDate] End date for analytics
         * @param {string} [period] Predefined period (1h, 24h, 7d, 30d, 90d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMetricsApiV1AnalyticsUsageGet: async (startDate?: string | null, endDate?: string | null, period?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/analytics/usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get per-user analytics.  Args:     user_id: User ID     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     User-specific analytics
         * @summary Get User Analytics
         * @param {string} userId 
         * @param {string | null} [startDate] Start date for analytics
         * @param {string | null} [endDate] End date for analytics
         * @param {string} [period] Predefined period (1h, 24h, 7d, 30d, 90d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAnalyticsApiV1AnalyticsUsersUserIdGet: async (userId: string, startDate?: string | null, endDate?: string | null, period?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserAnalyticsApiV1AnalyticsUsersUserIdGet', 'userId', userId)
            const localVarPath = `/api/v1/analytics/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString() :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString() :
                    endDate;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnalyticsApi - functional programming interface
 * @export
 */
export const AnalyticsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnalyticsApiAxiosParamCreator(configuration)
    return {
        /**
         * Export analytics reports.  Args:     format: Export format     metrics: List of metrics to export     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Exported analytics report
         * @summary Export Analytics
         * @param {Array<string>} metrics List of metrics to export
         * @param {string} [format] Export format (json, csv, xlsx)
         * @param {string | null} [startDate] Start date for analytics
         * @param {string | null} [endDate] End date for analytics
         * @param {string} [period] Predefined period (1h, 24h, 7d, 30d, 90d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportAnalyticsApiV1AnalyticsExportPost(metrics: Array<string>, format?: string, startDate?: string | null, endDate?: string | null, period?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportAnalyticsApiV1AnalyticsExportPost(metrics, format, startDate, endDate, period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.exportAnalyticsApiV1AnalyticsExportPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get conversation statistics.  Args:     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Conversation statistics
         * @summary Get Conversation Stats
         * @param {string | null} [startDate] Start date for analytics
         * @param {string | null} [endDate] End date for analytics
         * @param {string} [period] Predefined period (1h, 24h, 7d, 30d, 90d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationStatsApiV1AnalyticsConversationsGet(startDate?: string | null, endDate?: string | null, period?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversationStatsApiV1AnalyticsConversationsGet(startDate, endDate, period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getConversationStatsApiV1AnalyticsConversationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get comprehensive dashboard data.  Args:     request: Dashboard request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Complete dashboard data
         * @summary Get Dashboard
         * @param {string | null} [startDate] Start date for analytics
         * @param {string | null} [endDate] End date for analytics
         * @param {string} [period] Predefined period (1h, 24h, 7d, 30d, 90d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardApiV1AnalyticsDashboardGet(startDate?: string | null, endDate?: string | null, period?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardApiV1AnalyticsDashboardGet(startDate, endDate, period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getDashboardApiV1AnalyticsDashboardGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get document analytics.  Args:     request: Document analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Document analytics
         * @summary Get Document Analytics
         * @param {string | null} [startDate] Start date for analytics
         * @param {string | null} [endDate] End date for analytics
         * @param {string} [period] Predefined period (1h, 24h, 7d, 30d, 90d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentAnalyticsApiV1AnalyticsDocumentsGet(startDate?: string | null, endDate?: string | null, period?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentAnalyticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentAnalyticsApiV1AnalyticsDocumentsGet(startDate, endDate, period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getDocumentAnalyticsApiV1AnalyticsDocumentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get performance metrics.  Args:     request: Performance metrics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Performance metrics
         * @summary Get Performance Metrics
         * @param {string | null} [startDate] Start date for analytics
         * @param {string | null} [endDate] End date for analytics
         * @param {string} [period] Predefined period (1h, 24h, 7d, 30d, 90d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPerformanceMetricsApiV1AnalyticsPerformanceGet(startDate?: string | null, endDate?: string | null, period?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PerformanceMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPerformanceMetricsApiV1AnalyticsPerformanceGet(startDate, endDate, period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getPerformanceMetricsApiV1AnalyticsPerformanceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get system analytics.  Args:     request: System analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     System analytics
         * @summary Get System Analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSystemAnalyticsApiV1AnalyticsSystemGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SystemAnalyticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSystemAnalyticsApiV1AnalyticsSystemGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getSystemAnalyticsApiV1AnalyticsSystemGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get tool server analytics.  Args:     request: Tool server analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Tool server analytics data
         * @summary Get Tool Server Analytics
         * @param {string | null} [startDate] Start date for analytics
         * @param {string | null} [endDate] End date for analytics
         * @param {string} [period] Predefined period (1h, 24h, 7d, 30d, 90d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToolServerAnalyticsApiV1AnalyticsToolserversGet(startDate?: string | null, endDate?: string | null, period?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToolServerAnalyticsApiV1AnalyticsToolserversGet(startDate, endDate, period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getToolServerAnalyticsApiV1AnalyticsToolserversGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get usage metrics.  Args:     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Usage metrics
         * @summary Get Usage Metrics
         * @param {string | null} [startDate] Start date for analytics
         * @param {string | null} [endDate] End date for analytics
         * @param {string} [period] Predefined period (1h, 24h, 7d, 30d, 90d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsageMetricsApiV1AnalyticsUsageGet(startDate?: string | null, endDate?: string | null, period?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsageMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsageMetricsApiV1AnalyticsUsageGet(startDate, endDate, period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getUsageMetricsApiV1AnalyticsUsageGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get per-user analytics.  Args:     user_id: User ID     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     User-specific analytics
         * @summary Get User Analytics
         * @param {string} userId 
         * @param {string | null} [startDate] Start date for analytics
         * @param {string | null} [endDate] End date for analytics
         * @param {string} [period] Predefined period (1h, 24h, 7d, 30d, 90d)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAnalyticsApiV1AnalyticsUsersUserIdGet(userId: string, startDate?: string | null, endDate?: string | null, period?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAnalyticsApiV1AnalyticsUsersUserIdGet(userId, startDate, endDate, period, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AnalyticsApi.getUserAnalyticsApiV1AnalyticsUsersUserIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AnalyticsApi - factory interface
 * @export
 */
export const AnalyticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnalyticsApiFp(configuration)
    return {
        /**
         * Export analytics reports.  Args:     format: Export format     metrics: List of metrics to export     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Exported analytics report
         * @summary Export Analytics
         * @param {AnalyticsApiExportAnalyticsApiV1AnalyticsExportPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportAnalyticsApiV1AnalyticsExportPost(requestParameters: AnalyticsApiExportAnalyticsApiV1AnalyticsExportPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.exportAnalyticsApiV1AnalyticsExportPost(requestParameters.metrics, requestParameters.format, requestParameters.startDate, requestParameters.endDate, requestParameters.period, options).then((request) => request(axios, basePath));
        },
        /**
         * Get conversation statistics.  Args:     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Conversation statistics
         * @summary Get Conversation Stats
         * @param {AnalyticsApiGetConversationStatsApiV1AnalyticsConversationsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationStatsApiV1AnalyticsConversationsGet(requestParameters: AnalyticsApiGetConversationStatsApiV1AnalyticsConversationsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ConversationStatsResponse> {
            return localVarFp.getConversationStatsApiV1AnalyticsConversationsGet(requestParameters.startDate, requestParameters.endDate, requestParameters.period, options).then((request) => request(axios, basePath));
        },
        /**
         * Get comprehensive dashboard data.  Args:     request: Dashboard request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Complete dashboard data
         * @summary Get Dashboard
         * @param {AnalyticsApiGetDashboardApiV1AnalyticsDashboardGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardApiV1AnalyticsDashboardGet(requestParameters: AnalyticsApiGetDashboardApiV1AnalyticsDashboardGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<DashboardResponse> {
            return localVarFp.getDashboardApiV1AnalyticsDashboardGet(requestParameters.startDate, requestParameters.endDate, requestParameters.period, options).then((request) => request(axios, basePath));
        },
        /**
         * Get document analytics.  Args:     request: Document analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Document analytics
         * @summary Get Document Analytics
         * @param {AnalyticsApiGetDocumentAnalyticsApiV1AnalyticsDocumentsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentAnalyticsApiV1AnalyticsDocumentsGet(requestParameters: AnalyticsApiGetDocumentAnalyticsApiV1AnalyticsDocumentsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<DocumentAnalyticsResponse> {
            return localVarFp.getDocumentAnalyticsApiV1AnalyticsDocumentsGet(requestParameters.startDate, requestParameters.endDate, requestParameters.period, options).then((request) => request(axios, basePath));
        },
        /**
         * Get performance metrics.  Args:     request: Performance metrics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Performance metrics
         * @summary Get Performance Metrics
         * @param {AnalyticsApiGetPerformanceMetricsApiV1AnalyticsPerformanceGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerformanceMetricsApiV1AnalyticsPerformanceGet(requestParameters: AnalyticsApiGetPerformanceMetricsApiV1AnalyticsPerformanceGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PerformanceMetricsResponse> {
            return localVarFp.getPerformanceMetricsApiV1AnalyticsPerformanceGet(requestParameters.startDate, requestParameters.endDate, requestParameters.period, options).then((request) => request(axios, basePath));
        },
        /**
         * Get system analytics.  Args:     request: System analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     System analytics
         * @summary Get System Analytics
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSystemAnalyticsApiV1AnalyticsSystemGet(options?: RawAxiosRequestConfig): AxiosPromise<SystemAnalyticsResponse> {
            return localVarFp.getSystemAnalyticsApiV1AnalyticsSystemGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get tool server analytics.  Args:     request: Tool server analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Tool server analytics data
         * @summary Get Tool Server Analytics
         * @param {AnalyticsApiGetToolServerAnalyticsApiV1AnalyticsToolserversGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolServerAnalyticsApiV1AnalyticsToolserversGet(requestParameters: AnalyticsApiGetToolServerAnalyticsApiV1AnalyticsToolserversGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getToolServerAnalyticsApiV1AnalyticsToolserversGet(requestParameters.startDate, requestParameters.endDate, requestParameters.period, options).then((request) => request(axios, basePath));
        },
        /**
         * Get usage metrics.  Args:     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Usage metrics
         * @summary Get Usage Metrics
         * @param {AnalyticsApiGetUsageMetricsApiV1AnalyticsUsageGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsageMetricsApiV1AnalyticsUsageGet(requestParameters: AnalyticsApiGetUsageMetricsApiV1AnalyticsUsageGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<UsageMetricsResponse> {
            return localVarFp.getUsageMetricsApiV1AnalyticsUsageGet(requestParameters.startDate, requestParameters.endDate, requestParameters.period, options).then((request) => request(axios, basePath));
        },
        /**
         * Get per-user analytics.  Args:     user_id: User ID     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     User-specific analytics
         * @summary Get User Analytics
         * @param {AnalyticsApiGetUserAnalyticsApiV1AnalyticsUsersUserIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAnalyticsApiV1AnalyticsUsersUserIdGet(requestParameters: AnalyticsApiGetUserAnalyticsApiV1AnalyticsUsersUserIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.getUserAnalyticsApiV1AnalyticsUsersUserIdGet(requestParameters.userId, requestParameters.startDate, requestParameters.endDate, requestParameters.period, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnalyticsApi - interface
 * @export
 * @interface AnalyticsApi
 */
export interface AnalyticsApiInterface {
    /**
     * Export analytics reports.  Args:     format: Export format     metrics: List of metrics to export     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Exported analytics report
     * @summary Export Analytics
     * @param {AnalyticsApiExportAnalyticsApiV1AnalyticsExportPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApiInterface
     */
    exportAnalyticsApiV1AnalyticsExportPost(requestParameters: AnalyticsApiExportAnalyticsApiV1AnalyticsExportPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Get conversation statistics.  Args:     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Conversation statistics
     * @summary Get Conversation Stats
     * @param {AnalyticsApiGetConversationStatsApiV1AnalyticsConversationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApiInterface
     */
    getConversationStatsApiV1AnalyticsConversationsGet(requestParameters?: AnalyticsApiGetConversationStatsApiV1AnalyticsConversationsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationStatsResponse>;

    /**
     * Get comprehensive dashboard data.  Args:     request: Dashboard request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Complete dashboard data
     * @summary Get Dashboard
     * @param {AnalyticsApiGetDashboardApiV1AnalyticsDashboardGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApiInterface
     */
    getDashboardApiV1AnalyticsDashboardGet(requestParameters?: AnalyticsApiGetDashboardApiV1AnalyticsDashboardGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<DashboardResponse>;

    /**
     * Get document analytics.  Args:     request: Document analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Document analytics
     * @summary Get Document Analytics
     * @param {AnalyticsApiGetDocumentAnalyticsApiV1AnalyticsDocumentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApiInterface
     */
    getDocumentAnalyticsApiV1AnalyticsDocumentsGet(requestParameters?: AnalyticsApiGetDocumentAnalyticsApiV1AnalyticsDocumentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentAnalyticsResponse>;

    /**
     * Get performance metrics.  Args:     request: Performance metrics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Performance metrics
     * @summary Get Performance Metrics
     * @param {AnalyticsApiGetPerformanceMetricsApiV1AnalyticsPerformanceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApiInterface
     */
    getPerformanceMetricsApiV1AnalyticsPerformanceGet(requestParameters?: AnalyticsApiGetPerformanceMetricsApiV1AnalyticsPerformanceGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PerformanceMetricsResponse>;

    /**
     * Get system analytics.  Args:     request: System analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     System analytics
     * @summary Get System Analytics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApiInterface
     */
    getSystemAnalyticsApiV1AnalyticsSystemGet(options?: RawAxiosRequestConfig): AxiosPromise<SystemAnalyticsResponse>;

    /**
     * Get tool server analytics.  Args:     request: Tool server analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Tool server analytics data
     * @summary Get Tool Server Analytics
     * @param {AnalyticsApiGetToolServerAnalyticsApiV1AnalyticsToolserversGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApiInterface
     */
    getToolServerAnalyticsApiV1AnalyticsToolserversGet(requestParameters?: AnalyticsApiGetToolServerAnalyticsApiV1AnalyticsToolserversGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

    /**
     * Get usage metrics.  Args:     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Usage metrics
     * @summary Get Usage Metrics
     * @param {AnalyticsApiGetUsageMetricsApiV1AnalyticsUsageGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApiInterface
     */
    getUsageMetricsApiV1AnalyticsUsageGet(requestParameters?: AnalyticsApiGetUsageMetricsApiV1AnalyticsUsageGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<UsageMetricsResponse>;

    /**
     * Get per-user analytics.  Args:     user_id: User ID     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     User-specific analytics
     * @summary Get User Analytics
     * @param {AnalyticsApiGetUserAnalyticsApiV1AnalyticsUsersUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApiInterface
     */
    getUserAnalyticsApiV1AnalyticsUsersUserIdGet(requestParameters: AnalyticsApiGetUserAnalyticsApiV1AnalyticsUsersUserIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

}

/**
 * Request parameters for exportAnalyticsApiV1AnalyticsExportPost operation in AnalyticsApi.
 * @export
 * @interface AnalyticsApiExportAnalyticsApiV1AnalyticsExportPostRequest
 */
export interface AnalyticsApiExportAnalyticsApiV1AnalyticsExportPostRequest {
    /**
     * List of metrics to export
     * @type {Array<string>}
     * @memberof AnalyticsApiExportAnalyticsApiV1AnalyticsExportPost
     */
    readonly metrics: Array<string>

    /**
     * Export format (json, csv, xlsx)
     * @type {string}
     * @memberof AnalyticsApiExportAnalyticsApiV1AnalyticsExportPost
     */
    readonly format?: string

    /**
     * Start date for analytics
     * @type {string}
     * @memberof AnalyticsApiExportAnalyticsApiV1AnalyticsExportPost
     */
    readonly startDate?: string | null

    /**
     * End date for analytics
     * @type {string}
     * @memberof AnalyticsApiExportAnalyticsApiV1AnalyticsExportPost
     */
    readonly endDate?: string | null

    /**
     * Predefined period (1h, 24h, 7d, 30d, 90d)
     * @type {string}
     * @memberof AnalyticsApiExportAnalyticsApiV1AnalyticsExportPost
     */
    readonly period?: string
}

/**
 * Request parameters for getConversationStatsApiV1AnalyticsConversationsGet operation in AnalyticsApi.
 * @export
 * @interface AnalyticsApiGetConversationStatsApiV1AnalyticsConversationsGetRequest
 */
export interface AnalyticsApiGetConversationStatsApiV1AnalyticsConversationsGetRequest {
    /**
     * Start date for analytics
     * @type {string}
     * @memberof AnalyticsApiGetConversationStatsApiV1AnalyticsConversationsGet
     */
    readonly startDate?: string | null

    /**
     * End date for analytics
     * @type {string}
     * @memberof AnalyticsApiGetConversationStatsApiV1AnalyticsConversationsGet
     */
    readonly endDate?: string | null

    /**
     * Predefined period (1h, 24h, 7d, 30d, 90d)
     * @type {string}
     * @memberof AnalyticsApiGetConversationStatsApiV1AnalyticsConversationsGet
     */
    readonly period?: string
}

/**
 * Request parameters for getDashboardApiV1AnalyticsDashboardGet operation in AnalyticsApi.
 * @export
 * @interface AnalyticsApiGetDashboardApiV1AnalyticsDashboardGetRequest
 */
export interface AnalyticsApiGetDashboardApiV1AnalyticsDashboardGetRequest {
    /**
     * Start date for analytics
     * @type {string}
     * @memberof AnalyticsApiGetDashboardApiV1AnalyticsDashboardGet
     */
    readonly startDate?: string | null

    /**
     * End date for analytics
     * @type {string}
     * @memberof AnalyticsApiGetDashboardApiV1AnalyticsDashboardGet
     */
    readonly endDate?: string | null

    /**
     * Predefined period (1h, 24h, 7d, 30d, 90d)
     * @type {string}
     * @memberof AnalyticsApiGetDashboardApiV1AnalyticsDashboardGet
     */
    readonly period?: string
}

/**
 * Request parameters for getDocumentAnalyticsApiV1AnalyticsDocumentsGet operation in AnalyticsApi.
 * @export
 * @interface AnalyticsApiGetDocumentAnalyticsApiV1AnalyticsDocumentsGetRequest
 */
export interface AnalyticsApiGetDocumentAnalyticsApiV1AnalyticsDocumentsGetRequest {
    /**
     * Start date for analytics
     * @type {string}
     * @memberof AnalyticsApiGetDocumentAnalyticsApiV1AnalyticsDocumentsGet
     */
    readonly startDate?: string | null

    /**
     * End date for analytics
     * @type {string}
     * @memberof AnalyticsApiGetDocumentAnalyticsApiV1AnalyticsDocumentsGet
     */
    readonly endDate?: string | null

    /**
     * Predefined period (1h, 24h, 7d, 30d, 90d)
     * @type {string}
     * @memberof AnalyticsApiGetDocumentAnalyticsApiV1AnalyticsDocumentsGet
     */
    readonly period?: string
}

/**
 * Request parameters for getPerformanceMetricsApiV1AnalyticsPerformanceGet operation in AnalyticsApi.
 * @export
 * @interface AnalyticsApiGetPerformanceMetricsApiV1AnalyticsPerformanceGetRequest
 */
export interface AnalyticsApiGetPerformanceMetricsApiV1AnalyticsPerformanceGetRequest {
    /**
     * Start date for analytics
     * @type {string}
     * @memberof AnalyticsApiGetPerformanceMetricsApiV1AnalyticsPerformanceGet
     */
    readonly startDate?: string | null

    /**
     * End date for analytics
     * @type {string}
     * @memberof AnalyticsApiGetPerformanceMetricsApiV1AnalyticsPerformanceGet
     */
    readonly endDate?: string | null

    /**
     * Predefined period (1h, 24h, 7d, 30d, 90d)
     * @type {string}
     * @memberof AnalyticsApiGetPerformanceMetricsApiV1AnalyticsPerformanceGet
     */
    readonly period?: string
}

/**
 * Request parameters for getToolServerAnalyticsApiV1AnalyticsToolserversGet operation in AnalyticsApi.
 * @export
 * @interface AnalyticsApiGetToolServerAnalyticsApiV1AnalyticsToolserversGetRequest
 */
export interface AnalyticsApiGetToolServerAnalyticsApiV1AnalyticsToolserversGetRequest {
    /**
     * Start date for analytics
     * @type {string}
     * @memberof AnalyticsApiGetToolServerAnalyticsApiV1AnalyticsToolserversGet
     */
    readonly startDate?: string | null

    /**
     * End date for analytics
     * @type {string}
     * @memberof AnalyticsApiGetToolServerAnalyticsApiV1AnalyticsToolserversGet
     */
    readonly endDate?: string | null

    /**
     * Predefined period (1h, 24h, 7d, 30d, 90d)
     * @type {string}
     * @memberof AnalyticsApiGetToolServerAnalyticsApiV1AnalyticsToolserversGet
     */
    readonly period?: string
}

/**
 * Request parameters for getUsageMetricsApiV1AnalyticsUsageGet operation in AnalyticsApi.
 * @export
 * @interface AnalyticsApiGetUsageMetricsApiV1AnalyticsUsageGetRequest
 */
export interface AnalyticsApiGetUsageMetricsApiV1AnalyticsUsageGetRequest {
    /**
     * Start date for analytics
     * @type {string}
     * @memberof AnalyticsApiGetUsageMetricsApiV1AnalyticsUsageGet
     */
    readonly startDate?: string | null

    /**
     * End date for analytics
     * @type {string}
     * @memberof AnalyticsApiGetUsageMetricsApiV1AnalyticsUsageGet
     */
    readonly endDate?: string | null

    /**
     * Predefined period (1h, 24h, 7d, 30d, 90d)
     * @type {string}
     * @memberof AnalyticsApiGetUsageMetricsApiV1AnalyticsUsageGet
     */
    readonly period?: string
}

/**
 * Request parameters for getUserAnalyticsApiV1AnalyticsUsersUserIdGet operation in AnalyticsApi.
 * @export
 * @interface AnalyticsApiGetUserAnalyticsApiV1AnalyticsUsersUserIdGetRequest
 */
export interface AnalyticsApiGetUserAnalyticsApiV1AnalyticsUsersUserIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof AnalyticsApiGetUserAnalyticsApiV1AnalyticsUsersUserIdGet
     */
    readonly userId: string

    /**
     * Start date for analytics
     * @type {string}
     * @memberof AnalyticsApiGetUserAnalyticsApiV1AnalyticsUsersUserIdGet
     */
    readonly startDate?: string | null

    /**
     * End date for analytics
     * @type {string}
     * @memberof AnalyticsApiGetUserAnalyticsApiV1AnalyticsUsersUserIdGet
     */
    readonly endDate?: string | null

    /**
     * Predefined period (1h, 24h, 7d, 30d, 90d)
     * @type {string}
     * @memberof AnalyticsApiGetUserAnalyticsApiV1AnalyticsUsersUserIdGet
     */
    readonly period?: string
}

/**
 * AnalyticsApi - object-oriented interface
 * @export
 * @class AnalyticsApi
 * @extends {BaseAPI}
 */
export class AnalyticsApi extends BaseAPI implements AnalyticsApiInterface {
    /**
     * Export analytics reports.  Args:     format: Export format     metrics: List of metrics to export     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Exported analytics report
     * @summary Export Analytics
     * @param {AnalyticsApiExportAnalyticsApiV1AnalyticsExportPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public exportAnalyticsApiV1AnalyticsExportPost(requestParameters: AnalyticsApiExportAnalyticsApiV1AnalyticsExportPostRequest, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).exportAnalyticsApiV1AnalyticsExportPost(requestParameters.metrics, requestParameters.format, requestParameters.startDate, requestParameters.endDate, requestParameters.period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get conversation statistics.  Args:     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Conversation statistics
     * @summary Get Conversation Stats
     * @param {AnalyticsApiGetConversationStatsApiV1AnalyticsConversationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getConversationStatsApiV1AnalyticsConversationsGet(requestParameters: AnalyticsApiGetConversationStatsApiV1AnalyticsConversationsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getConversationStatsApiV1AnalyticsConversationsGet(requestParameters.startDate, requestParameters.endDate, requestParameters.period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get comprehensive dashboard data.  Args:     request: Dashboard request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Complete dashboard data
     * @summary Get Dashboard
     * @param {AnalyticsApiGetDashboardApiV1AnalyticsDashboardGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getDashboardApiV1AnalyticsDashboardGet(requestParameters: AnalyticsApiGetDashboardApiV1AnalyticsDashboardGetRequest = {}, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getDashboardApiV1AnalyticsDashboardGet(requestParameters.startDate, requestParameters.endDate, requestParameters.period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get document analytics.  Args:     request: Document analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Document analytics
     * @summary Get Document Analytics
     * @param {AnalyticsApiGetDocumentAnalyticsApiV1AnalyticsDocumentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getDocumentAnalyticsApiV1AnalyticsDocumentsGet(requestParameters: AnalyticsApiGetDocumentAnalyticsApiV1AnalyticsDocumentsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getDocumentAnalyticsApiV1AnalyticsDocumentsGet(requestParameters.startDate, requestParameters.endDate, requestParameters.period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get performance metrics.  Args:     request: Performance metrics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Performance metrics
     * @summary Get Performance Metrics
     * @param {AnalyticsApiGetPerformanceMetricsApiV1AnalyticsPerformanceGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getPerformanceMetricsApiV1AnalyticsPerformanceGet(requestParameters: AnalyticsApiGetPerformanceMetricsApiV1AnalyticsPerformanceGetRequest = {}, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getPerformanceMetricsApiV1AnalyticsPerformanceGet(requestParameters.startDate, requestParameters.endDate, requestParameters.period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get system analytics.  Args:     request: System analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     System analytics
     * @summary Get System Analytics
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getSystemAnalyticsApiV1AnalyticsSystemGet(options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getSystemAnalyticsApiV1AnalyticsSystemGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get tool server analytics.  Args:     request: Tool server analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Tool server analytics data
     * @summary Get Tool Server Analytics
     * @param {AnalyticsApiGetToolServerAnalyticsApiV1AnalyticsToolserversGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getToolServerAnalyticsApiV1AnalyticsToolserversGet(requestParameters: AnalyticsApiGetToolServerAnalyticsApiV1AnalyticsToolserversGetRequest = {}, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getToolServerAnalyticsApiV1AnalyticsToolserversGet(requestParameters.startDate, requestParameters.endDate, requestParameters.period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get usage metrics.  Args:     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Usage metrics
     * @summary Get Usage Metrics
     * @param {AnalyticsApiGetUsageMetricsApiV1AnalyticsUsageGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getUsageMetricsApiV1AnalyticsUsageGet(requestParameters: AnalyticsApiGetUsageMetricsApiV1AnalyticsUsageGetRequest = {}, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getUsageMetricsApiV1AnalyticsUsageGet(requestParameters.startDate, requestParameters.endDate, requestParameters.period, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get per-user analytics.  Args:     user_id: User ID     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     User-specific analytics
     * @summary Get User Analytics
     * @param {AnalyticsApiGetUserAnalyticsApiV1AnalyticsUsersUserIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnalyticsApi
     */
    public getUserAnalyticsApiV1AnalyticsUsersUserIdGet(requestParameters: AnalyticsApiGetUserAnalyticsApiV1AnalyticsUsersUserIdGetRequest, options?: RawAxiosRequestConfig) {
        return AnalyticsApiFp(this.configuration).getUserAnalyticsApiV1AnalyticsUsersUserIdGet(requestParameters.userId, requestParameters.startDate, requestParameters.endDate, requestParameters.period, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Change user password.  Args:     password_data: Password change data     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
         * @summary Change Password
         * @param {PasswordChange} passwordChange 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordApiV1AuthChangePasswordPost: async (passwordChange: PasswordChange, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'passwordChange' is not null or undefined
            assertParamExists('changePasswordApiV1AuthChangePasswordPost', 'passwordChange', passwordChange)
            const localVarPath = `/api/v1/auth/change-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(passwordChange, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Confirm password reset.  Args:     token: Reset token     new_password: New password     auth_service: Authentication service  Returns:     Success message
         * @summary Confirm Password Reset
         * @param {string} token 
         * @param {string} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPasswordResetApiV1AuthPasswordResetConfirmPost: async (token: string, newPassword: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('confirmPasswordResetApiV1AuthPasswordResetConfirmPost', 'token', token)
            // verify required parameter 'newPassword' is not null or undefined
            assertParamExists('confirmPasswordResetApiV1AuthPasswordResetConfirmPost', 'newPassword', newPassword)
            const localVarPath = `/api/v1/auth/password-reset/confirm`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }

            if (newPassword !== undefined) {
                localVarQueryParameter['new_password'] = newPassword;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create API key for current user.  Args:     key_data: API key creation data     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Created API key
         * @summary Create Api Key
         * @param {APIKeyCreate} aPIKeyCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyApiV1AuthApiKeyPost: async (aPIKeyCreate: APIKeyCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'aPIKeyCreate' is not null or undefined
            assertParamExists('createApiKeyApiV1AuthApiKeyPost', 'aPIKeyCreate', aPIKeyCreate)
            const localVarPath = `/api/v1/auth/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aPIKeyCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deactivate current user account.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
         * @summary Deactivate Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateAccountApiV1AuthAccountDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get current user information.  Args:     current_user: Current authenticated user  Returns:     Current user data
         * @summary Get Current User Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInfoApiV1AuthMeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List user\'s API keys.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     List of API keys
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysApiV1AuthApiKeysGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/api-keys`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate user and return tokens.  Args:     user_data: User login data     auth_service: Authentication service  Returns:     User data and authentication tokens
         * @summary Login
         * @param {UserLogin} userLogin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginApiV1AuthLoginPost: async (userLogin: UserLogin, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userLogin' is not null or undefined
            assertParamExists('loginApiV1AuthLoginPost', 'userLogin', userLogin)
            const localVarPath = `/api/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userLogin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout and revoke current token.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutApiV1AuthLogoutPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refresh access token.  Args:     token_data: Refresh token data     auth_service: Authentication service  Returns:     New access and refresh tokens
         * @summary Refresh Token
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenApiV1AuthRefreshPost: async (tokenRefresh: TokenRefresh, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRefresh' is not null or undefined
            assertParamExists('refreshTokenApiV1AuthRefreshPost', 'tokenRefresh', tokenRefresh)
            const localVarPath = `/api/v1/auth/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRefresh, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Register a new user.  Args:     user_data: User registration data     auth_service: Authentication service  Returns:     User data and authentication tokens
         * @summary Register
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerApiV1AuthRegisterPost: async (userCreate: UserCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('registerApiV1AuthRegisterPost', 'userCreate', userCreate)
            const localVarPath = `/api/v1/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Request password reset.  Args:     email: User email     auth_service: Authentication service  Returns:     Success message
         * @summary Request Password Reset
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordResetApiV1AuthPasswordResetRequestPost: async (email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'email' is not null or undefined
            assertParamExists('requestPasswordResetApiV1AuthPasswordResetRequestPost', 'email', email)
            const localVarPath = `/api/v1/auth/password-reset/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke current user\'s API key.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
         * @summary Revoke Api Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeApiKeyApiV1AuthApiKeyDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/api-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update current user profile.  Args:     user_data: Profile update data     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Updated user data
         * @summary Update Profile
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileApiV1AuthMePut: async (userUpdate: UserUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('updateProfileApiV1AuthMePut', 'userUpdate', userUpdate)
            const localVarPath = `/api/v1/auth/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Change user password.  Args:     password_data: Password change data     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
         * @summary Change Password
         * @param {PasswordChange} passwordChange 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePasswordApiV1AuthChangePasswordPost(passwordChange: PasswordChange, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordChangeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changePasswordApiV1AuthChangePasswordPost(passwordChange, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.changePasswordApiV1AuthChangePasswordPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Confirm password reset.  Args:     token: Reset token     new_password: New password     auth_service: Authentication service  Returns:     Success message
         * @summary Confirm Password Reset
         * @param {string} token 
         * @param {string} newPassword 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async confirmPasswordResetApiV1AuthPasswordResetConfirmPost(token: string, newPassword: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordResetConfirmResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.confirmPasswordResetApiV1AuthPasswordResetConfirmPost(token, newPassword, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.confirmPasswordResetApiV1AuthPasswordResetConfirmPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create API key for current user.  Args:     key_data: API key creation data     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Created API key
         * @summary Create Api Key
         * @param {APIKeyCreate} aPIKeyCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createApiKeyApiV1AuthApiKeyPost(aPIKeyCreate: APIKeyCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createApiKeyApiV1AuthApiKeyPost(aPIKeyCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.createApiKeyApiV1AuthApiKeyPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deactivate current user account.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
         * @summary Deactivate Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deactivateAccountApiV1AuthAccountDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountDeactivateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deactivateAccountApiV1AuthAccountDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.deactivateAccountApiV1AuthAccountDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get current user information.  Args:     current_user: Current authenticated user  Returns:     Current user data
         * @summary Get Current User Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUserInfoApiV1AuthMeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUserInfoApiV1AuthMeGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.getCurrentUserInfoApiV1AuthMeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List user\'s API keys.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     List of API keys
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listApiKeysApiV1AuthApiKeysGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<APIKeyResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listApiKeysApiV1AuthApiKeysGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.listApiKeysApiV1AuthApiKeysGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authenticate user and return tokens.  Args:     user_data: User login data     auth_service: Authentication service  Returns:     User data and authentication tokens
         * @summary Login
         * @param {UserLogin} userLogin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginApiV1AuthLoginPost(userLogin: UserLogin, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginApiV1AuthLoginPost(userLogin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.loginApiV1AuthLoginPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Logout and revoke current token.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutApiV1AuthLogoutPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutApiV1AuthLogoutPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.logoutApiV1AuthLogoutPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Refresh access token.  Args:     token_data: Refresh token data     auth_service: Authentication service  Returns:     New access and refresh tokens
         * @summary Refresh Token
         * @param {TokenRefresh} tokenRefresh 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshTokenApiV1AuthRefreshPost(tokenRefresh: TokenRefresh, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenRefreshResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshTokenApiV1AuthRefreshPost(tokenRefresh, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.refreshTokenApiV1AuthRefreshPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Register a new user.  Args:     user_data: User registration data     auth_service: Authentication service  Returns:     User data and authentication tokens
         * @summary Register
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerApiV1AuthRegisterPost(userCreate: UserCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerApiV1AuthRegisterPost(userCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.registerApiV1AuthRegisterPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Request password reset.  Args:     email: User email     auth_service: Authentication service  Returns:     Success message
         * @summary Request Password Reset
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async requestPasswordResetApiV1AuthPasswordResetRequestPost(email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PasswordResetRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.requestPasswordResetApiV1AuthPasswordResetRequestPost(email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.requestPasswordResetApiV1AuthPasswordResetRequestPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Revoke current user\'s API key.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
         * @summary Revoke Api Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeApiKeyApiV1AuthApiKeyDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<APIKeyRevokeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.revokeApiKeyApiV1AuthApiKeyDelete(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.revokeApiKeyApiV1AuthApiKeyDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update current user profile.  Args:     user_data: Profile update data     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Updated user data
         * @summary Update Profile
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfileApiV1AuthMePut(userUpdate: UserUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfileApiV1AuthMePut(userUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.updateProfileApiV1AuthMePut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Change user password.  Args:     password_data: Password change data     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
         * @summary Change Password
         * @param {AuthenticationApiChangePasswordApiV1AuthChangePasswordPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordApiV1AuthChangePasswordPost(requestParameters: AuthenticationApiChangePasswordApiV1AuthChangePasswordPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PasswordChangeResponse> {
            return localVarFp.changePasswordApiV1AuthChangePasswordPost(requestParameters.passwordChange, options).then((request) => request(axios, basePath));
        },
        /**
         * Confirm password reset.  Args:     token: Reset token     new_password: New password     auth_service: Authentication service  Returns:     Success message
         * @summary Confirm Password Reset
         * @param {AuthenticationApiConfirmPasswordResetApiV1AuthPasswordResetConfirmPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        confirmPasswordResetApiV1AuthPasswordResetConfirmPost(requestParameters: AuthenticationApiConfirmPasswordResetApiV1AuthPasswordResetConfirmPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PasswordResetConfirmResponse> {
            return localVarFp.confirmPasswordResetApiV1AuthPasswordResetConfirmPost(requestParameters.token, requestParameters.newPassword, options).then((request) => request(axios, basePath));
        },
        /**
         * Create API key for current user.  Args:     key_data: API key creation data     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Created API key
         * @summary Create Api Key
         * @param {AuthenticationApiCreateApiKeyApiV1AuthApiKeyPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createApiKeyApiV1AuthApiKeyPost(requestParameters: AuthenticationApiCreateApiKeyApiV1AuthApiKeyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<APIKeyResponse> {
            return localVarFp.createApiKeyApiV1AuthApiKeyPost(requestParameters.aPIKeyCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Deactivate current user account.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
         * @summary Deactivate Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deactivateAccountApiV1AuthAccountDelete(options?: RawAxiosRequestConfig): AxiosPromise<AccountDeactivateResponse> {
            return localVarFp.deactivateAccountApiV1AuthAccountDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * Get current user information.  Args:     current_user: Current authenticated user  Returns:     Current user data
         * @summary Get Current User Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserInfoApiV1AuthMeGet(options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.getCurrentUserInfoApiV1AuthMeGet(options).then((request) => request(axios, basePath));
        },
        /**
         * List user\'s API keys.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     List of API keys
         * @summary List Api Keys
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listApiKeysApiV1AuthApiKeysGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<APIKeyResponse>> {
            return localVarFp.listApiKeysApiV1AuthApiKeysGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate user and return tokens.  Args:     user_data: User login data     auth_service: Authentication service  Returns:     User data and authentication tokens
         * @summary Login
         * @param {AuthenticationApiLoginApiV1AuthLoginPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginApiV1AuthLoginPost(requestParameters: AuthenticationApiLoginApiV1AuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse> {
            return localVarFp.loginApiV1AuthLoginPost(requestParameters.userLogin, options).then((request) => request(axios, basePath));
        },
        /**
         * Logout and revoke current token.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutApiV1AuthLogoutPost(options?: RawAxiosRequestConfig): AxiosPromise<LogoutResponse> {
            return localVarFp.logoutApiV1AuthLogoutPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Refresh access token.  Args:     token_data: Refresh token data     auth_service: Authentication service  Returns:     New access and refresh tokens
         * @summary Refresh Token
         * @param {AuthenticationApiRefreshTokenApiV1AuthRefreshPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshTokenApiV1AuthRefreshPost(requestParameters: AuthenticationApiRefreshTokenApiV1AuthRefreshPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenRefreshResponse> {
            return localVarFp.refreshTokenApiV1AuthRefreshPost(requestParameters.tokenRefresh, options).then((request) => request(axios, basePath));
        },
        /**
         * Register a new user.  Args:     user_data: User registration data     auth_service: Authentication service  Returns:     User data and authentication tokens
         * @summary Register
         * @param {AuthenticationApiRegisterApiV1AuthRegisterPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerApiV1AuthRegisterPost(requestParameters: AuthenticationApiRegisterApiV1AuthRegisterPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse> {
            return localVarFp.registerApiV1AuthRegisterPost(requestParameters.userCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Request password reset.  Args:     email: User email     auth_service: Authentication service  Returns:     Success message
         * @summary Request Password Reset
         * @param {AuthenticationApiRequestPasswordResetApiV1AuthPasswordResetRequestPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        requestPasswordResetApiV1AuthPasswordResetRequestPost(requestParameters: AuthenticationApiRequestPasswordResetApiV1AuthPasswordResetRequestPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PasswordResetRequestResponse> {
            return localVarFp.requestPasswordResetApiV1AuthPasswordResetRequestPost(requestParameters.email, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke current user\'s API key.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
         * @summary Revoke Api Key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeApiKeyApiV1AuthApiKeyDelete(options?: RawAxiosRequestConfig): AxiosPromise<APIKeyRevokeResponse> {
            return localVarFp.revokeApiKeyApiV1AuthApiKeyDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * Update current user profile.  Args:     user_data: Profile update data     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Updated user data
         * @summary Update Profile
         * @param {AuthenticationApiUpdateProfileApiV1AuthMePutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileApiV1AuthMePut(requestParameters: AuthenticationApiUpdateProfileApiV1AuthMePutRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.updateProfileApiV1AuthMePut(requestParameters.userUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - interface
 * @export
 * @interface AuthenticationApi
 */
export interface AuthenticationApiInterface {
    /**
     * Change user password.  Args:     password_data: Password change data     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
     * @summary Change Password
     * @param {AuthenticationApiChangePasswordApiV1AuthChangePasswordPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    changePasswordApiV1AuthChangePasswordPost(requestParameters: AuthenticationApiChangePasswordApiV1AuthChangePasswordPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PasswordChangeResponse>;

    /**
     * Confirm password reset.  Args:     token: Reset token     new_password: New password     auth_service: Authentication service  Returns:     Success message
     * @summary Confirm Password Reset
     * @param {AuthenticationApiConfirmPasswordResetApiV1AuthPasswordResetConfirmPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    confirmPasswordResetApiV1AuthPasswordResetConfirmPost(requestParameters: AuthenticationApiConfirmPasswordResetApiV1AuthPasswordResetConfirmPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PasswordResetConfirmResponse>;

    /**
     * Create API key for current user.  Args:     key_data: API key creation data     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Created API key
     * @summary Create Api Key
     * @param {AuthenticationApiCreateApiKeyApiV1AuthApiKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    createApiKeyApiV1AuthApiKeyPost(requestParameters: AuthenticationApiCreateApiKeyApiV1AuthApiKeyPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<APIKeyResponse>;

    /**
     * Deactivate current user account.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
     * @summary Deactivate Account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    deactivateAccountApiV1AuthAccountDelete(options?: RawAxiosRequestConfig): AxiosPromise<AccountDeactivateResponse>;

    /**
     * Get current user information.  Args:     current_user: Current authenticated user  Returns:     Current user data
     * @summary Get Current User Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    getCurrentUserInfoApiV1AuthMeGet(options?: RawAxiosRequestConfig): AxiosPromise<UserResponse>;

    /**
     * List user\'s API keys.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     List of API keys
     * @summary List Api Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    listApiKeysApiV1AuthApiKeysGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<APIKeyResponse>>;

    /**
     * Authenticate user and return tokens.  Args:     user_data: User login data     auth_service: Authentication service  Returns:     User data and authentication tokens
     * @summary Login
     * @param {AuthenticationApiLoginApiV1AuthLoginPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    loginApiV1AuthLoginPost(requestParameters: AuthenticationApiLoginApiV1AuthLoginPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse>;

    /**
     * Logout and revoke current token.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    logoutApiV1AuthLogoutPost(options?: RawAxiosRequestConfig): AxiosPromise<LogoutResponse>;

    /**
     * Refresh access token.  Args:     token_data: Refresh token data     auth_service: Authentication service  Returns:     New access and refresh tokens
     * @summary Refresh Token
     * @param {AuthenticationApiRefreshTokenApiV1AuthRefreshPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    refreshTokenApiV1AuthRefreshPost(requestParameters: AuthenticationApiRefreshTokenApiV1AuthRefreshPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenRefreshResponse>;

    /**
     * Register a new user.  Args:     user_data: User registration data     auth_service: Authentication service  Returns:     User data and authentication tokens
     * @summary Register
     * @param {AuthenticationApiRegisterApiV1AuthRegisterPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    registerApiV1AuthRegisterPost(requestParameters: AuthenticationApiRegisterApiV1AuthRegisterPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<TokenResponse>;

    /**
     * Request password reset.  Args:     email: User email     auth_service: Authentication service  Returns:     Success message
     * @summary Request Password Reset
     * @param {AuthenticationApiRequestPasswordResetApiV1AuthPasswordResetRequestPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    requestPasswordResetApiV1AuthPasswordResetRequestPost(requestParameters: AuthenticationApiRequestPasswordResetApiV1AuthPasswordResetRequestPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PasswordResetRequestResponse>;

    /**
     * Revoke current user\'s API key.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
     * @summary Revoke Api Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    revokeApiKeyApiV1AuthApiKeyDelete(options?: RawAxiosRequestConfig): AxiosPromise<APIKeyRevokeResponse>;

    /**
     * Update current user profile.  Args:     user_data: Profile update data     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Updated user data
     * @summary Update Profile
     * @param {AuthenticationApiUpdateProfileApiV1AuthMePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApiInterface
     */
    updateProfileApiV1AuthMePut(requestParameters: AuthenticationApiUpdateProfileApiV1AuthMePutRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse>;

}

/**
 * Request parameters for changePasswordApiV1AuthChangePasswordPost operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiChangePasswordApiV1AuthChangePasswordPostRequest
 */
export interface AuthenticationApiChangePasswordApiV1AuthChangePasswordPostRequest {
    /**
     * 
     * @type {PasswordChange}
     * @memberof AuthenticationApiChangePasswordApiV1AuthChangePasswordPost
     */
    readonly passwordChange: PasswordChange
}

/**
 * Request parameters for confirmPasswordResetApiV1AuthPasswordResetConfirmPost operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiConfirmPasswordResetApiV1AuthPasswordResetConfirmPostRequest
 */
export interface AuthenticationApiConfirmPasswordResetApiV1AuthPasswordResetConfirmPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationApiConfirmPasswordResetApiV1AuthPasswordResetConfirmPost
     */
    readonly token: string

    /**
     * 
     * @type {string}
     * @memberof AuthenticationApiConfirmPasswordResetApiV1AuthPasswordResetConfirmPost
     */
    readonly newPassword: string
}

/**
 * Request parameters for createApiKeyApiV1AuthApiKeyPost operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiCreateApiKeyApiV1AuthApiKeyPostRequest
 */
export interface AuthenticationApiCreateApiKeyApiV1AuthApiKeyPostRequest {
    /**
     * 
     * @type {APIKeyCreate}
     * @memberof AuthenticationApiCreateApiKeyApiV1AuthApiKeyPost
     */
    readonly aPIKeyCreate: APIKeyCreate
}

/**
 * Request parameters for loginApiV1AuthLoginPost operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiLoginApiV1AuthLoginPostRequest
 */
export interface AuthenticationApiLoginApiV1AuthLoginPostRequest {
    /**
     * 
     * @type {UserLogin}
     * @memberof AuthenticationApiLoginApiV1AuthLoginPost
     */
    readonly userLogin: UserLogin
}

/**
 * Request parameters for refreshTokenApiV1AuthRefreshPost operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiRefreshTokenApiV1AuthRefreshPostRequest
 */
export interface AuthenticationApiRefreshTokenApiV1AuthRefreshPostRequest {
    /**
     * 
     * @type {TokenRefresh}
     * @memberof AuthenticationApiRefreshTokenApiV1AuthRefreshPost
     */
    readonly tokenRefresh: TokenRefresh
}

/**
 * Request parameters for registerApiV1AuthRegisterPost operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiRegisterApiV1AuthRegisterPostRequest
 */
export interface AuthenticationApiRegisterApiV1AuthRegisterPostRequest {
    /**
     * 
     * @type {UserCreate}
     * @memberof AuthenticationApiRegisterApiV1AuthRegisterPost
     */
    readonly userCreate: UserCreate
}

/**
 * Request parameters for requestPasswordResetApiV1AuthPasswordResetRequestPost operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiRequestPasswordResetApiV1AuthPasswordResetRequestPostRequest
 */
export interface AuthenticationApiRequestPasswordResetApiV1AuthPasswordResetRequestPostRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthenticationApiRequestPasswordResetApiV1AuthPasswordResetRequestPost
     */
    readonly email: string
}

/**
 * Request parameters for updateProfileApiV1AuthMePut operation in AuthenticationApi.
 * @export
 * @interface AuthenticationApiUpdateProfileApiV1AuthMePutRequest
 */
export interface AuthenticationApiUpdateProfileApiV1AuthMePutRequest {
    /**
     * 
     * @type {UserUpdate}
     * @memberof AuthenticationApiUpdateProfileApiV1AuthMePut
     */
    readonly userUpdate: UserUpdate
}

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI implements AuthenticationApiInterface {
    /**
     * Change user password.  Args:     password_data: Password change data     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
     * @summary Change Password
     * @param {AuthenticationApiChangePasswordApiV1AuthChangePasswordPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public changePasswordApiV1AuthChangePasswordPost(requestParameters: AuthenticationApiChangePasswordApiV1AuthChangePasswordPostRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).changePasswordApiV1AuthChangePasswordPost(requestParameters.passwordChange, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Confirm password reset.  Args:     token: Reset token     new_password: New password     auth_service: Authentication service  Returns:     Success message
     * @summary Confirm Password Reset
     * @param {AuthenticationApiConfirmPasswordResetApiV1AuthPasswordResetConfirmPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public confirmPasswordResetApiV1AuthPasswordResetConfirmPost(requestParameters: AuthenticationApiConfirmPasswordResetApiV1AuthPasswordResetConfirmPostRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).confirmPasswordResetApiV1AuthPasswordResetConfirmPost(requestParameters.token, requestParameters.newPassword, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create API key for current user.  Args:     key_data: API key creation data     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Created API key
     * @summary Create Api Key
     * @param {AuthenticationApiCreateApiKeyApiV1AuthApiKeyPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public createApiKeyApiV1AuthApiKeyPost(requestParameters: AuthenticationApiCreateApiKeyApiV1AuthApiKeyPostRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).createApiKeyApiV1AuthApiKeyPost(requestParameters.aPIKeyCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deactivate current user account.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
     * @summary Deactivate Account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public deactivateAccountApiV1AuthAccountDelete(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).deactivateAccountApiV1AuthAccountDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get current user information.  Args:     current_user: Current authenticated user  Returns:     Current user data
     * @summary Get Current User Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public getCurrentUserInfoApiV1AuthMeGet(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).getCurrentUserInfoApiV1AuthMeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List user\'s API keys.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     List of API keys
     * @summary List Api Keys
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public listApiKeysApiV1AuthApiKeysGet(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).listApiKeysApiV1AuthApiKeysGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate user and return tokens.  Args:     user_data: User login data     auth_service: Authentication service  Returns:     User data and authentication tokens
     * @summary Login
     * @param {AuthenticationApiLoginApiV1AuthLoginPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public loginApiV1AuthLoginPost(requestParameters: AuthenticationApiLoginApiV1AuthLoginPostRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).loginApiV1AuthLoginPost(requestParameters.userLogin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout and revoke current token.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public logoutApiV1AuthLogoutPost(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).logoutApiV1AuthLogoutPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Refresh access token.  Args:     token_data: Refresh token data     auth_service: Authentication service  Returns:     New access and refresh tokens
     * @summary Refresh Token
     * @param {AuthenticationApiRefreshTokenApiV1AuthRefreshPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public refreshTokenApiV1AuthRefreshPost(requestParameters: AuthenticationApiRefreshTokenApiV1AuthRefreshPostRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).refreshTokenApiV1AuthRefreshPost(requestParameters.tokenRefresh, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Register a new user.  Args:     user_data: User registration data     auth_service: Authentication service  Returns:     User data and authentication tokens
     * @summary Register
     * @param {AuthenticationApiRegisterApiV1AuthRegisterPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public registerApiV1AuthRegisterPost(requestParameters: AuthenticationApiRegisterApiV1AuthRegisterPostRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).registerApiV1AuthRegisterPost(requestParameters.userCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Request password reset.  Args:     email: User email     auth_service: Authentication service  Returns:     Success message
     * @summary Request Password Reset
     * @param {AuthenticationApiRequestPasswordResetApiV1AuthPasswordResetRequestPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public requestPasswordResetApiV1AuthPasswordResetRequestPost(requestParameters: AuthenticationApiRequestPasswordResetApiV1AuthPasswordResetRequestPostRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).requestPasswordResetApiV1AuthPasswordResetRequestPost(requestParameters.email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke current user\'s API key.  Args:     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Success message
     * @summary Revoke Api Key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public revokeApiKeyApiV1AuthApiKeyDelete(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).revokeApiKeyApiV1AuthApiKeyDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update current user profile.  Args:     user_data: Profile update data     current_user: Current authenticated user     auth_service: Authentication service  Returns:     Updated user data
     * @summary Update Profile
     * @param {AuthenticationApiUpdateProfileApiV1AuthMePutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public updateProfileApiV1AuthMePut(requestParameters: AuthenticationApiUpdateProfileApiV1AuthMePutRequest, options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).updateProfileApiV1AuthMePut(requestParameters.userUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ChatApi - axios parameter creator
 * @export
 */
export const ChatApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new message to existing conversation.
         * @summary Add Message To Conversation
         * @param {string} conversationId 
         * @param {MessageCreate} messageCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost: async (conversationId: string, messageCreate: MessageCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost', 'conversationId', conversationId)
            // verify required parameter 'messageCreate' is not null or undefined
            assertParamExists('addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost', 'messageCreate', messageCreate)
            const localVarPath = `/api/v1/chat/conversations/{conversation_id}/messages`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Single chat endpoint supporting plain, rag, tools, and full workflows.  - If chat_request.stream is True, returns SSE stream. - Otherwise returns ChatResponse JSON.
         * @summary Chat
         * @param {ChatRequest} chatRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatApiV1ChatChatPost: async (chatRequest: ChatRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatRequest' is not null or undefined
            assertParamExists('chatApiV1ChatChatPost', 'chatRequest', chatRequest)
            const localVarPath = `/api/v1/chat/chat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new conversation.  Args:     conversation_data: Conversation creation data     current_user: Current authenticated user     chat_service: Chat service  Returns:     Created conversation
         * @summary Create Conversation
         * @param {ConversationCreate} conversationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationApiV1ChatConversationsPost: async (conversationCreate: ConversationCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationCreate' is not null or undefined
            assertParamExists('createConversationApiV1ChatConversationsPost', 'conversationCreate', conversationCreate)
            const localVarPath = `/api/v1/chat/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conversationCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete conversation.
         * @summary Delete Conversation
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationApiV1ChatConversationsConversationIdDelete: async (conversationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('deleteConversationApiV1ChatConversationsConversationIdDelete', 'conversationId', conversationId)
            const localVarPath = `/api/v1/chat/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a message from conversation.
         * @summary Delete Message
         * @param {string} conversationId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete: async (conversationId: string, messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete', 'conversationId', conversationId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete', 'messageId', messageId)
            const localVarPath = `/api/v1/chat/conversations/{conversation_id}/messages/{message_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of available MCP tools.
         * @summary Get Available Tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableToolsApiV1ChatToolsAvailableGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/chat/tools/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get conversation details with messages.
         * @summary Get Conversation
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationApiV1ChatConversationsConversationIdGet: async (conversationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('getConversationApiV1ChatConversationsConversationIdGet', 'conversationId', conversationId)
            const localVarPath = `/api/v1/chat/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get conversation messages.
         * @summary Get Conversation Messages
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet: async (conversationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet', 'conversationId', conversationId)
            const localVarPath = `/api/v1/chat/conversations/{conversation_id}/messages`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get MCP service status.
         * @summary Get Mcp Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMcpStatusApiV1ChatMcpStatusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/chat/mcp/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List user\'s conversations.  Note: Filters may be ignored if not supported by the service implementation.
         * @summary List Conversations
         * @param {string | null} [query] Search query
         * @param {ConversationStatus | null} [status] Filter by status
         * @param {number} [limit] Maximum number of results
         * @param {number} [offset] Number of results to skip
         * @param {string} [sortBy] Sort field
         * @param {string} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsApiV1ChatConversationsGet: async (query?: string | null, status?: ConversationStatus | null, limit?: number, offset?: number, sortBy?: string, sortOrder?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/chat/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update conversation.
         * @summary Update Conversation
         * @param {string} conversationId 
         * @param {ConversationUpdate} conversationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationApiV1ChatConversationsConversationIdPut: async (conversationId: string, conversationUpdate: ConversationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('updateConversationApiV1ChatConversationsConversationIdPut', 'conversationId', conversationId)
            // verify required parameter 'conversationUpdate' is not null or undefined
            assertParamExists('updateConversationApiV1ChatConversationsConversationIdPut', 'conversationUpdate', conversationUpdate)
            const localVarPath = `/api/v1/chat/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conversationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatApi - functional programming interface
 * @export
 */
export const ChatApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new message to existing conversation.
         * @summary Add Message To Conversation
         * @param {string} conversationId 
         * @param {MessageCreate} messageCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost(conversationId: string, messageCreate: MessageCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost(conversationId, messageCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Single chat endpoint supporting plain, rag, tools, and full workflows.  - If chat_request.stream is True, returns SSE stream. - Otherwise returns ChatResponse JSON.
         * @summary Chat
         * @param {ChatRequest} chatRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatApiV1ChatChatPost(chatRequest: ChatRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatApiV1ChatChatPost(chatRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.chatApiV1ChatChatPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new conversation.  Args:     conversation_data: Conversation creation data     current_user: Current authenticated user     chat_service: Chat service  Returns:     Created conversation
         * @summary Create Conversation
         * @param {ConversationCreate} conversationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversationApiV1ChatConversationsPost(conversationCreate: ConversationCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConversationApiV1ChatConversationsPost(conversationCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.createConversationApiV1ChatConversationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete conversation.
         * @summary Delete Conversation
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversationApiV1ChatConversationsConversationIdDelete(conversationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConversationApiV1ChatConversationsConversationIdDelete(conversationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.deleteConversationApiV1ChatConversationsConversationIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a message from conversation.
         * @summary Delete Message
         * @param {string} conversationId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete(conversationId: string, messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete(conversationId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of available MCP tools.
         * @summary Get Available Tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableToolsApiV1ChatToolsAvailableGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableToolsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableToolsApiV1ChatToolsAvailableGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.getAvailableToolsApiV1ChatToolsAvailableGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get conversation details with messages.
         * @summary Get Conversation
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationApiV1ChatConversationsConversationIdGet(conversationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationWithMessages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversationApiV1ChatConversationsConversationIdGet(conversationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.getConversationApiV1ChatConversationsConversationIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get conversation messages.
         * @summary Get Conversation Messages
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet(conversationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet(conversationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get MCP service status.
         * @summary Get Mcp Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMcpStatusApiV1ChatMcpStatusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<McpStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMcpStatusApiV1ChatMcpStatusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.getMcpStatusApiV1ChatMcpStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List user\'s conversations.  Note: Filters may be ignored if not supported by the service implementation.
         * @summary List Conversations
         * @param {string | null} [query] Search query
         * @param {ConversationStatus | null} [status] Filter by status
         * @param {number} [limit] Maximum number of results
         * @param {number} [offset] Number of results to skip
         * @param {string} [sortBy] Sort field
         * @param {string} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversationsApiV1ChatConversationsGet(query?: string | null, status?: ConversationStatus | null, limit?: number, offset?: number, sortBy?: string, sortOrder?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConversationsApiV1ChatConversationsGet(query, status, limit, offset, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.listConversationsApiV1ChatConversationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update conversation.
         * @summary Update Conversation
         * @param {string} conversationId 
         * @param {ConversationUpdate} conversationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConversationApiV1ChatConversationsConversationIdPut(conversationId: string, conversationUpdate: ConversationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConversationApiV1ChatConversationsConversationIdPut(conversationId, conversationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.updateConversationApiV1ChatConversationsConversationIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatApi - factory interface
 * @export
 */
export const ChatApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatApiFp(configuration)
    return {
        /**
         * Add a new message to existing conversation.
         * @summary Add Message To Conversation
         * @param {ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost(requestParameters: ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost(requestParameters.conversationId, requestParameters.messageCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Single chat endpoint supporting plain, rag, tools, and full workflows.  - If chat_request.stream is True, returns SSE stream. - Otherwise returns ChatResponse JSON.
         * @summary Chat
         * @param {ChatApiChatApiV1ChatChatPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatApiV1ChatChatPost(requestParameters: ChatApiChatApiV1ChatChatPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatResponse> {
            return localVarFp.chatApiV1ChatChatPost(requestParameters.chatRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new conversation.  Args:     conversation_data: Conversation creation data     current_user: Current authenticated user     chat_service: Chat service  Returns:     Created conversation
         * @summary Create Conversation
         * @param {ChatApiCreateConversationApiV1ChatConversationsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationApiV1ChatConversationsPost(requestParameters: ChatApiCreateConversationApiV1ChatConversationsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationResponse> {
            return localVarFp.createConversationApiV1ChatConversationsPost(requestParameters.conversationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete conversation.
         * @summary Delete Conversation
         * @param {ChatApiDeleteConversationApiV1ChatConversationsConversationIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationApiV1ChatConversationsConversationIdDelete(requestParameters: ChatApiDeleteConversationApiV1ChatConversationsConversationIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationDeleteResponse> {
            return localVarFp.deleteConversationApiV1ChatConversationsConversationIdDelete(requestParameters.conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a message from conversation.
         * @summary Delete Message
         * @param {ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete(requestParameters: ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete(requestParameters.conversationId, requestParameters.messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of available MCP tools.
         * @summary Get Available Tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableToolsApiV1ChatToolsAvailableGet(options?: RawAxiosRequestConfig): AxiosPromise<AvailableToolsResponse> {
            return localVarFp.getAvailableToolsApiV1ChatToolsAvailableGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get conversation details with messages.
         * @summary Get Conversation
         * @param {ChatApiGetConversationApiV1ChatConversationsConversationIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationApiV1ChatConversationsConversationIdGet(requestParameters: ChatApiGetConversationApiV1ChatConversationsConversationIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationWithMessages> {
            return localVarFp.getConversationApiV1ChatConversationsConversationIdGet(requestParameters.conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get conversation messages.
         * @summary Get Conversation Messages
         * @param {ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet(requestParameters: ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MessageResponse>> {
            return localVarFp.getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet(requestParameters.conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get MCP service status.
         * @summary Get Mcp Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMcpStatusApiV1ChatMcpStatusGet(options?: RawAxiosRequestConfig): AxiosPromise<McpStatusResponse> {
            return localVarFp.getMcpStatusApiV1ChatMcpStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * List user\'s conversations.  Note: Filters may be ignored if not supported by the service implementation.
         * @summary List Conversations
         * @param {ChatApiListConversationsApiV1ChatConversationsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsApiV1ChatConversationsGet(requestParameters: ChatApiListConversationsApiV1ChatConversationsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ConversationSearchResponse> {
            return localVarFp.listConversationsApiV1ChatConversationsGet(requestParameters.query, requestParameters.status, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Update conversation.
         * @summary Update Conversation
         * @param {ChatApiUpdateConversationApiV1ChatConversationsConversationIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationApiV1ChatConversationsConversationIdPut(requestParameters: ChatApiUpdateConversationApiV1ChatConversationsConversationIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationResponse> {
            return localVarFp.updateConversationApiV1ChatConversationsConversationIdPut(requestParameters.conversationId, requestParameters.conversationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatApi - interface
 * @export
 * @interface ChatApi
 */
export interface ChatApiInterface {
    /**
     * Add a new message to existing conversation.
     * @summary Add Message To Conversation
     * @param {ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost(requestParameters: ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse>;

    /**
     * Single chat endpoint supporting plain, rag, tools, and full workflows.  - If chat_request.stream is True, returns SSE stream. - Otherwise returns ChatResponse JSON.
     * @summary Chat
     * @param {ChatApiChatApiV1ChatChatPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    chatApiV1ChatChatPost(requestParameters: ChatApiChatApiV1ChatChatPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatResponse>;

    /**
     * Create a new conversation.  Args:     conversation_data: Conversation creation data     current_user: Current authenticated user     chat_service: Chat service  Returns:     Created conversation
     * @summary Create Conversation
     * @param {ChatApiCreateConversationApiV1ChatConversationsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    createConversationApiV1ChatConversationsPost(requestParameters: ChatApiCreateConversationApiV1ChatConversationsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationResponse>;

    /**
     * Delete conversation.
     * @summary Delete Conversation
     * @param {ChatApiDeleteConversationApiV1ChatConversationsConversationIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    deleteConversationApiV1ChatConversationsConversationIdDelete(requestParameters: ChatApiDeleteConversationApiV1ChatConversationsConversationIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationDeleteResponse>;

    /**
     * Delete a message from conversation.
     * @summary Delete Message
     * @param {ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete(requestParameters: ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

    /**
     * Get list of available MCP tools.
     * @summary Get Available Tools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    getAvailableToolsApiV1ChatToolsAvailableGet(options?: RawAxiosRequestConfig): AxiosPromise<AvailableToolsResponse>;

    /**
     * Get conversation details with messages.
     * @summary Get Conversation
     * @param {ChatApiGetConversationApiV1ChatConversationsConversationIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    getConversationApiV1ChatConversationsConversationIdGet(requestParameters: ChatApiGetConversationApiV1ChatConversationsConversationIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationWithMessages>;

    /**
     * Get conversation messages.
     * @summary Get Conversation Messages
     * @param {ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet(requestParameters: ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MessageResponse>>;

    /**
     * Get MCP service status.
     * @summary Get Mcp Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    getMcpStatusApiV1ChatMcpStatusGet(options?: RawAxiosRequestConfig): AxiosPromise<McpStatusResponse>;

    /**
     * List user\'s conversations.  Note: Filters may be ignored if not supported by the service implementation.
     * @summary List Conversations
     * @param {ChatApiListConversationsApiV1ChatConversationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    listConversationsApiV1ChatConversationsGet(requestParameters?: ChatApiListConversationsApiV1ChatConversationsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationSearchResponse>;

    /**
     * Update conversation.
     * @summary Update Conversation
     * @param {ChatApiUpdateConversationApiV1ChatConversationsConversationIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    updateConversationApiV1ChatConversationsConversationIdPut(requestParameters: ChatApiUpdateConversationApiV1ChatConversationsConversationIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationResponse>;

}

/**
 * Request parameters for addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost operation in ChatApi.
 * @export
 * @interface ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPostRequest
 */
export interface ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPost
     */
    readonly conversationId: string

    /**
     * 
     * @type {MessageCreate}
     * @memberof ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPost
     */
    readonly messageCreate: MessageCreate
}

/**
 * Request parameters for chatApiV1ChatChatPost operation in ChatApi.
 * @export
 * @interface ChatApiChatApiV1ChatChatPostRequest
 */
export interface ChatApiChatApiV1ChatChatPostRequest {
    /**
     * 
     * @type {ChatRequest}
     * @memberof ChatApiChatApiV1ChatChatPost
     */
    readonly chatRequest: ChatRequest
}

/**
 * Request parameters for createConversationApiV1ChatConversationsPost operation in ChatApi.
 * @export
 * @interface ChatApiCreateConversationApiV1ChatConversationsPostRequest
 */
export interface ChatApiCreateConversationApiV1ChatConversationsPostRequest {
    /**
     * 
     * @type {ConversationCreate}
     * @memberof ChatApiCreateConversationApiV1ChatConversationsPost
     */
    readonly conversationCreate: ConversationCreate
}

/**
 * Request parameters for deleteConversationApiV1ChatConversationsConversationIdDelete operation in ChatApi.
 * @export
 * @interface ChatApiDeleteConversationApiV1ChatConversationsConversationIdDeleteRequest
 */
export interface ChatApiDeleteConversationApiV1ChatConversationsConversationIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatApiDeleteConversationApiV1ChatConversationsConversationIdDelete
     */
    readonly conversationId: string
}

/**
 * Request parameters for deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete operation in ChatApi.
 * @export
 * @interface ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest
 */
export interface ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete
     */
    readonly conversationId: string

    /**
     * 
     * @type {string}
     * @memberof ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete
     */
    readonly messageId: string
}

/**
 * Request parameters for getConversationApiV1ChatConversationsConversationIdGet operation in ChatApi.
 * @export
 * @interface ChatApiGetConversationApiV1ChatConversationsConversationIdGetRequest
 */
export interface ChatApiGetConversationApiV1ChatConversationsConversationIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatApiGetConversationApiV1ChatConversationsConversationIdGet
     */
    readonly conversationId: string
}

/**
 * Request parameters for getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet operation in ChatApi.
 * @export
 * @interface ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest
 */
export interface ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGet
     */
    readonly conversationId: string
}

/**
 * Request parameters for listConversationsApiV1ChatConversationsGet operation in ChatApi.
 * @export
 * @interface ChatApiListConversationsApiV1ChatConversationsGetRequest
 */
export interface ChatApiListConversationsApiV1ChatConversationsGetRequest {
    /**
     * Search query
     * @type {string}
     * @memberof ChatApiListConversationsApiV1ChatConversationsGet
     */
    readonly query?: string | null

    /**
     * Filter by status
     * @type {ConversationStatus}
     * @memberof ChatApiListConversationsApiV1ChatConversationsGet
     */
    readonly status?: ConversationStatus | null

    /**
     * Maximum number of results
     * @type {number}
     * @memberof ChatApiListConversationsApiV1ChatConversationsGet
     */
    readonly limit?: number

    /**
     * Number of results to skip
     * @type {number}
     * @memberof ChatApiListConversationsApiV1ChatConversationsGet
     */
    readonly offset?: number

    /**
     * Sort field
     * @type {string}
     * @memberof ChatApiListConversationsApiV1ChatConversationsGet
     */
    readonly sortBy?: string

    /**
     * Sort order
     * @type {string}
     * @memberof ChatApiListConversationsApiV1ChatConversationsGet
     */
    readonly sortOrder?: string
}

/**
 * Request parameters for updateConversationApiV1ChatConversationsConversationIdPut operation in ChatApi.
 * @export
 * @interface ChatApiUpdateConversationApiV1ChatConversationsConversationIdPutRequest
 */
export interface ChatApiUpdateConversationApiV1ChatConversationsConversationIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatApiUpdateConversationApiV1ChatConversationsConversationIdPut
     */
    readonly conversationId: string

    /**
     * 
     * @type {ConversationUpdate}
     * @memberof ChatApiUpdateConversationApiV1ChatConversationsConversationIdPut
     */
    readonly conversationUpdate: ConversationUpdate
}

/**
 * ChatApi - object-oriented interface
 * @export
 * @class ChatApi
 * @extends {BaseAPI}
 */
export class ChatApi extends BaseAPI implements ChatApiInterface {
    /**
     * Add a new message to existing conversation.
     * @summary Add Message To Conversation
     * @param {ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost(requestParameters: ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPostRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost(requestParameters.conversationId, requestParameters.messageCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Single chat endpoint supporting plain, rag, tools, and full workflows.  - If chat_request.stream is True, returns SSE stream. - Otherwise returns ChatResponse JSON.
     * @summary Chat
     * @param {ChatApiChatApiV1ChatChatPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public chatApiV1ChatChatPost(requestParameters: ChatApiChatApiV1ChatChatPostRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).chatApiV1ChatChatPost(requestParameters.chatRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new conversation.  Args:     conversation_data: Conversation creation data     current_user: Current authenticated user     chat_service: Chat service  Returns:     Created conversation
     * @summary Create Conversation
     * @param {ChatApiCreateConversationApiV1ChatConversationsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public createConversationApiV1ChatConversationsPost(requestParameters: ChatApiCreateConversationApiV1ChatConversationsPostRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).createConversationApiV1ChatConversationsPost(requestParameters.conversationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete conversation.
     * @summary Delete Conversation
     * @param {ChatApiDeleteConversationApiV1ChatConversationsConversationIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public deleteConversationApiV1ChatConversationsConversationIdDelete(requestParameters: ChatApiDeleteConversationApiV1ChatConversationsConversationIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).deleteConversationApiV1ChatConversationsConversationIdDelete(requestParameters.conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a message from conversation.
     * @summary Delete Message
     * @param {ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete(requestParameters: ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete(requestParameters.conversationId, requestParameters.messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of available MCP tools.
     * @summary Get Available Tools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public getAvailableToolsApiV1ChatToolsAvailableGet(options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).getAvailableToolsApiV1ChatToolsAvailableGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get conversation details with messages.
     * @summary Get Conversation
     * @param {ChatApiGetConversationApiV1ChatConversationsConversationIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public getConversationApiV1ChatConversationsConversationIdGet(requestParameters: ChatApiGetConversationApiV1ChatConversationsConversationIdGetRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).getConversationApiV1ChatConversationsConversationIdGet(requestParameters.conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get conversation messages.
     * @summary Get Conversation Messages
     * @param {ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet(requestParameters: ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet(requestParameters.conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get MCP service status.
     * @summary Get Mcp Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public getMcpStatusApiV1ChatMcpStatusGet(options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).getMcpStatusApiV1ChatMcpStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List user\'s conversations.  Note: Filters may be ignored if not supported by the service implementation.
     * @summary List Conversations
     * @param {ChatApiListConversationsApiV1ChatConversationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public listConversationsApiV1ChatConversationsGet(requestParameters: ChatApiListConversationsApiV1ChatConversationsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).listConversationsApiV1ChatConversationsGet(requestParameters.query, requestParameters.status, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update conversation.
     * @summary Update Conversation
     * @param {ChatApiUpdateConversationApiV1ChatConversationsConversationIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public updateConversationApiV1ChatConversationsConversationIdPut(requestParameters: ChatApiUpdateConversationApiV1ChatConversationsConversationIdPutRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).updateConversationApiV1ChatConversationsConversationIdPut(requestParameters.conversationId, requestParameters.conversationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DataManagementApi - axios parameter creator
 * @export
 */
export const DataManagementApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Bulk delete conversations.
         * @summary Bulk Delete Conversations
         * @param {Array<string | null>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteConversationsApiV1DataBulkDeleteConversationsPost: async (requestBody: Array<string | null>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('bulkDeleteConversationsApiV1DataBulkDeleteConversationsPost', 'requestBody', requestBody)
            const localVarPath = `/api/v1/data/bulk/delete-conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk delete documents.
         * @summary Bulk Delete Documents
         * @param {Array<string | null>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPost: async (requestBody: Array<string | null>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('bulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPost', 'requestBody', requestBody)
            const localVarPath = `/api/v1/data/bulk/delete-documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Bulk delete prompts.
         * @summary Bulk Delete Prompts
         * @param {Array<string | null>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeletePromptsApiV1DataBulkDeletePromptsPost: async (requestBody: Array<string | null>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('bulkDeletePromptsApiV1DataBulkDeletePromptsPost', 'requestBody', requestBody)
            const localVarPath = `/api/v1/data/bulk/delete-prompts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a data backup.
         * @summary Create Backup
         * @param {BackupRequest} backupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBackupApiV1DataBackupPost: async (backupRequest: BackupRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'backupRequest' is not null or undefined
            assertParamExists('createBackupApiV1DataBackupPost', 'backupRequest', backupRequest)
            const localVarPath = `/api/v1/data/backup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(backupRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export data in specified format.
         * @summary Export Data
         * @param {ExportDataRequest} exportDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDataApiV1DataExportPost: async (exportDataRequest: ExportDataRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'exportDataRequest' is not null or undefined
            assertParamExists('exportDataApiV1DataExportPost', 'exportDataRequest', exportDataRequest)
            const localVarPath = `/api/v1/data/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(exportDataRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage statistics and usage information.
         * @summary Get Storage Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageStatsApiV1DataStatsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/data/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List available backups.
         * @summary List Backups
         * @param {BackupType | null} [backupType] 
         * @param {string | null} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBackupsApiV1DataBackupsGet: async (backupType?: BackupType | null, status?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/data/backups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (backupType !== undefined) {
                localVarQueryParameter['backup_type'] = backupType;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore data from a backup.
         * @summary Restore From Backup
         * @param {RestoreRequest} restoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreFromBackupApiV1DataRestorePost: async (restoreRequest: RestoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'restoreRequest' is not null or undefined
            assertParamExists('restoreFromBackupApiV1DataRestorePost', 'restoreRequest', restoreRequest)
            const localVarPath = `/api/v1/data/restore`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(restoreRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataManagementApi - functional programming interface
 * @export
 */
export const DataManagementApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataManagementApiAxiosParamCreator(configuration)
    return {
        /**
         * Bulk delete conversations.
         * @summary Bulk Delete Conversations
         * @param {Array<string | null>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkDeleteConversationsApiV1DataBulkDeleteConversationsPost(requestBody: Array<string | null>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteConversationsApiV1DataBulkDeleteConversationsPost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataManagementApi.bulkDeleteConversationsApiV1DataBulkDeleteConversationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk delete documents.
         * @summary Bulk Delete Documents
         * @param {Array<string | null>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPost(requestBody: Array<string | null>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataManagementApi.bulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Bulk delete prompts.
         * @summary Bulk Delete Prompts
         * @param {Array<string | null>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkDeletePromptsApiV1DataBulkDeletePromptsPost(requestBody: Array<string | null>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeletePromptsApiV1DataBulkDeletePromptsPost(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataManagementApi.bulkDeletePromptsApiV1DataBulkDeletePromptsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a data backup.
         * @summary Create Backup
         * @param {BackupRequest} backupRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createBackupApiV1DataBackupPost(backupRequest: BackupRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createBackupApiV1DataBackupPost(backupRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataManagementApi.createBackupApiV1DataBackupPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export data in specified format.
         * @summary Export Data
         * @param {ExportDataRequest} exportDataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportDataApiV1DataExportPost(exportDataRequest: ExportDataRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportDataResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportDataApiV1DataExportPost(exportDataRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataManagementApi.exportDataApiV1DataExportPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get storage statistics and usage information.
         * @summary Get Storage Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStorageStatsApiV1DataStatsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStorageStatsApiV1DataStatsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataManagementApi.getStorageStatsApiV1DataStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List available backups.
         * @summary List Backups
         * @param {BackupType | null} [backupType] 
         * @param {string | null} [status] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listBackupsApiV1DataBackupsGet(backupType?: BackupType | null, status?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listBackupsApiV1DataBackupsGet(backupType, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataManagementApi.listBackupsApiV1DataBackupsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restore data from a backup.
         * @summary Restore From Backup
         * @param {RestoreRequest} restoreRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreFromBackupApiV1DataRestorePost(restoreRequest: RestoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RestoreResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreFromBackupApiV1DataRestorePost(restoreRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DataManagementApi.restoreFromBackupApiV1DataRestorePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DataManagementApi - factory interface
 * @export
 */
export const DataManagementApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataManagementApiFp(configuration)
    return {
        /**
         * Bulk delete conversations.
         * @summary Bulk Delete Conversations
         * @param {DataManagementApiBulkDeleteConversationsApiV1DataBulkDeleteConversationsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteConversationsApiV1DataBulkDeleteConversationsPost(requestParameters: DataManagementApiBulkDeleteConversationsApiV1DataBulkDeleteConversationsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.bulkDeleteConversationsApiV1DataBulkDeleteConversationsPost(requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk delete documents.
         * @summary Bulk Delete Documents
         * @param {DataManagementApiBulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPost(requestParameters: DataManagementApiBulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.bulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPost(requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Bulk delete prompts.
         * @summary Bulk Delete Prompts
         * @param {DataManagementApiBulkDeletePromptsApiV1DataBulkDeletePromptsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeletePromptsApiV1DataBulkDeletePromptsPost(requestParameters: DataManagementApiBulkDeletePromptsApiV1DataBulkDeletePromptsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.bulkDeletePromptsApiV1DataBulkDeletePromptsPost(requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a data backup.
         * @summary Create Backup
         * @param {DataManagementApiCreateBackupApiV1DataBackupPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBackupApiV1DataBackupPost(requestParameters: DataManagementApiCreateBackupApiV1DataBackupPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<BackupResponse> {
            return localVarFp.createBackupApiV1DataBackupPost(requestParameters.backupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Export data in specified format.
         * @summary Export Data
         * @param {DataManagementApiExportDataApiV1DataExportPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDataApiV1DataExportPost(requestParameters: DataManagementApiExportDataApiV1DataExportPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExportDataResponse> {
            return localVarFp.exportDataApiV1DataExportPost(requestParameters.exportDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage statistics and usage information.
         * @summary Get Storage Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStorageStatsApiV1DataStatsGet(options?: RawAxiosRequestConfig): AxiosPromise<StorageStatsResponse> {
            return localVarFp.getStorageStatsApiV1DataStatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * List available backups.
         * @summary List Backups
         * @param {DataManagementApiListBackupsApiV1DataBackupsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listBackupsApiV1DataBackupsGet(requestParameters: DataManagementApiListBackupsApiV1DataBackupsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<BackupListResponse> {
            return localVarFp.listBackupsApiV1DataBackupsGet(requestParameters.backupType, requestParameters.status, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore data from a backup.
         * @summary Restore From Backup
         * @param {DataManagementApiRestoreFromBackupApiV1DataRestorePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreFromBackupApiV1DataRestorePost(requestParameters: DataManagementApiRestoreFromBackupApiV1DataRestorePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestoreResponse> {
            return localVarFp.restoreFromBackupApiV1DataRestorePost(requestParameters.restoreRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataManagementApi - interface
 * @export
 * @interface DataManagementApi
 */
export interface DataManagementApiInterface {
    /**
     * Bulk delete conversations.
     * @summary Bulk Delete Conversations
     * @param {DataManagementApiBulkDeleteConversationsApiV1DataBulkDeleteConversationsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataManagementApiInterface
     */
    bulkDeleteConversationsApiV1DataBulkDeleteConversationsPost(requestParameters: DataManagementApiBulkDeleteConversationsApiV1DataBulkDeleteConversationsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

    /**
     * Bulk delete documents.
     * @summary Bulk Delete Documents
     * @param {DataManagementApiBulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataManagementApiInterface
     */
    bulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPost(requestParameters: DataManagementApiBulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

    /**
     * Bulk delete prompts.
     * @summary Bulk Delete Prompts
     * @param {DataManagementApiBulkDeletePromptsApiV1DataBulkDeletePromptsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataManagementApiInterface
     */
    bulkDeletePromptsApiV1DataBulkDeletePromptsPost(requestParameters: DataManagementApiBulkDeletePromptsApiV1DataBulkDeletePromptsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

    /**
     * Create a data backup.
     * @summary Create Backup
     * @param {DataManagementApiCreateBackupApiV1DataBackupPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataManagementApiInterface
     */
    createBackupApiV1DataBackupPost(requestParameters: DataManagementApiCreateBackupApiV1DataBackupPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<BackupResponse>;

    /**
     * Export data in specified format.
     * @summary Export Data
     * @param {DataManagementApiExportDataApiV1DataExportPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataManagementApiInterface
     */
    exportDataApiV1DataExportPost(requestParameters: DataManagementApiExportDataApiV1DataExportPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ExportDataResponse>;

    /**
     * Get storage statistics and usage information.
     * @summary Get Storage Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataManagementApiInterface
     */
    getStorageStatsApiV1DataStatsGet(options?: RawAxiosRequestConfig): AxiosPromise<StorageStatsResponse>;

    /**
     * List available backups.
     * @summary List Backups
     * @param {DataManagementApiListBackupsApiV1DataBackupsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataManagementApiInterface
     */
    listBackupsApiV1DataBackupsGet(requestParameters?: DataManagementApiListBackupsApiV1DataBackupsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<BackupListResponse>;

    /**
     * Restore data from a backup.
     * @summary Restore From Backup
     * @param {DataManagementApiRestoreFromBackupApiV1DataRestorePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataManagementApiInterface
     */
    restoreFromBackupApiV1DataRestorePost(requestParameters: DataManagementApiRestoreFromBackupApiV1DataRestorePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<RestoreResponse>;

}

/**
 * Request parameters for bulkDeleteConversationsApiV1DataBulkDeleteConversationsPost operation in DataManagementApi.
 * @export
 * @interface DataManagementApiBulkDeleteConversationsApiV1DataBulkDeleteConversationsPostRequest
 */
export interface DataManagementApiBulkDeleteConversationsApiV1DataBulkDeleteConversationsPostRequest {
    /**
     * 
     * @type {Array<string | null>}
     * @memberof DataManagementApiBulkDeleteConversationsApiV1DataBulkDeleteConversationsPost
     */
    readonly requestBody: Array<string | null>
}

/**
 * Request parameters for bulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPost operation in DataManagementApi.
 * @export
 * @interface DataManagementApiBulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPostRequest
 */
export interface DataManagementApiBulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPostRequest {
    /**
     * 
     * @type {Array<string | null>}
     * @memberof DataManagementApiBulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPost
     */
    readonly requestBody: Array<string | null>
}

/**
 * Request parameters for bulkDeletePromptsApiV1DataBulkDeletePromptsPost operation in DataManagementApi.
 * @export
 * @interface DataManagementApiBulkDeletePromptsApiV1DataBulkDeletePromptsPostRequest
 */
export interface DataManagementApiBulkDeletePromptsApiV1DataBulkDeletePromptsPostRequest {
    /**
     * 
     * @type {Array<string | null>}
     * @memberof DataManagementApiBulkDeletePromptsApiV1DataBulkDeletePromptsPost
     */
    readonly requestBody: Array<string | null>
}

/**
 * Request parameters for createBackupApiV1DataBackupPost operation in DataManagementApi.
 * @export
 * @interface DataManagementApiCreateBackupApiV1DataBackupPostRequest
 */
export interface DataManagementApiCreateBackupApiV1DataBackupPostRequest {
    /**
     * 
     * @type {BackupRequest}
     * @memberof DataManagementApiCreateBackupApiV1DataBackupPost
     */
    readonly backupRequest: BackupRequest
}

/**
 * Request parameters for exportDataApiV1DataExportPost operation in DataManagementApi.
 * @export
 * @interface DataManagementApiExportDataApiV1DataExportPostRequest
 */
export interface DataManagementApiExportDataApiV1DataExportPostRequest {
    /**
     * 
     * @type {ExportDataRequest}
     * @memberof DataManagementApiExportDataApiV1DataExportPost
     */
    readonly exportDataRequest: ExportDataRequest
}

/**
 * Request parameters for listBackupsApiV1DataBackupsGet operation in DataManagementApi.
 * @export
 * @interface DataManagementApiListBackupsApiV1DataBackupsGetRequest
 */
export interface DataManagementApiListBackupsApiV1DataBackupsGetRequest {
    /**
     * 
     * @type {BackupType}
     * @memberof DataManagementApiListBackupsApiV1DataBackupsGet
     */
    readonly backupType?: BackupType | null

    /**
     * 
     * @type {string}
     * @memberof DataManagementApiListBackupsApiV1DataBackupsGet
     */
    readonly status?: string | null
}

/**
 * Request parameters for restoreFromBackupApiV1DataRestorePost operation in DataManagementApi.
 * @export
 * @interface DataManagementApiRestoreFromBackupApiV1DataRestorePostRequest
 */
export interface DataManagementApiRestoreFromBackupApiV1DataRestorePostRequest {
    /**
     * 
     * @type {RestoreRequest}
     * @memberof DataManagementApiRestoreFromBackupApiV1DataRestorePost
     */
    readonly restoreRequest: RestoreRequest
}

/**
 * DataManagementApi - object-oriented interface
 * @export
 * @class DataManagementApi
 * @extends {BaseAPI}
 */
export class DataManagementApi extends BaseAPI implements DataManagementApiInterface {
    /**
     * Bulk delete conversations.
     * @summary Bulk Delete Conversations
     * @param {DataManagementApiBulkDeleteConversationsApiV1DataBulkDeleteConversationsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataManagementApi
     */
    public bulkDeleteConversationsApiV1DataBulkDeleteConversationsPost(requestParameters: DataManagementApiBulkDeleteConversationsApiV1DataBulkDeleteConversationsPostRequest, options?: RawAxiosRequestConfig) {
        return DataManagementApiFp(this.configuration).bulkDeleteConversationsApiV1DataBulkDeleteConversationsPost(requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk delete documents.
     * @summary Bulk Delete Documents
     * @param {DataManagementApiBulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataManagementApi
     */
    public bulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPost(requestParameters: DataManagementApiBulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPostRequest, options?: RawAxiosRequestConfig) {
        return DataManagementApiFp(this.configuration).bulkDeleteDocumentsApiV1DataBulkDeleteDocumentsPost(requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Bulk delete prompts.
     * @summary Bulk Delete Prompts
     * @param {DataManagementApiBulkDeletePromptsApiV1DataBulkDeletePromptsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataManagementApi
     */
    public bulkDeletePromptsApiV1DataBulkDeletePromptsPost(requestParameters: DataManagementApiBulkDeletePromptsApiV1DataBulkDeletePromptsPostRequest, options?: RawAxiosRequestConfig) {
        return DataManagementApiFp(this.configuration).bulkDeletePromptsApiV1DataBulkDeletePromptsPost(requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a data backup.
     * @summary Create Backup
     * @param {DataManagementApiCreateBackupApiV1DataBackupPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataManagementApi
     */
    public createBackupApiV1DataBackupPost(requestParameters: DataManagementApiCreateBackupApiV1DataBackupPostRequest, options?: RawAxiosRequestConfig) {
        return DataManagementApiFp(this.configuration).createBackupApiV1DataBackupPost(requestParameters.backupRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export data in specified format.
     * @summary Export Data
     * @param {DataManagementApiExportDataApiV1DataExportPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataManagementApi
     */
    public exportDataApiV1DataExportPost(requestParameters: DataManagementApiExportDataApiV1DataExportPostRequest, options?: RawAxiosRequestConfig) {
        return DataManagementApiFp(this.configuration).exportDataApiV1DataExportPost(requestParameters.exportDataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage statistics and usage information.
     * @summary Get Storage Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataManagementApi
     */
    public getStorageStatsApiV1DataStatsGet(options?: RawAxiosRequestConfig) {
        return DataManagementApiFp(this.configuration).getStorageStatsApiV1DataStatsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List available backups.
     * @summary List Backups
     * @param {DataManagementApiListBackupsApiV1DataBackupsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataManagementApi
     */
    public listBackupsApiV1DataBackupsGet(requestParameters: DataManagementApiListBackupsApiV1DataBackupsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return DataManagementApiFp(this.configuration).listBackupsApiV1DataBackupsGet(requestParameters.backupType, requestParameters.status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore data from a backup.
     * @summary Restore From Backup
     * @param {DataManagementApiRestoreFromBackupApiV1DataRestorePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataManagementApi
     */
    public restoreFromBackupApiV1DataRestorePost(requestParameters: DataManagementApiRestoreFromBackupApiV1DataRestorePostRequest, options?: RawAxiosRequestConfig) {
        return DataManagementApiFp(this.configuration).restoreFromBackupApiV1DataRestorePost(requestParameters.restoreRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Root endpoint.
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Serve React App
         * @param {string} fullPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveReactAppFullPathGet: async (fullPath: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fullPath' is not null or undefined
            assertParamExists('serveReactAppFullPathGet', 'fullPath', fullPath)
            const localVarPath = `/{full_path}`
                .replace(`{${"full_path"}}`, encodeURIComponent(String(fullPath)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Root endpoint.
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rootGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rootGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.rootGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Serve React App
         * @param {string} fullPath 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serveReactAppFullPathGet(fullPath: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serveReactAppFullPathGet(fullPath, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DefaultApi.serveReactAppFullPathGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Root endpoint.
         * @summary Root
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rootGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.rootGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Serve React App
         * @param {DefaultApiServeReactAppFullPathGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serveReactAppFullPathGet(requestParameters: DefaultApiServeReactAppFullPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.serveReactAppFullPathGet(requestParameters.fullPath, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - interface
 * @export
 * @interface DefaultApi
 */
export interface DefaultApiInterface {
    /**
     * Root endpoint.
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    rootGet(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * 
     * @summary Serve React App
     * @param {DefaultApiServeReactAppFullPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApiInterface
     */
    serveReactAppFullPathGet(requestParameters: DefaultApiServeReactAppFullPathGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

}

/**
 * Request parameters for serveReactAppFullPathGet operation in DefaultApi.
 * @export
 * @interface DefaultApiServeReactAppFullPathGetRequest
 */
export interface DefaultApiServeReactAppFullPathGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiServeReactAppFullPathGet
     */
    readonly fullPath: string
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI implements DefaultApiInterface {
    /**
     * Root endpoint.
     * @summary Root
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public rootGet(options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).rootGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Serve React App
     * @param {DefaultApiServeReactAppFullPathGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public serveReactAppFullPathGet(requestParameters: DefaultApiServeReactAppFullPathGetRequest, options?: RawAxiosRequestConfig) {
        return DefaultApiFp(this.configuration).serveReactAppFullPathGet(requestParameters.fullPath, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DocumentsApi - axios parameter creator
 * @export
 */
export const DocumentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete document.  Args:     document_id: Document ID     request: Delete request parameters     current_user: Current authenticated user     document_service: Document service  Returns:     Success message
         * @summary Delete Document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentApiV1DocumentsDocumentIdDelete: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('deleteDocumentApiV1DocumentsDocumentIdDelete', 'documentId', documentId)
            const localVarPath = `/api/v1/documents/{document_id}`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Download original document file.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     File download response
         * @summary Download Document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentApiV1DocumentsDocumentIdDownloadGet: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('downloadDocumentApiV1DocumentsDocumentIdDownloadGet', 'documentId', documentId)
            const localVarPath = `/api/v1/documents/{document_id}/download`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get document details.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Document information
         * @summary Get Document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentApiV1DocumentsDocumentIdGet: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getDocumentApiV1DocumentsDocumentIdGet', 'documentId', documentId)
            const localVarPath = `/api/v1/documents/{document_id}`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get document chunks.  Args:     document_id: Document ID     limit: Maximum number of results     offset: Number of results to skip     current_user: Current authenticated user     document_service: Document service  Returns:     List of document chunks with pagination
         * @summary Get Document Chunks
         * @param {string} documentId 
         * @param {number} [limit] Maximum number of results
         * @param {number} [offset] Number of results to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentChunksApiV1DocumentsDocumentIdChunksGet: async (documentId: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('getDocumentChunksApiV1DocumentsDocumentIdChunksGet', 'documentId', documentId)
            const localVarPath = `/api/v1/documents/{document_id}/chunks`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get document statistics.  Args:     current_user: Current authenticated user     document_service: Document service  Returns:     Document statistics
         * @summary Get Document Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentStatsApiV1DocumentsStatsOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/documents/stats/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List user\'s documents.  Args:     status: Filter by document status     document_type: Filter by document type     tags: Filter by tags     owner_id: Filter by owner (admin only)     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     document_service: Document service  Returns:     List of documents with pagination info
         * @summary List Documents
         * @param {DocumentStatus | null} [status] Filter by status
         * @param {DocumentType | null} [documentType] Filter by document type
         * @param {Array<string> | null} [tags] Filter by tags
         * @param {string | null} [ownerId] Filter by owner (admin only)
         * @param {number} [limit] Maximum number of results
         * @param {number} [offset] Number of results to skip
         * @param {string} [sortBy] Sort field
         * @param {string} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocumentsApiV1DocumentsGet: async (status?: DocumentStatus | null, documentType?: DocumentType | null, tags?: Array<string> | null, ownerId?: string | null, limit?: number, offset?: number, sortBy?: string, sortOrder?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/documents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (documentType !== undefined) {
                localVarQueryParameter['document_type'] = documentType;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (ownerId !== undefined) {
                localVarQueryParameter['owner_id'] = ownerId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger document processing.  Args:     document_id: Document ID     processing_request: Processing request     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
         * @summary Process Document
         * @param {string} documentId 
         * @param {DocumentProcessingRequest} documentProcessingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processDocumentApiV1DocumentsDocumentIdProcessPost: async (documentId: string, documentProcessingRequest: DocumentProcessingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('processDocumentApiV1DocumentsDocumentIdProcessPost', 'documentId', documentId)
            // verify required parameter 'documentProcessingRequest' is not null or undefined
            assertParamExists('processDocumentApiV1DocumentsDocumentIdProcessPost', 'documentProcessingRequest', documentProcessingRequest)
            const localVarPath = `/api/v1/documents/{document_id}/process`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentProcessingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reprocess an existing document.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
         * @summary Reprocess Document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reprocessDocumentApiV1DocumentsDocumentIdReprocessPost: async (documentId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('reprocessDocumentApiV1DocumentsDocumentIdReprocessPost', 'documentId', documentId)
            const localVarPath = `/api/v1/documents/{document_id}/reprocess`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search documents using vector similarity.  Args:     search_request: Search request     current_user: Current authenticated user     document_service: Document service  Returns:     Search results
         * @summary Search Documents
         * @param {DocumentSearchRequest} documentSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocumentsApiV1DocumentsSearchPost: async (documentSearchRequest: DocumentSearchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentSearchRequest' is not null or undefined
            assertParamExists('searchDocumentsApiV1DocumentsSearchPost', 'documentSearchRequest', documentSearchRequest)
            const localVarPath = `/api/v1/documents/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentSearchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update document metadata.  Args:     document_id: Document ID     update_data: Update data     current_user: Current authenticated user     document_service: Document service  Returns:     Updated document information
         * @summary Update Document
         * @param {string} documentId 
         * @param {DocumentUpdate} documentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentApiV1DocumentsDocumentIdPut: async (documentId: string, documentUpdate: DocumentUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'documentId' is not null or undefined
            assertParamExists('updateDocumentApiV1DocumentsDocumentIdPut', 'documentId', documentId)
            // verify required parameter 'documentUpdate' is not null or undefined
            assertParamExists('updateDocumentApiV1DocumentsDocumentIdPut', 'documentUpdate', documentUpdate)
            const localVarPath = `/api/v1/documents/{document_id}`
                .replace(`{${"document_id"}}`, encodeURIComponent(String(documentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(documentUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a document.  Args:     file: Document file to upload     title: Document title     description: Document description     tags: Document tags (JSON array string)     chunk_size: Text chunk size for processing     chunk_overlap: Text chunk overlap     is_public: Whether document is public     current_user: Current authenticated user     document_service: Document service  Returns:     Created document information
         * @summary Upload Document
         * @param {File} file 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [tags] 
         * @param {number} [chunkSize] 
         * @param {number} [chunkOverlap] 
         * @param {boolean} [isPublic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocumentApiV1DocumentsUploadPost: async (file: File, title?: string, description?: string, tags?: string, chunkSize?: number, chunkOverlap?: number, isPublic?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadDocumentApiV1DocumentsUploadPost', 'file', file)
            const localVarPath = `/api/v1/documents/upload`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (title !== undefined) { 
                localVarFormParams.append('title', title as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (tags !== undefined) { 
                localVarFormParams.append('tags', tags as any);
            }
    
            if (chunkSize !== undefined) { 
                localVarFormParams.append('chunk_size', chunkSize as any);
            }
    
            if (chunkOverlap !== undefined) { 
                localVarFormParams.append('chunk_overlap', chunkOverlap as any);
            }
    
            if (isPublic !== undefined) { 
                localVarFormParams.append('is_public', String(isPublic) as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentsApi - functional programming interface
 * @export
 */
export const DocumentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DocumentsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete document.  Args:     document_id: Document ID     request: Delete request parameters     current_user: Current authenticated user     document_service: Document service  Returns:     Success message
         * @summary Delete Document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDocumentApiV1DocumentsDocumentIdDelete(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDocumentApiV1DocumentsDocumentIdDelete(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.deleteDocumentApiV1DocumentsDocumentIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Download original document file.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     File download response
         * @summary Download Document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDocumentApiV1DocumentsDocumentIdDownloadGet(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDocumentApiV1DocumentsDocumentIdDownloadGet(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.downloadDocumentApiV1DocumentsDocumentIdDownloadGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get document details.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Document information
         * @summary Get Document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentApiV1DocumentsDocumentIdGet(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentApiV1DocumentsDocumentIdGet(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.getDocumentApiV1DocumentsDocumentIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get document chunks.  Args:     document_id: Document ID     limit: Maximum number of results     offset: Number of results to skip     current_user: Current authenticated user     document_service: Document service  Returns:     List of document chunks with pagination
         * @summary Get Document Chunks
         * @param {string} documentId 
         * @param {number} [limit] Maximum number of results
         * @param {number} [offset] Number of results to skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentChunksApiV1DocumentsDocumentIdChunksGet(documentId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentChunksResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentChunksApiV1DocumentsDocumentIdChunksGet(documentId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.getDocumentChunksApiV1DocumentsDocumentIdChunksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get document statistics.  Args:     current_user: Current authenticated user     document_service: Document service  Returns:     Document statistics
         * @summary Get Document Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDocumentStatsApiV1DocumentsStatsOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDocumentStatsApiV1DocumentsStatsOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.getDocumentStatsApiV1DocumentsStatsOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List user\'s documents.  Args:     status: Filter by document status     document_type: Filter by document type     tags: Filter by tags     owner_id: Filter by owner (admin only)     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     document_service: Document service  Returns:     List of documents with pagination info
         * @summary List Documents
         * @param {DocumentStatus | null} [status] Filter by status
         * @param {DocumentType | null} [documentType] Filter by document type
         * @param {Array<string> | null} [tags] Filter by tags
         * @param {string | null} [ownerId] Filter by owner (admin only)
         * @param {number} [limit] Maximum number of results
         * @param {number} [offset] Number of results to skip
         * @param {string} [sortBy] Sort field
         * @param {string} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDocumentsApiV1DocumentsGet(status?: DocumentStatus | null, documentType?: DocumentType | null, tags?: Array<string> | null, ownerId?: string | null, limit?: number, offset?: number, sortBy?: string, sortOrder?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listDocumentsApiV1DocumentsGet(status, documentType, tags, ownerId, limit, offset, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.listDocumentsApiV1DocumentsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger document processing.  Args:     document_id: Document ID     processing_request: Processing request     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
         * @summary Process Document
         * @param {string} documentId 
         * @param {DocumentProcessingRequest} documentProcessingRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async processDocumentApiV1DocumentsDocumentIdProcessPost(documentId: string, documentProcessingRequest: DocumentProcessingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentProcessingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.processDocumentApiV1DocumentsDocumentIdProcessPost(documentId, documentProcessingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.processDocumentApiV1DocumentsDocumentIdProcessPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Reprocess an existing document.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
         * @summary Reprocess Document
         * @param {string} documentId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reprocessDocumentApiV1DocumentsDocumentIdReprocessPost(documentId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentProcessingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reprocessDocumentApiV1DocumentsDocumentIdReprocessPost(documentId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.reprocessDocumentApiV1DocumentsDocumentIdReprocessPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search documents using vector similarity.  Args:     search_request: Search request     current_user: Current authenticated user     document_service: Document service  Returns:     Search results
         * @summary Search Documents
         * @param {DocumentSearchRequest} documentSearchRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDocumentsApiV1DocumentsSearchPost(documentSearchRequest: DocumentSearchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDocumentsApiV1DocumentsSearchPost(documentSearchRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.searchDocumentsApiV1DocumentsSearchPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update document metadata.  Args:     document_id: Document ID     update_data: Update data     current_user: Current authenticated user     document_service: Document service  Returns:     Updated document information
         * @summary Update Document
         * @param {string} documentId 
         * @param {DocumentUpdate} documentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDocumentApiV1DocumentsDocumentIdPut(documentId: string, documentUpdate: DocumentUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDocumentApiV1DocumentsDocumentIdPut(documentId, documentUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.updateDocumentApiV1DocumentsDocumentIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a document.  Args:     file: Document file to upload     title: Document title     description: Document description     tags: Document tags (JSON array string)     chunk_size: Text chunk size for processing     chunk_overlap: Text chunk overlap     is_public: Whether document is public     current_user: Current authenticated user     document_service: Document service  Returns:     Created document information
         * @summary Upload Document
         * @param {File} file 
         * @param {string} [title] 
         * @param {string} [description] 
         * @param {string} [tags] 
         * @param {number} [chunkSize] 
         * @param {number} [chunkOverlap] 
         * @param {boolean} [isPublic] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadDocumentApiV1DocumentsUploadPost(file: File, title?: string, description?: string, tags?: string, chunkSize?: number, chunkOverlap?: number, isPublic?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DocumentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadDocumentApiV1DocumentsUploadPost(file, title, description, tags, chunkSize, chunkOverlap, isPublic, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DocumentsApi.uploadDocumentApiV1DocumentsUploadPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DocumentsApi - factory interface
 * @export
 */
export const DocumentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DocumentsApiFp(configuration)
    return {
        /**
         * Delete document.  Args:     document_id: Document ID     request: Delete request parameters     current_user: Current authenticated user     document_service: Document service  Returns:     Success message
         * @summary Delete Document
         * @param {DocumentsApiDeleteDocumentApiV1DocumentsDocumentIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentApiV1DocumentsDocumentIdDelete(requestParameters: DocumentsApiDeleteDocumentApiV1DocumentsDocumentIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.deleteDocumentApiV1DocumentsDocumentIdDelete(requestParameters.documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Download original document file.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     File download response
         * @summary Download Document
         * @param {DocumentsApiDownloadDocumentApiV1DocumentsDocumentIdDownloadGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocumentApiV1DocumentsDocumentIdDownloadGet(requestParameters: DocumentsApiDownloadDocumentApiV1DocumentsDocumentIdDownloadGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.downloadDocumentApiV1DocumentsDocumentIdDownloadGet(requestParameters.documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get document details.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Document information
         * @summary Get Document
         * @param {DocumentsApiGetDocumentApiV1DocumentsDocumentIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentApiV1DocumentsDocumentIdGet(requestParameters: DocumentsApiGetDocumentApiV1DocumentsDocumentIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse> {
            return localVarFp.getDocumentApiV1DocumentsDocumentIdGet(requestParameters.documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get document chunks.  Args:     document_id: Document ID     limit: Maximum number of results     offset: Number of results to skip     current_user: Current authenticated user     document_service: Document service  Returns:     List of document chunks with pagination
         * @summary Get Document Chunks
         * @param {DocumentsApiGetDocumentChunksApiV1DocumentsDocumentIdChunksGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentChunksApiV1DocumentsDocumentIdChunksGet(requestParameters: DocumentsApiGetDocumentChunksApiV1DocumentsDocumentIdChunksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentChunksResponse> {
            return localVarFp.getDocumentChunksApiV1DocumentsDocumentIdChunksGet(requestParameters.documentId, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get document statistics.  Args:     current_user: Current authenticated user     document_service: Document service  Returns:     Document statistics
         * @summary Get Document Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentStatsApiV1DocumentsStatsOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<DocumentStatsResponse> {
            return localVarFp.getDocumentStatsApiV1DocumentsStatsOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * List user\'s documents.  Args:     status: Filter by document status     document_type: Filter by document type     tags: Filter by tags     owner_id: Filter by owner (admin only)     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     document_service: Document service  Returns:     List of documents with pagination info
         * @summary List Documents
         * @param {DocumentsApiListDocumentsApiV1DocumentsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDocumentsApiV1DocumentsGet(requestParameters: DocumentsApiListDocumentsApiV1DocumentsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<DocumentListResponse> {
            return localVarFp.listDocumentsApiV1DocumentsGet(requestParameters.status, requestParameters.documentType, requestParameters.tags, requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger document processing.  Args:     document_id: Document ID     processing_request: Processing request     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
         * @summary Process Document
         * @param {DocumentsApiProcessDocumentApiV1DocumentsDocumentIdProcessPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processDocumentApiV1DocumentsDocumentIdProcessPost(requestParameters: DocumentsApiProcessDocumentApiV1DocumentsDocumentIdProcessPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentProcessingResponse> {
            return localVarFp.processDocumentApiV1DocumentsDocumentIdProcessPost(requestParameters.documentId, requestParameters.documentProcessingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Reprocess an existing document.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
         * @summary Reprocess Document
         * @param {DocumentsApiReprocessDocumentApiV1DocumentsDocumentIdReprocessPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reprocessDocumentApiV1DocumentsDocumentIdReprocessPost(requestParameters: DocumentsApiReprocessDocumentApiV1DocumentsDocumentIdReprocessPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentProcessingResponse> {
            return localVarFp.reprocessDocumentApiV1DocumentsDocumentIdReprocessPost(requestParameters.documentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Search documents using vector similarity.  Args:     search_request: Search request     current_user: Current authenticated user     document_service: Document service  Returns:     Search results
         * @summary Search Documents
         * @param {DocumentsApiSearchDocumentsApiV1DocumentsSearchPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDocumentsApiV1DocumentsSearchPost(requestParameters: DocumentsApiSearchDocumentsApiV1DocumentsSearchPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentSearchResponse> {
            return localVarFp.searchDocumentsApiV1DocumentsSearchPost(requestParameters.documentSearchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update document metadata.  Args:     document_id: Document ID     update_data: Update data     current_user: Current authenticated user     document_service: Document service  Returns:     Updated document information
         * @summary Update Document
         * @param {DocumentsApiUpdateDocumentApiV1DocumentsDocumentIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentApiV1DocumentsDocumentIdPut(requestParameters: DocumentsApiUpdateDocumentApiV1DocumentsDocumentIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse> {
            return localVarFp.updateDocumentApiV1DocumentsDocumentIdPut(requestParameters.documentId, requestParameters.documentUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a document.  Args:     file: Document file to upload     title: Document title     description: Document description     tags: Document tags (JSON array string)     chunk_size: Text chunk size for processing     chunk_overlap: Text chunk overlap     is_public: Whether document is public     current_user: Current authenticated user     document_service: Document service  Returns:     Created document information
         * @summary Upload Document
         * @param {DocumentsApiUploadDocumentApiV1DocumentsUploadPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDocumentApiV1DocumentsUploadPost(requestParameters: DocumentsApiUploadDocumentApiV1DocumentsUploadPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse> {
            return localVarFp.uploadDocumentApiV1DocumentsUploadPost(requestParameters.file, requestParameters.title, requestParameters.description, requestParameters.tags, requestParameters.chunkSize, requestParameters.chunkOverlap, requestParameters.isPublic, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DocumentsApi - interface
 * @export
 * @interface DocumentsApi
 */
export interface DocumentsApiInterface {
    /**
     * Delete document.  Args:     document_id: Document ID     request: Delete request parameters     current_user: Current authenticated user     document_service: Document service  Returns:     Success message
     * @summary Delete Document
     * @param {DocumentsApiDeleteDocumentApiV1DocumentsDocumentIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    deleteDocumentApiV1DocumentsDocumentIdDelete(requestParameters: DocumentsApiDeleteDocumentApiV1DocumentsDocumentIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

    /**
     * Download original document file.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     File download response
     * @summary Download Document
     * @param {DocumentsApiDownloadDocumentApiV1DocumentsDocumentIdDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    downloadDocumentApiV1DocumentsDocumentIdDownloadGet(requestParameters: DocumentsApiDownloadDocumentApiV1DocumentsDocumentIdDownloadGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Get document details.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Document information
     * @summary Get Document
     * @param {DocumentsApiGetDocumentApiV1DocumentsDocumentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    getDocumentApiV1DocumentsDocumentIdGet(requestParameters: DocumentsApiGetDocumentApiV1DocumentsDocumentIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse>;

    /**
     * Get document chunks.  Args:     document_id: Document ID     limit: Maximum number of results     offset: Number of results to skip     current_user: Current authenticated user     document_service: Document service  Returns:     List of document chunks with pagination
     * @summary Get Document Chunks
     * @param {DocumentsApiGetDocumentChunksApiV1DocumentsDocumentIdChunksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    getDocumentChunksApiV1DocumentsDocumentIdChunksGet(requestParameters: DocumentsApiGetDocumentChunksApiV1DocumentsDocumentIdChunksGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentChunksResponse>;

    /**
     * Get document statistics.  Args:     current_user: Current authenticated user     document_service: Document service  Returns:     Document statistics
     * @summary Get Document Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    getDocumentStatsApiV1DocumentsStatsOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<DocumentStatsResponse>;

    /**
     * List user\'s documents.  Args:     status: Filter by document status     document_type: Filter by document type     tags: Filter by tags     owner_id: Filter by owner (admin only)     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     document_service: Document service  Returns:     List of documents with pagination info
     * @summary List Documents
     * @param {DocumentsApiListDocumentsApiV1DocumentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    listDocumentsApiV1DocumentsGet(requestParameters?: DocumentsApiListDocumentsApiV1DocumentsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentListResponse>;

    /**
     * Trigger document processing.  Args:     document_id: Document ID     processing_request: Processing request     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
     * @summary Process Document
     * @param {DocumentsApiProcessDocumentApiV1DocumentsDocumentIdProcessPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    processDocumentApiV1DocumentsDocumentIdProcessPost(requestParameters: DocumentsApiProcessDocumentApiV1DocumentsDocumentIdProcessPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentProcessingResponse>;

    /**
     * Reprocess an existing document.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
     * @summary Reprocess Document
     * @param {DocumentsApiReprocessDocumentApiV1DocumentsDocumentIdReprocessPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    reprocessDocumentApiV1DocumentsDocumentIdReprocessPost(requestParameters: DocumentsApiReprocessDocumentApiV1DocumentsDocumentIdReprocessPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentProcessingResponse>;

    /**
     * Search documents using vector similarity.  Args:     search_request: Search request     current_user: Current authenticated user     document_service: Document service  Returns:     Search results
     * @summary Search Documents
     * @param {DocumentsApiSearchDocumentsApiV1DocumentsSearchPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    searchDocumentsApiV1DocumentsSearchPost(requestParameters: DocumentsApiSearchDocumentsApiV1DocumentsSearchPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentSearchResponse>;

    /**
     * Update document metadata.  Args:     document_id: Document ID     update_data: Update data     current_user: Current authenticated user     document_service: Document service  Returns:     Updated document information
     * @summary Update Document
     * @param {DocumentsApiUpdateDocumentApiV1DocumentsDocumentIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    updateDocumentApiV1DocumentsDocumentIdPut(requestParameters: DocumentsApiUpdateDocumentApiV1DocumentsDocumentIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse>;

    /**
     * Upload a document.  Args:     file: Document file to upload     title: Document title     description: Document description     tags: Document tags (JSON array string)     chunk_size: Text chunk size for processing     chunk_overlap: Text chunk overlap     is_public: Whether document is public     current_user: Current authenticated user     document_service: Document service  Returns:     Created document information
     * @summary Upload Document
     * @param {DocumentsApiUploadDocumentApiV1DocumentsUploadPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    uploadDocumentApiV1DocumentsUploadPost(requestParameters: DocumentsApiUploadDocumentApiV1DocumentsUploadPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<DocumentResponse>;

}

/**
 * Request parameters for deleteDocumentApiV1DocumentsDocumentIdDelete operation in DocumentsApi.
 * @export
 * @interface DocumentsApiDeleteDocumentApiV1DocumentsDocumentIdDeleteRequest
 */
export interface DocumentsApiDeleteDocumentApiV1DocumentsDocumentIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDeleteDocumentApiV1DocumentsDocumentIdDelete
     */
    readonly documentId: string
}

/**
 * Request parameters for downloadDocumentApiV1DocumentsDocumentIdDownloadGet operation in DocumentsApi.
 * @export
 * @interface DocumentsApiDownloadDocumentApiV1DocumentsDocumentIdDownloadGetRequest
 */
export interface DocumentsApiDownloadDocumentApiV1DocumentsDocumentIdDownloadGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiDownloadDocumentApiV1DocumentsDocumentIdDownloadGet
     */
    readonly documentId: string
}

/**
 * Request parameters for getDocumentApiV1DocumentsDocumentIdGet operation in DocumentsApi.
 * @export
 * @interface DocumentsApiGetDocumentApiV1DocumentsDocumentIdGetRequest
 */
export interface DocumentsApiGetDocumentApiV1DocumentsDocumentIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiGetDocumentApiV1DocumentsDocumentIdGet
     */
    readonly documentId: string
}

/**
 * Request parameters for getDocumentChunksApiV1DocumentsDocumentIdChunksGet operation in DocumentsApi.
 * @export
 * @interface DocumentsApiGetDocumentChunksApiV1DocumentsDocumentIdChunksGetRequest
 */
export interface DocumentsApiGetDocumentChunksApiV1DocumentsDocumentIdChunksGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiGetDocumentChunksApiV1DocumentsDocumentIdChunksGet
     */
    readonly documentId: string

    /**
     * Maximum number of results
     * @type {number}
     * @memberof DocumentsApiGetDocumentChunksApiV1DocumentsDocumentIdChunksGet
     */
    readonly limit?: number

    /**
     * Number of results to skip
     * @type {number}
     * @memberof DocumentsApiGetDocumentChunksApiV1DocumentsDocumentIdChunksGet
     */
    readonly offset?: number
}

/**
 * Request parameters for listDocumentsApiV1DocumentsGet operation in DocumentsApi.
 * @export
 * @interface DocumentsApiListDocumentsApiV1DocumentsGetRequest
 */
export interface DocumentsApiListDocumentsApiV1DocumentsGetRequest {
    /**
     * Filter by status
     * @type {DocumentStatus}
     * @memberof DocumentsApiListDocumentsApiV1DocumentsGet
     */
    readonly status?: DocumentStatus | null

    /**
     * Filter by document type
     * @type {DocumentType}
     * @memberof DocumentsApiListDocumentsApiV1DocumentsGet
     */
    readonly documentType?: DocumentType | null

    /**
     * Filter by tags
     * @type {Array<string>}
     * @memberof DocumentsApiListDocumentsApiV1DocumentsGet
     */
    readonly tags?: Array<string> | null

    /**
     * Filter by owner (admin only)
     * @type {string}
     * @memberof DocumentsApiListDocumentsApiV1DocumentsGet
     */
    readonly ownerId?: string | null

    /**
     * Maximum number of results
     * @type {number}
     * @memberof DocumentsApiListDocumentsApiV1DocumentsGet
     */
    readonly limit?: number

    /**
     * Number of results to skip
     * @type {number}
     * @memberof DocumentsApiListDocumentsApiV1DocumentsGet
     */
    readonly offset?: number

    /**
     * Sort field
     * @type {string}
     * @memberof DocumentsApiListDocumentsApiV1DocumentsGet
     */
    readonly sortBy?: string

    /**
     * Sort order
     * @type {string}
     * @memberof DocumentsApiListDocumentsApiV1DocumentsGet
     */
    readonly sortOrder?: string
}

/**
 * Request parameters for processDocumentApiV1DocumentsDocumentIdProcessPost operation in DocumentsApi.
 * @export
 * @interface DocumentsApiProcessDocumentApiV1DocumentsDocumentIdProcessPostRequest
 */
export interface DocumentsApiProcessDocumentApiV1DocumentsDocumentIdProcessPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiProcessDocumentApiV1DocumentsDocumentIdProcessPost
     */
    readonly documentId: string

    /**
     * 
     * @type {DocumentProcessingRequest}
     * @memberof DocumentsApiProcessDocumentApiV1DocumentsDocumentIdProcessPost
     */
    readonly documentProcessingRequest: DocumentProcessingRequest
}

/**
 * Request parameters for reprocessDocumentApiV1DocumentsDocumentIdReprocessPost operation in DocumentsApi.
 * @export
 * @interface DocumentsApiReprocessDocumentApiV1DocumentsDocumentIdReprocessPostRequest
 */
export interface DocumentsApiReprocessDocumentApiV1DocumentsDocumentIdReprocessPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiReprocessDocumentApiV1DocumentsDocumentIdReprocessPost
     */
    readonly documentId: string
}

/**
 * Request parameters for searchDocumentsApiV1DocumentsSearchPost operation in DocumentsApi.
 * @export
 * @interface DocumentsApiSearchDocumentsApiV1DocumentsSearchPostRequest
 */
export interface DocumentsApiSearchDocumentsApiV1DocumentsSearchPostRequest {
    /**
     * 
     * @type {DocumentSearchRequest}
     * @memberof DocumentsApiSearchDocumentsApiV1DocumentsSearchPost
     */
    readonly documentSearchRequest: DocumentSearchRequest
}

/**
 * Request parameters for updateDocumentApiV1DocumentsDocumentIdPut operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUpdateDocumentApiV1DocumentsDocumentIdPutRequest
 */
export interface DocumentsApiUpdateDocumentApiV1DocumentsDocumentIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUpdateDocumentApiV1DocumentsDocumentIdPut
     */
    readonly documentId: string

    /**
     * 
     * @type {DocumentUpdate}
     * @memberof DocumentsApiUpdateDocumentApiV1DocumentsDocumentIdPut
     */
    readonly documentUpdate: DocumentUpdate
}

/**
 * Request parameters for uploadDocumentApiV1DocumentsUploadPost operation in DocumentsApi.
 * @export
 * @interface DocumentsApiUploadDocumentApiV1DocumentsUploadPostRequest
 */
export interface DocumentsApiUploadDocumentApiV1DocumentsUploadPostRequest {
    /**
     * 
     * @type {File}
     * @memberof DocumentsApiUploadDocumentApiV1DocumentsUploadPost
     */
    readonly file: File

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUploadDocumentApiV1DocumentsUploadPost
     */
    readonly title?: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUploadDocumentApiV1DocumentsUploadPost
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DocumentsApiUploadDocumentApiV1DocumentsUploadPost
     */
    readonly tags?: string

    /**
     * 
     * @type {number}
     * @memberof DocumentsApiUploadDocumentApiV1DocumentsUploadPost
     */
    readonly chunkSize?: number

    /**
     * 
     * @type {number}
     * @memberof DocumentsApiUploadDocumentApiV1DocumentsUploadPost
     */
    readonly chunkOverlap?: number

    /**
     * 
     * @type {boolean}
     * @memberof DocumentsApiUploadDocumentApiV1DocumentsUploadPost
     */
    readonly isPublic?: boolean
}

/**
 * DocumentsApi - object-oriented interface
 * @export
 * @class DocumentsApi
 * @extends {BaseAPI}
 */
export class DocumentsApi extends BaseAPI implements DocumentsApiInterface {
    /**
     * Delete document.  Args:     document_id: Document ID     request: Delete request parameters     current_user: Current authenticated user     document_service: Document service  Returns:     Success message
     * @summary Delete Document
     * @param {DocumentsApiDeleteDocumentApiV1DocumentsDocumentIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public deleteDocumentApiV1DocumentsDocumentIdDelete(requestParameters: DocumentsApiDeleteDocumentApiV1DocumentsDocumentIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).deleteDocumentApiV1DocumentsDocumentIdDelete(requestParameters.documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Download original document file.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     File download response
     * @summary Download Document
     * @param {DocumentsApiDownloadDocumentApiV1DocumentsDocumentIdDownloadGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public downloadDocumentApiV1DocumentsDocumentIdDownloadGet(requestParameters: DocumentsApiDownloadDocumentApiV1DocumentsDocumentIdDownloadGetRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).downloadDocumentApiV1DocumentsDocumentIdDownloadGet(requestParameters.documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get document details.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Document information
     * @summary Get Document
     * @param {DocumentsApiGetDocumentApiV1DocumentsDocumentIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public getDocumentApiV1DocumentsDocumentIdGet(requestParameters: DocumentsApiGetDocumentApiV1DocumentsDocumentIdGetRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).getDocumentApiV1DocumentsDocumentIdGet(requestParameters.documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get document chunks.  Args:     document_id: Document ID     limit: Maximum number of results     offset: Number of results to skip     current_user: Current authenticated user     document_service: Document service  Returns:     List of document chunks with pagination
     * @summary Get Document Chunks
     * @param {DocumentsApiGetDocumentChunksApiV1DocumentsDocumentIdChunksGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public getDocumentChunksApiV1DocumentsDocumentIdChunksGet(requestParameters: DocumentsApiGetDocumentChunksApiV1DocumentsDocumentIdChunksGetRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).getDocumentChunksApiV1DocumentsDocumentIdChunksGet(requestParameters.documentId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get document statistics.  Args:     current_user: Current authenticated user     document_service: Document service  Returns:     Document statistics
     * @summary Get Document Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public getDocumentStatsApiV1DocumentsStatsOverviewGet(options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).getDocumentStatsApiV1DocumentsStatsOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List user\'s documents.  Args:     status: Filter by document status     document_type: Filter by document type     tags: Filter by tags     owner_id: Filter by owner (admin only)     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     document_service: Document service  Returns:     List of documents with pagination info
     * @summary List Documents
     * @param {DocumentsApiListDocumentsApiV1DocumentsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public listDocumentsApiV1DocumentsGet(requestParameters: DocumentsApiListDocumentsApiV1DocumentsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).listDocumentsApiV1DocumentsGet(requestParameters.status, requestParameters.documentType, requestParameters.tags, requestParameters.ownerId, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger document processing.  Args:     document_id: Document ID     processing_request: Processing request     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
     * @summary Process Document
     * @param {DocumentsApiProcessDocumentApiV1DocumentsDocumentIdProcessPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public processDocumentApiV1DocumentsDocumentIdProcessPost(requestParameters: DocumentsApiProcessDocumentApiV1DocumentsDocumentIdProcessPostRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).processDocumentApiV1DocumentsDocumentIdProcessPost(requestParameters.documentId, requestParameters.documentProcessingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Reprocess an existing document.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
     * @summary Reprocess Document
     * @param {DocumentsApiReprocessDocumentApiV1DocumentsDocumentIdReprocessPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public reprocessDocumentApiV1DocumentsDocumentIdReprocessPost(requestParameters: DocumentsApiReprocessDocumentApiV1DocumentsDocumentIdReprocessPostRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).reprocessDocumentApiV1DocumentsDocumentIdReprocessPost(requestParameters.documentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search documents using vector similarity.  Args:     search_request: Search request     current_user: Current authenticated user     document_service: Document service  Returns:     Search results
     * @summary Search Documents
     * @param {DocumentsApiSearchDocumentsApiV1DocumentsSearchPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public searchDocumentsApiV1DocumentsSearchPost(requestParameters: DocumentsApiSearchDocumentsApiV1DocumentsSearchPostRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).searchDocumentsApiV1DocumentsSearchPost(requestParameters.documentSearchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update document metadata.  Args:     document_id: Document ID     update_data: Update data     current_user: Current authenticated user     document_service: Document service  Returns:     Updated document information
     * @summary Update Document
     * @param {DocumentsApiUpdateDocumentApiV1DocumentsDocumentIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public updateDocumentApiV1DocumentsDocumentIdPut(requestParameters: DocumentsApiUpdateDocumentApiV1DocumentsDocumentIdPutRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).updateDocumentApiV1DocumentsDocumentIdPut(requestParameters.documentId, requestParameters.documentUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a document.  Args:     file: Document file to upload     title: Document title     description: Document description     tags: Document tags (JSON array string)     chunk_size: Text chunk size for processing     chunk_overlap: Text chunk overlap     is_public: Whether document is public     current_user: Current authenticated user     document_service: Document service  Returns:     Created document information
     * @summary Upload Document
     * @param {DocumentsApiUploadDocumentApiV1DocumentsUploadPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApi
     */
    public uploadDocumentApiV1DocumentsUploadPost(requestParameters: DocumentsApiUploadDocumentApiV1DocumentsUploadPostRequest, options?: RawAxiosRequestConfig) {
        return DocumentsApiFp(this.configuration).uploadDocumentApiV1DocumentsUploadPost(requestParameters.file, requestParameters.title, requestParameters.description, requestParameters.tags, requestParameters.chunkSize, requestParameters.chunkOverlap, requestParameters.isPublic, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Stream all system events for admin users.  Args:     request: FastAPI request object     current_user: Current authenticated user (must be admin)  Returns:     StreamingResponse with SSE format for all events
         * @summary Admin Events Stream
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminEventsStreamApiV1EventsAdminStreamGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/events/admin/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stream real-time events via Server-Sent Events.  Args:     request: FastAPI request object     current_user: Current authenticated user  Returns:     StreamingResponse with SSE format
         * @summary Events Stream
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsStreamApiV1EventsStreamGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/events/stream`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SSE service statistics.  Args:     current_user: Current authenticated user  Returns:     SSE service statistics
         * @summary Get Sse Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSseStatsApiV1EventsStatsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/events/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger a broadcast test event for all users.  Args:     current_user: Current authenticated user  Returns:     Success message with event ID
         * @summary Trigger Broadcast Test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerBroadcastTestApiV1EventsBroadcastTestPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/events/broadcast-test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger a test event for the current user.  Args:     current_user: Current authenticated user  Returns:     Success message with event ID
         * @summary Trigger Test Event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTestEventApiV1EventsTestEventPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/events/test-event`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EventsApiAxiosParamCreator(configuration)
    return {
        /**
         * Stream all system events for admin users.  Args:     request: FastAPI request object     current_user: Current authenticated user (must be admin)  Returns:     StreamingResponse with SSE format for all events
         * @summary Admin Events Stream
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adminEventsStreamApiV1EventsAdminStreamGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adminEventsStreamApiV1EventsAdminStreamGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.adminEventsStreamApiV1EventsAdminStreamGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stream real-time events via Server-Sent Events.  Args:     request: FastAPI request object     current_user: Current authenticated user  Returns:     StreamingResponse with SSE format
         * @summary Events Stream
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsStreamApiV1EventsStreamGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsStreamApiV1EventsStreamGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.eventsStreamApiV1EventsStreamGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get SSE service statistics.  Args:     current_user: Current authenticated user  Returns:     SSE service statistics
         * @summary Get Sse Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSseStatsApiV1EventsStatsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SSEStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSseStatsApiV1EventsStatsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.getSseStatsApiV1EventsStatsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger a broadcast test event for all users.  Args:     current_user: Current authenticated user  Returns:     Success message with event ID
         * @summary Trigger Broadcast Test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerBroadcastTestApiV1EventsBroadcastTestPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerBroadcastTestApiV1EventsBroadcastTestPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.triggerBroadcastTestApiV1EventsBroadcastTestPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Trigger a test event for the current user.  Args:     current_user: Current authenticated user  Returns:     Success message with event ID
         * @summary Trigger Test Event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerTestEventApiV1EventsTestEventPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestEventResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerTestEventApiV1EventsTestEventPost(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EventsApi.triggerTestEventApiV1EventsTestEventPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EventsApiFp(configuration)
    return {
        /**
         * Stream all system events for admin users.  Args:     request: FastAPI request object     current_user: Current authenticated user (must be admin)  Returns:     StreamingResponse with SSE format for all events
         * @summary Admin Events Stream
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adminEventsStreamApiV1EventsAdminStreamGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.adminEventsStreamApiV1EventsAdminStreamGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Stream real-time events via Server-Sent Events.  Args:     request: FastAPI request object     current_user: Current authenticated user  Returns:     StreamingResponse with SSE format
         * @summary Events Stream
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsStreamApiV1EventsStreamGet(options?: RawAxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.eventsStreamApiV1EventsStreamGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get SSE service statistics.  Args:     current_user: Current authenticated user  Returns:     SSE service statistics
         * @summary Get Sse Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSseStatsApiV1EventsStatsGet(options?: RawAxiosRequestConfig): AxiosPromise<SSEStatsResponse> {
            return localVarFp.getSseStatsApiV1EventsStatsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger a broadcast test event for all users.  Args:     current_user: Current authenticated user  Returns:     Success message with event ID
         * @summary Trigger Broadcast Test
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerBroadcastTestApiV1EventsBroadcastTestPost(options?: RawAxiosRequestConfig): AxiosPromise<TestEventResponse> {
            return localVarFp.triggerBroadcastTestApiV1EventsBroadcastTestPost(options).then((request) => request(axios, basePath));
        },
        /**
         * Trigger a test event for the current user.  Args:     current_user: Current authenticated user  Returns:     Success message with event ID
         * @summary Trigger Test Event
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerTestEventApiV1EventsTestEventPost(options?: RawAxiosRequestConfig): AxiosPromise<TestEventResponse> {
            return localVarFp.triggerTestEventApiV1EventsTestEventPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - interface
 * @export
 * @interface EventsApi
 */
export interface EventsApiInterface {
    /**
     * Stream all system events for admin users.  Args:     request: FastAPI request object     current_user: Current authenticated user (must be admin)  Returns:     StreamingResponse with SSE format for all events
     * @summary Admin Events Stream
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    adminEventsStreamApiV1EventsAdminStreamGet(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Stream real-time events via Server-Sent Events.  Args:     request: FastAPI request object     current_user: Current authenticated user  Returns:     StreamingResponse with SSE format
     * @summary Events Stream
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    eventsStreamApiV1EventsStreamGet(options?: RawAxiosRequestConfig): AxiosPromise<any>;

    /**
     * Get SSE service statistics.  Args:     current_user: Current authenticated user  Returns:     SSE service statistics
     * @summary Get Sse Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    getSseStatsApiV1EventsStatsGet(options?: RawAxiosRequestConfig): AxiosPromise<SSEStatsResponse>;

    /**
     * Trigger a broadcast test event for all users.  Args:     current_user: Current authenticated user  Returns:     Success message with event ID
     * @summary Trigger Broadcast Test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    triggerBroadcastTestApiV1EventsBroadcastTestPost(options?: RawAxiosRequestConfig): AxiosPromise<TestEventResponse>;

    /**
     * Trigger a test event for the current user.  Args:     current_user: Current authenticated user  Returns:     Success message with event ID
     * @summary Trigger Test Event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApiInterface
     */
    triggerTestEventApiV1EventsTestEventPost(options?: RawAxiosRequestConfig): AxiosPromise<TestEventResponse>;

}

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI implements EventsApiInterface {
    /**
     * Stream all system events for admin users.  Args:     request: FastAPI request object     current_user: Current authenticated user (must be admin)  Returns:     StreamingResponse with SSE format for all events
     * @summary Admin Events Stream
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public adminEventsStreamApiV1EventsAdminStreamGet(options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).adminEventsStreamApiV1EventsAdminStreamGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stream real-time events via Server-Sent Events.  Args:     request: FastAPI request object     current_user: Current authenticated user  Returns:     StreamingResponse with SSE format
     * @summary Events Stream
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsStreamApiV1EventsStreamGet(options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).eventsStreamApiV1EventsStreamGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SSE service statistics.  Args:     current_user: Current authenticated user  Returns:     SSE service statistics
     * @summary Get Sse Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public getSseStatsApiV1EventsStatsGet(options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).getSseStatsApiV1EventsStatsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger a broadcast test event for all users.  Args:     current_user: Current authenticated user  Returns:     Success message with event ID
     * @summary Trigger Broadcast Test
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public triggerBroadcastTestApiV1EventsBroadcastTestPost(options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).triggerBroadcastTestApiV1EventsBroadcastTestPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger a test event for the current user.  Args:     current_user: Current authenticated user  Returns:     Success message with event ID
     * @summary Trigger Test Event
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public triggerTestEventApiV1EventsTestEventPost(options?: RawAxiosRequestConfig) {
        return EventsApiFp(this.configuration).triggerTestEventApiV1EventsTestEventPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * HealthApi - axios parameter creator
 * @export
 */
export const HealthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Basic health check endpoint.  Returns:     Health status
         * @summary Health Check Endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckEndpointHealthzGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/healthz`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Liveness check endpoint for Kubernetes (alias for /healthz).  Returns:     Health status (same as /healthz)
         * @summary Liveness Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        livenessCheckLiveGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/live`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Readiness check endpoint with database connectivity.  Args:     session: Database session  Returns:     Readiness status with detailed checks
         * @summary Readiness Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readinessCheckReadyzGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/readyz`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HealthApi - functional programming interface
 * @export
 */
export const HealthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HealthApiAxiosParamCreator(configuration)
    return {
        /**
         * Basic health check endpoint.  Returns:     Health status
         * @summary Health Check Endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthCheckEndpointHealthzGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthCheckEndpointHealthzGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.healthCheckEndpointHealthzGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Liveness check endpoint for Kubernetes (alias for /healthz).  Returns:     Health status (same as /healthz)
         * @summary Liveness Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async livenessCheckLiveGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.livenessCheckLiveGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.livenessCheckLiveGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Readiness check endpoint with database connectivity.  Args:     session: Database session  Returns:     Readiness status with detailed checks
         * @summary Readiness Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async readinessCheckReadyzGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadinessCheckResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.readinessCheckReadyzGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['HealthApi.readinessCheckReadyzGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * HealthApi - factory interface
 * @export
 */
export const HealthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HealthApiFp(configuration)
    return {
        /**
         * Basic health check endpoint.  Returns:     Health status
         * @summary Health Check Endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthCheckEndpointHealthzGet(options?: RawAxiosRequestConfig): AxiosPromise<HealthCheckResponse> {
            return localVarFp.healthCheckEndpointHealthzGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Liveness check endpoint for Kubernetes (alias for /healthz).  Returns:     Health status (same as /healthz)
         * @summary Liveness Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        livenessCheckLiveGet(options?: RawAxiosRequestConfig): AxiosPromise<HealthCheckResponse> {
            return localVarFp.livenessCheckLiveGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Readiness check endpoint with database connectivity.  Args:     session: Database session  Returns:     Readiness status with detailed checks
         * @summary Readiness Check
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        readinessCheckReadyzGet(options?: RawAxiosRequestConfig): AxiosPromise<ReadinessCheckResponse> {
            return localVarFp.readinessCheckReadyzGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HealthApi - interface
 * @export
 * @interface HealthApi
 */
export interface HealthApiInterface {
    /**
     * Basic health check endpoint.  Returns:     Health status
     * @summary Health Check Endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiInterface
     */
    healthCheckEndpointHealthzGet(options?: RawAxiosRequestConfig): AxiosPromise<HealthCheckResponse>;

    /**
     * Liveness check endpoint for Kubernetes (alias for /healthz).  Returns:     Health status (same as /healthz)
     * @summary Liveness Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiInterface
     */
    livenessCheckLiveGet(options?: RawAxiosRequestConfig): AxiosPromise<HealthCheckResponse>;

    /**
     * Readiness check endpoint with database connectivity.  Args:     session: Database session  Returns:     Readiness status with detailed checks
     * @summary Readiness Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApiInterface
     */
    readinessCheckReadyzGet(options?: RawAxiosRequestConfig): AxiosPromise<ReadinessCheckResponse>;

}

/**
 * HealthApi - object-oriented interface
 * @export
 * @class HealthApi
 * @extends {BaseAPI}
 */
export class HealthApi extends BaseAPI implements HealthApiInterface {
    /**
     * Basic health check endpoint.  Returns:     Health status
     * @summary Health Check Endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public healthCheckEndpointHealthzGet(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).healthCheckEndpointHealthzGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Liveness check endpoint for Kubernetes (alias for /healthz).  Returns:     Health status (same as /healthz)
     * @summary Liveness Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public livenessCheckLiveGet(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).livenessCheckLiveGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Readiness check endpoint with database connectivity.  Args:     session: Database session  Returns:     Readiness status with detailed checks
     * @summary Readiness Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HealthApi
     */
    public readinessCheckReadyzGet(options?: RawAxiosRequestConfig) {
        return HealthApiFp(this.configuration).readinessCheckReadyzGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * JobsApi - axios parameter creator
 * @export
 */
export const JobsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel a job.  Args:     job_id: Job ID     current_user: Current authenticated user  Returns:     Cancellation result
         * @summary Cancel Job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJobApiV1JobsJobIdCancelPost: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('cancelJobApiV1JobsJobIdCancelPost', 'jobId', jobId)
            const localVarPath = `/api/v1/jobs/{job_id}/cancel`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new job.  Args:     job_data: Job creation data     current_user: Current authenticated user  Returns:     Created job data
         * @summary Create Job
         * @param {JobCreateRequest} jobCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobApiV1JobsPost: async (jobCreateRequest: JobCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobCreateRequest' is not null or undefined
            assertParamExists('createJobApiV1JobsPost', 'jobCreateRequest', jobCreateRequest)
            const localVarPath = `/api/v1/jobs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get job by ID.  Args:     job_id: Job ID     current_user: Current authenticated user  Returns:     Job data
         * @summary Get Job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobApiV1JobsJobIdGet: async (jobId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobApiV1JobsJobIdGet', 'jobId', jobId)
            const localVarPath = `/api/v1/jobs/{job_id}`
                .replace(`{${"job_id"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get job queue statistics.  Args:     current_user: Current authenticated user  Returns:     Job statistics
         * @summary Get Job Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatsApiV1JobsStatsOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/jobs/stats/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List jobs with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user  Returns:     List of jobs
         * @summary List Jobs
         * @param {JobStatus | null} [status] 
         * @param {JobPriority | null} [priority] 
         * @param {string | null} [functionName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobsApiV1JobsGet: async (status?: JobStatus | null, priority?: JobPriority | null, functionName?: string | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/jobs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }

            if (functionName !== undefined) {
                localVarQueryParameter['function_name'] = functionName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobsApi - functional programming interface
 * @export
 */
export const JobsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobsApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel a job.  Args:     job_id: Job ID     current_user: Current authenticated user  Returns:     Cancellation result
         * @summary Cancel Job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelJobApiV1JobsJobIdCancelPost(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobActionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelJobApiV1JobsJobIdCancelPost(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.cancelJobApiV1JobsJobIdCancelPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new job.  Args:     job_data: Job creation data     current_user: Current authenticated user  Returns:     Created job data
         * @summary Create Job
         * @param {JobCreateRequest} jobCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createJobApiV1JobsPost(jobCreateRequest: JobCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createJobApiV1JobsPost(jobCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.createJobApiV1JobsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get job by ID.  Args:     job_id: Job ID     current_user: Current authenticated user  Returns:     Job data
         * @summary Get Job
         * @param {string} jobId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobApiV1JobsJobIdGet(jobId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobApiV1JobsJobIdGet(jobId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.getJobApiV1JobsJobIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get job queue statistics.  Args:     current_user: Current authenticated user  Returns:     Job statistics
         * @summary Get Job Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobStatsApiV1JobsStatsOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobStatsApiV1JobsStatsOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.getJobStatsApiV1JobsStatsOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List jobs with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user  Returns:     List of jobs
         * @summary List Jobs
         * @param {JobStatus | null} [status] 
         * @param {JobPriority | null} [priority] 
         * @param {string | null} [functionName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listJobsApiV1JobsGet(status?: JobStatus | null, priority?: JobPriority | null, functionName?: string | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listJobsApiV1JobsGet(status, priority, functionName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['JobsApi.listJobsApiV1JobsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * JobsApi - factory interface
 * @export
 */
export const JobsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobsApiFp(configuration)
    return {
        /**
         * Cancel a job.  Args:     job_id: Job ID     current_user: Current authenticated user  Returns:     Cancellation result
         * @summary Cancel Job
         * @param {JobsApiCancelJobApiV1JobsJobIdCancelPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJobApiV1JobsJobIdCancelPost(requestParameters: JobsApiCancelJobApiV1JobsJobIdCancelPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobActionResponse> {
            return localVarFp.cancelJobApiV1JobsJobIdCancelPost(requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new job.  Args:     job_data: Job creation data     current_user: Current authenticated user  Returns:     Created job data
         * @summary Create Job
         * @param {JobsApiCreateJobApiV1JobsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createJobApiV1JobsPost(requestParameters: JobsApiCreateJobApiV1JobsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.createJobApiV1JobsPost(requestParameters.jobCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get job by ID.  Args:     job_id: Job ID     current_user: Current authenticated user  Returns:     Job data
         * @summary Get Job
         * @param {JobsApiGetJobApiV1JobsJobIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobApiV1JobsJobIdGet(requestParameters: JobsApiGetJobApiV1JobsJobIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse> {
            return localVarFp.getJobApiV1JobsJobIdGet(requestParameters.jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get job queue statistics.  Args:     current_user: Current authenticated user  Returns:     Job statistics
         * @summary Get Job Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobStatsApiV1JobsStatsOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<JobStatsResponse> {
            return localVarFp.getJobStatsApiV1JobsStatsOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * List jobs with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user  Returns:     List of jobs
         * @summary List Jobs
         * @param {JobsApiListJobsApiV1JobsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listJobsApiV1JobsGet(requestParameters: JobsApiListJobsApiV1JobsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<JobListResponse> {
            return localVarFp.listJobsApiV1JobsGet(requestParameters.status, requestParameters.priority, requestParameters.functionName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobsApi - interface
 * @export
 * @interface JobsApi
 */
export interface JobsApiInterface {
    /**
     * Cancel a job.  Args:     job_id: Job ID     current_user: Current authenticated user  Returns:     Cancellation result
     * @summary Cancel Job
     * @param {JobsApiCancelJobApiV1JobsJobIdCancelPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApiInterface
     */
    cancelJobApiV1JobsJobIdCancelPost(requestParameters: JobsApiCancelJobApiV1JobsJobIdCancelPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobActionResponse>;

    /**
     * Create a new job.  Args:     job_data: Job creation data     current_user: Current authenticated user  Returns:     Created job data
     * @summary Create Job
     * @param {JobsApiCreateJobApiV1JobsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApiInterface
     */
    createJobApiV1JobsPost(requestParameters: JobsApiCreateJobApiV1JobsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse>;

    /**
     * Get job by ID.  Args:     job_id: Job ID     current_user: Current authenticated user  Returns:     Job data
     * @summary Get Job
     * @param {JobsApiGetJobApiV1JobsJobIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApiInterface
     */
    getJobApiV1JobsJobIdGet(requestParameters: JobsApiGetJobApiV1JobsJobIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobResponse>;

    /**
     * Get job queue statistics.  Args:     current_user: Current authenticated user  Returns:     Job statistics
     * @summary Get Job Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApiInterface
     */
    getJobStatsApiV1JobsStatsOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<JobStatsResponse>;

    /**
     * List jobs with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user  Returns:     List of jobs
     * @summary List Jobs
     * @param {JobsApiListJobsApiV1JobsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApiInterface
     */
    listJobsApiV1JobsGet(requestParameters?: JobsApiListJobsApiV1JobsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<JobListResponse>;

}

/**
 * Request parameters for cancelJobApiV1JobsJobIdCancelPost operation in JobsApi.
 * @export
 * @interface JobsApiCancelJobApiV1JobsJobIdCancelPostRequest
 */
export interface JobsApiCancelJobApiV1JobsJobIdCancelPostRequest {
    /**
     * 
     * @type {string}
     * @memberof JobsApiCancelJobApiV1JobsJobIdCancelPost
     */
    readonly jobId: string
}

/**
 * Request parameters for createJobApiV1JobsPost operation in JobsApi.
 * @export
 * @interface JobsApiCreateJobApiV1JobsPostRequest
 */
export interface JobsApiCreateJobApiV1JobsPostRequest {
    /**
     * 
     * @type {JobCreateRequest}
     * @memberof JobsApiCreateJobApiV1JobsPost
     */
    readonly jobCreateRequest: JobCreateRequest
}

/**
 * Request parameters for getJobApiV1JobsJobIdGet operation in JobsApi.
 * @export
 * @interface JobsApiGetJobApiV1JobsJobIdGetRequest
 */
export interface JobsApiGetJobApiV1JobsJobIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof JobsApiGetJobApiV1JobsJobIdGet
     */
    readonly jobId: string
}

/**
 * Request parameters for listJobsApiV1JobsGet operation in JobsApi.
 * @export
 * @interface JobsApiListJobsApiV1JobsGetRequest
 */
export interface JobsApiListJobsApiV1JobsGetRequest {
    /**
     * 
     * @type {JobStatus}
     * @memberof JobsApiListJobsApiV1JobsGet
     */
    readonly status?: JobStatus | null

    /**
     * 
     * @type {JobPriority}
     * @memberof JobsApiListJobsApiV1JobsGet
     */
    readonly priority?: JobPriority | null

    /**
     * 
     * @type {string}
     * @memberof JobsApiListJobsApiV1JobsGet
     */
    readonly functionName?: string | null
}

/**
 * JobsApi - object-oriented interface
 * @export
 * @class JobsApi
 * @extends {BaseAPI}
 */
export class JobsApi extends BaseAPI implements JobsApiInterface {
    /**
     * Cancel a job.  Args:     job_id: Job ID     current_user: Current authenticated user  Returns:     Cancellation result
     * @summary Cancel Job
     * @param {JobsApiCancelJobApiV1JobsJobIdCancelPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public cancelJobApiV1JobsJobIdCancelPost(requestParameters: JobsApiCancelJobApiV1JobsJobIdCancelPostRequest, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).cancelJobApiV1JobsJobIdCancelPost(requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new job.  Args:     job_data: Job creation data     current_user: Current authenticated user  Returns:     Created job data
     * @summary Create Job
     * @param {JobsApiCreateJobApiV1JobsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public createJobApiV1JobsPost(requestParameters: JobsApiCreateJobApiV1JobsPostRequest, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).createJobApiV1JobsPost(requestParameters.jobCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get job by ID.  Args:     job_id: Job ID     current_user: Current authenticated user  Returns:     Job data
     * @summary Get Job
     * @param {JobsApiGetJobApiV1JobsJobIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobApiV1JobsJobIdGet(requestParameters: JobsApiGetJobApiV1JobsJobIdGetRequest, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).getJobApiV1JobsJobIdGet(requestParameters.jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get job queue statistics.  Args:     current_user: Current authenticated user  Returns:     Job statistics
     * @summary Get Job Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public getJobStatsApiV1JobsStatsOverviewGet(options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).getJobStatsApiV1JobsStatsOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List jobs with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user  Returns:     List of jobs
     * @summary List Jobs
     * @param {JobsApiListJobsApiV1JobsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobsApi
     */
    public listJobsApiV1JobsGet(requestParameters: JobsApiListJobsApiV1JobsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return JobsApiFp(this.configuration).listJobsApiV1JobsGet(requestParameters.status, requestParameters.priority, requestParameters.functionName, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PluginsApi - axios parameter creator
 * @export
 */
export const PluginsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Disable a plugin.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Action result
         * @summary Disable Plugin
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disablePluginApiV1PluginsPluginIdDisablePost: async (pluginId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginId' is not null or undefined
            assertParamExists('disablePluginApiV1PluginsPluginIdDisablePost', 'pluginId', pluginId)
            const localVarPath = `/api/v1/plugins/{plugin_id}/disable`
                .replace(`{${"plugin_id"}}`, encodeURIComponent(String(pluginId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable a plugin.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Action result
         * @summary Enable Plugin
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enablePluginApiV1PluginsPluginIdEnablePost: async (pluginId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginId' is not null or undefined
            assertParamExists('enablePluginApiV1PluginsPluginIdEnablePost', 'pluginId', pluginId)
            const localVarPath = `/api/v1/plugins/{plugin_id}/enable`
                .replace(`{${"plugin_id"}}`, encodeURIComponent(String(pluginId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get plugin by ID.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Plugin data
         * @summary Get Plugin
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginApiV1PluginsPluginIdGet: async (pluginId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginId' is not null or undefined
            assertParamExists('getPluginApiV1PluginsPluginIdGet', 'pluginId', pluginId)
            const localVarPath = `/api/v1/plugins/{plugin_id}`
                .replace(`{${"plugin_id"}}`, encodeURIComponent(String(pluginId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Install a new plugin.  Args:     install_data: Plugin installation data     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Installed plugin data
         * @summary Install Plugin
         * @param {PluginInstallRequest} pluginInstallRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installPluginApiV1PluginsInstallPost: async (pluginInstallRequest: PluginInstallRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginInstallRequest' is not null or undefined
            assertParamExists('installPluginApiV1PluginsInstallPost', 'pluginInstallRequest', pluginInstallRequest)
            const localVarPath = `/api/v1/plugins/install`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pluginInstallRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List installed plugins with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     List of installed plugins
         * @summary List Plugins
         * @param {PluginType | null} [pluginType] 
         * @param {PluginStatus | null} [status] 
         * @param {boolean | null} [enabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPluginsApiV1PluginsGet: async (pluginType?: PluginType | null, status?: PluginStatus | null, enabled?: boolean | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/plugins/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (pluginType !== undefined) {
                localVarQueryParameter['plugin_type'] = pluginType;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Uninstall a plugin.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Uninstall result
         * @summary Uninstall Plugin
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallPluginApiV1PluginsPluginIdDelete: async (pluginId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginId' is not null or undefined
            assertParamExists('uninstallPluginApiV1PluginsPluginIdDelete', 'pluginId', pluginId)
            const localVarPath = `/api/v1/plugins/{plugin_id}`
                .replace(`{${"plugin_id"}}`, encodeURIComponent(String(pluginId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a plugin.  Args:     plugin_id: Plugin ID     update_data: Plugin update data     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Updated plugin data
         * @summary Update Plugin
         * @param {string} pluginId 
         * @param {PluginUpdateRequest} pluginUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginApiV1PluginsPluginIdPut: async (pluginId: string, pluginUpdateRequest: PluginUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pluginId' is not null or undefined
            assertParamExists('updatePluginApiV1PluginsPluginIdPut', 'pluginId', pluginId)
            // verify required parameter 'pluginUpdateRequest' is not null or undefined
            assertParamExists('updatePluginApiV1PluginsPluginIdPut', 'pluginUpdateRequest', pluginUpdateRequest)
            const localVarPath = `/api/v1/plugins/{plugin_id}`
                .replace(`{${"plugin_id"}}`, encodeURIComponent(String(pluginId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pluginUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PluginsApi - functional programming interface
 * @export
 */
export const PluginsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PluginsApiAxiosParamCreator(configuration)
    return {
        /**
         * Disable a plugin.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Action result
         * @summary Disable Plugin
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disablePluginApiV1PluginsPluginIdDisablePost(pluginId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginActionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disablePluginApiV1PluginsPluginIdDisablePost(pluginId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginsApi.disablePluginApiV1PluginsPluginIdDisablePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable a plugin.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Action result
         * @summary Enable Plugin
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enablePluginApiV1PluginsPluginIdEnablePost(pluginId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginActionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enablePluginApiV1PluginsPluginIdEnablePost(pluginId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginsApi.enablePluginApiV1PluginsPluginIdEnablePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get plugin by ID.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Plugin data
         * @summary Get Plugin
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPluginApiV1PluginsPluginIdGet(pluginId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPluginApiV1PluginsPluginIdGet(pluginId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginsApi.getPluginApiV1PluginsPluginIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Install a new plugin.  Args:     install_data: Plugin installation data     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Installed plugin data
         * @summary Install Plugin
         * @param {PluginInstallRequest} pluginInstallRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async installPluginApiV1PluginsInstallPost(pluginInstallRequest: PluginInstallRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.installPluginApiV1PluginsInstallPost(pluginInstallRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginsApi.installPluginApiV1PluginsInstallPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List installed plugins with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     List of installed plugins
         * @summary List Plugins
         * @param {PluginType | null} [pluginType] 
         * @param {PluginStatus | null} [status] 
         * @param {boolean | null} [enabled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPluginsApiV1PluginsGet(pluginType?: PluginType | null, status?: PluginStatus | null, enabled?: boolean | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPluginsApiV1PluginsGet(pluginType, status, enabled, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginsApi.listPluginsApiV1PluginsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Uninstall a plugin.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Uninstall result
         * @summary Uninstall Plugin
         * @param {string} pluginId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uninstallPluginApiV1PluginsPluginIdDelete(pluginId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uninstallPluginApiV1PluginsPluginIdDelete(pluginId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginsApi.uninstallPluginApiV1PluginsPluginIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a plugin.  Args:     plugin_id: Plugin ID     update_data: Plugin update data     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Updated plugin data
         * @summary Update Plugin
         * @param {string} pluginId 
         * @param {PluginUpdateRequest} pluginUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePluginApiV1PluginsPluginIdPut(pluginId: string, pluginUpdateRequest: PluginUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PluginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePluginApiV1PluginsPluginIdPut(pluginId, pluginUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PluginsApi.updatePluginApiV1PluginsPluginIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PluginsApi - factory interface
 * @export
 */
export const PluginsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PluginsApiFp(configuration)
    return {
        /**
         * Disable a plugin.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Action result
         * @summary Disable Plugin
         * @param {PluginsApiDisablePluginApiV1PluginsPluginIdDisablePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disablePluginApiV1PluginsPluginIdDisablePost(requestParameters: PluginsApiDisablePluginApiV1PluginsPluginIdDisablePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PluginActionResponse> {
            return localVarFp.disablePluginApiV1PluginsPluginIdDisablePost(requestParameters.pluginId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable a plugin.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Action result
         * @summary Enable Plugin
         * @param {PluginsApiEnablePluginApiV1PluginsPluginIdEnablePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enablePluginApiV1PluginsPluginIdEnablePost(requestParameters: PluginsApiEnablePluginApiV1PluginsPluginIdEnablePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PluginActionResponse> {
            return localVarFp.enablePluginApiV1PluginsPluginIdEnablePost(requestParameters.pluginId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get plugin by ID.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Plugin data
         * @summary Get Plugin
         * @param {PluginsApiGetPluginApiV1PluginsPluginIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginApiV1PluginsPluginIdGet(requestParameters: PluginsApiGetPluginApiV1PluginsPluginIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PluginResponse> {
            return localVarFp.getPluginApiV1PluginsPluginIdGet(requestParameters.pluginId, options).then((request) => request(axios, basePath));
        },
        /**
         * Install a new plugin.  Args:     install_data: Plugin installation data     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Installed plugin data
         * @summary Install Plugin
         * @param {PluginsApiInstallPluginApiV1PluginsInstallPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        installPluginApiV1PluginsInstallPost(requestParameters: PluginsApiInstallPluginApiV1PluginsInstallPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PluginResponse> {
            return localVarFp.installPluginApiV1PluginsInstallPost(requestParameters.pluginInstallRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List installed plugins with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     List of installed plugins
         * @summary List Plugins
         * @param {PluginsApiListPluginsApiV1PluginsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPluginsApiV1PluginsGet(requestParameters: PluginsApiListPluginsApiV1PluginsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PluginListResponse> {
            return localVarFp.listPluginsApiV1PluginsGet(requestParameters.pluginType, requestParameters.status, requestParameters.enabled, options).then((request) => request(axios, basePath));
        },
        /**
         * Uninstall a plugin.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Uninstall result
         * @summary Uninstall Plugin
         * @param {PluginsApiUninstallPluginApiV1PluginsPluginIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uninstallPluginApiV1PluginsPluginIdDelete(requestParameters: PluginsApiUninstallPluginApiV1PluginsPluginIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<PluginDeleteResponse> {
            return localVarFp.uninstallPluginApiV1PluginsPluginIdDelete(requestParameters.pluginId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a plugin.  Args:     plugin_id: Plugin ID     update_data: Plugin update data     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Updated plugin data
         * @summary Update Plugin
         * @param {PluginsApiUpdatePluginApiV1PluginsPluginIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePluginApiV1PluginsPluginIdPut(requestParameters: PluginsApiUpdatePluginApiV1PluginsPluginIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<PluginResponse> {
            return localVarFp.updatePluginApiV1PluginsPluginIdPut(requestParameters.pluginId, requestParameters.pluginUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PluginsApi - interface
 * @export
 * @interface PluginsApi
 */
export interface PluginsApiInterface {
    /**
     * Disable a plugin.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Action result
     * @summary Disable Plugin
     * @param {PluginsApiDisablePluginApiV1PluginsPluginIdDisablePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApiInterface
     */
    disablePluginApiV1PluginsPluginIdDisablePost(requestParameters: PluginsApiDisablePluginApiV1PluginsPluginIdDisablePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PluginActionResponse>;

    /**
     * Enable a plugin.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Action result
     * @summary Enable Plugin
     * @param {PluginsApiEnablePluginApiV1PluginsPluginIdEnablePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApiInterface
     */
    enablePluginApiV1PluginsPluginIdEnablePost(requestParameters: PluginsApiEnablePluginApiV1PluginsPluginIdEnablePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PluginActionResponse>;

    /**
     * Get plugin by ID.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Plugin data
     * @summary Get Plugin
     * @param {PluginsApiGetPluginApiV1PluginsPluginIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApiInterface
     */
    getPluginApiV1PluginsPluginIdGet(requestParameters: PluginsApiGetPluginApiV1PluginsPluginIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PluginResponse>;

    /**
     * Install a new plugin.  Args:     install_data: Plugin installation data     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Installed plugin data
     * @summary Install Plugin
     * @param {PluginsApiInstallPluginApiV1PluginsInstallPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApiInterface
     */
    installPluginApiV1PluginsInstallPost(requestParameters: PluginsApiInstallPluginApiV1PluginsInstallPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PluginResponse>;

    /**
     * List installed plugins with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     List of installed plugins
     * @summary List Plugins
     * @param {PluginsApiListPluginsApiV1PluginsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApiInterface
     */
    listPluginsApiV1PluginsGet(requestParameters?: PluginsApiListPluginsApiV1PluginsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PluginListResponse>;

    /**
     * Uninstall a plugin.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Uninstall result
     * @summary Uninstall Plugin
     * @param {PluginsApiUninstallPluginApiV1PluginsPluginIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApiInterface
     */
    uninstallPluginApiV1PluginsPluginIdDelete(requestParameters: PluginsApiUninstallPluginApiV1PluginsPluginIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<PluginDeleteResponse>;

    /**
     * Update a plugin.  Args:     plugin_id: Plugin ID     update_data: Plugin update data     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Updated plugin data
     * @summary Update Plugin
     * @param {PluginsApiUpdatePluginApiV1PluginsPluginIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApiInterface
     */
    updatePluginApiV1PluginsPluginIdPut(requestParameters: PluginsApiUpdatePluginApiV1PluginsPluginIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<PluginResponse>;

}

/**
 * Request parameters for disablePluginApiV1PluginsPluginIdDisablePost operation in PluginsApi.
 * @export
 * @interface PluginsApiDisablePluginApiV1PluginsPluginIdDisablePostRequest
 */
export interface PluginsApiDisablePluginApiV1PluginsPluginIdDisablePostRequest {
    /**
     * 
     * @type {string}
     * @memberof PluginsApiDisablePluginApiV1PluginsPluginIdDisablePost
     */
    readonly pluginId: string
}

/**
 * Request parameters for enablePluginApiV1PluginsPluginIdEnablePost operation in PluginsApi.
 * @export
 * @interface PluginsApiEnablePluginApiV1PluginsPluginIdEnablePostRequest
 */
export interface PluginsApiEnablePluginApiV1PluginsPluginIdEnablePostRequest {
    /**
     * 
     * @type {string}
     * @memberof PluginsApiEnablePluginApiV1PluginsPluginIdEnablePost
     */
    readonly pluginId: string
}

/**
 * Request parameters for getPluginApiV1PluginsPluginIdGet operation in PluginsApi.
 * @export
 * @interface PluginsApiGetPluginApiV1PluginsPluginIdGetRequest
 */
export interface PluginsApiGetPluginApiV1PluginsPluginIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PluginsApiGetPluginApiV1PluginsPluginIdGet
     */
    readonly pluginId: string
}

/**
 * Request parameters for installPluginApiV1PluginsInstallPost operation in PluginsApi.
 * @export
 * @interface PluginsApiInstallPluginApiV1PluginsInstallPostRequest
 */
export interface PluginsApiInstallPluginApiV1PluginsInstallPostRequest {
    /**
     * 
     * @type {PluginInstallRequest}
     * @memberof PluginsApiInstallPluginApiV1PluginsInstallPost
     */
    readonly pluginInstallRequest: PluginInstallRequest
}

/**
 * Request parameters for listPluginsApiV1PluginsGet operation in PluginsApi.
 * @export
 * @interface PluginsApiListPluginsApiV1PluginsGetRequest
 */
export interface PluginsApiListPluginsApiV1PluginsGetRequest {
    /**
     * 
     * @type {PluginType}
     * @memberof PluginsApiListPluginsApiV1PluginsGet
     */
    readonly pluginType?: PluginType | null

    /**
     * 
     * @type {PluginStatus}
     * @memberof PluginsApiListPluginsApiV1PluginsGet
     */
    readonly status?: PluginStatus | null

    /**
     * 
     * @type {boolean}
     * @memberof PluginsApiListPluginsApiV1PluginsGet
     */
    readonly enabled?: boolean | null
}

/**
 * Request parameters for uninstallPluginApiV1PluginsPluginIdDelete operation in PluginsApi.
 * @export
 * @interface PluginsApiUninstallPluginApiV1PluginsPluginIdDeleteRequest
 */
export interface PluginsApiUninstallPluginApiV1PluginsPluginIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof PluginsApiUninstallPluginApiV1PluginsPluginIdDelete
     */
    readonly pluginId: string
}

/**
 * Request parameters for updatePluginApiV1PluginsPluginIdPut operation in PluginsApi.
 * @export
 * @interface PluginsApiUpdatePluginApiV1PluginsPluginIdPutRequest
 */
export interface PluginsApiUpdatePluginApiV1PluginsPluginIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof PluginsApiUpdatePluginApiV1PluginsPluginIdPut
     */
    readonly pluginId: string

    /**
     * 
     * @type {PluginUpdateRequest}
     * @memberof PluginsApiUpdatePluginApiV1PluginsPluginIdPut
     */
    readonly pluginUpdateRequest: PluginUpdateRequest
}

/**
 * PluginsApi - object-oriented interface
 * @export
 * @class PluginsApi
 * @extends {BaseAPI}
 */
export class PluginsApi extends BaseAPI implements PluginsApiInterface {
    /**
     * Disable a plugin.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Action result
     * @summary Disable Plugin
     * @param {PluginsApiDisablePluginApiV1PluginsPluginIdDisablePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public disablePluginApiV1PluginsPluginIdDisablePost(requestParameters: PluginsApiDisablePluginApiV1PluginsPluginIdDisablePostRequest, options?: RawAxiosRequestConfig) {
        return PluginsApiFp(this.configuration).disablePluginApiV1PluginsPluginIdDisablePost(requestParameters.pluginId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable a plugin.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Action result
     * @summary Enable Plugin
     * @param {PluginsApiEnablePluginApiV1PluginsPluginIdEnablePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public enablePluginApiV1PluginsPluginIdEnablePost(requestParameters: PluginsApiEnablePluginApiV1PluginsPluginIdEnablePostRequest, options?: RawAxiosRequestConfig) {
        return PluginsApiFp(this.configuration).enablePluginApiV1PluginsPluginIdEnablePost(requestParameters.pluginId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get plugin by ID.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Plugin data
     * @summary Get Plugin
     * @param {PluginsApiGetPluginApiV1PluginsPluginIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public getPluginApiV1PluginsPluginIdGet(requestParameters: PluginsApiGetPluginApiV1PluginsPluginIdGetRequest, options?: RawAxiosRequestConfig) {
        return PluginsApiFp(this.configuration).getPluginApiV1PluginsPluginIdGet(requestParameters.pluginId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Install a new plugin.  Args:     install_data: Plugin installation data     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Installed plugin data
     * @summary Install Plugin
     * @param {PluginsApiInstallPluginApiV1PluginsInstallPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public installPluginApiV1PluginsInstallPost(requestParameters: PluginsApiInstallPluginApiV1PluginsInstallPostRequest, options?: RawAxiosRequestConfig) {
        return PluginsApiFp(this.configuration).installPluginApiV1PluginsInstallPost(requestParameters.pluginInstallRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List installed plugins with optional filtering.  Args:     request: List request parameters     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     List of installed plugins
     * @summary List Plugins
     * @param {PluginsApiListPluginsApiV1PluginsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public listPluginsApiV1PluginsGet(requestParameters: PluginsApiListPluginsApiV1PluginsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return PluginsApiFp(this.configuration).listPluginsApiV1PluginsGet(requestParameters.pluginType, requestParameters.status, requestParameters.enabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Uninstall a plugin.  Args:     plugin_id: Plugin ID     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Uninstall result
     * @summary Uninstall Plugin
     * @param {PluginsApiUninstallPluginApiV1PluginsPluginIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public uninstallPluginApiV1PluginsPluginIdDelete(requestParameters: PluginsApiUninstallPluginApiV1PluginsPluginIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return PluginsApiFp(this.configuration).uninstallPluginApiV1PluginsPluginIdDelete(requestParameters.pluginId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a plugin.  Args:     plugin_id: Plugin ID     update_data: Plugin update data     current_user: Current authenticated user     plugin_manager: Plugin manager instance  Returns:     Updated plugin data
     * @summary Update Plugin
     * @param {PluginsApiUpdatePluginApiV1PluginsPluginIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginsApi
     */
    public updatePluginApiV1PluginsPluginIdPut(requestParameters: PluginsApiUpdatePluginApiV1PluginsPluginIdPutRequest, options?: RawAxiosRequestConfig) {
        return PluginsApiFp(this.configuration).updatePluginApiV1PluginsPluginIdPut(requestParameters.pluginId, requestParameters.pluginUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProfilesApi - axios parameter creator
 * @export
 */
export const ProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Clone an existing profile.  Args:     profile_id: Source profile ID     clone_request: Clone request     current_user: Current authenticated user     profile_service: Profile service  Returns:     Cloned profile information
         * @summary Clone Profile
         * @param {string} profileId 
         * @param {ProfileCloneRequest} profileCloneRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneProfileApiV1ProfilesProfileIdClonePost: async (profileId: string, profileCloneRequest: ProfileCloneRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('cloneProfileApiV1ProfilesProfileIdClonePost', 'profileId', profileId)
            // verify required parameter 'profileCloneRequest' is not null or undefined
            assertParamExists('cloneProfileApiV1ProfilesProfileIdClonePost', 'profileCloneRequest', profileCloneRequest)
            const localVarPath = `/api/v1/profiles/{profile_id}/clone`
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileCloneRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new LLM profile.  Args:     profile_data: Profile creation data     current_user: Current authenticated user     profile_service: Profile service  Returns:     Created profile information
         * @summary Create Profile
         * @param {ProfileCreate} profileCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileApiV1ProfilesPost: async (profileCreate: ProfileCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileCreate' is not null or undefined
            assertParamExists('createProfileApiV1ProfilesPost', 'profileCreate', profileCreate)
            const localVarPath = `/api/v1/profiles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete profile.  Args:     profile_id: Profile ID     request: Delete request parameters     current_user: Current authenticated user     profile_service: Profile service  Returns:     Success message
         * @summary Delete Profile
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfileApiV1ProfilesProfileIdDelete: async (profileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('deleteProfileApiV1ProfilesProfileIdDelete', 'profileId', profileId)
            const localVarPath = `/api/v1/profiles/{profile_id}`
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get available LLM providers.  Args:     request: Providers request parameters     current_user: Current authenticated user     profile_service: Profile service  Returns:     Available providers information
         * @summary Get Available Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableProvidersApiV1ProfilesProvidersAvailableGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/profiles/providers/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get profile details.  Args:     profile_id: Profile ID     current_user: Current authenticated user     profile_service: Profile service  Returns:     Profile information
         * @summary Get Profile
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileApiV1ProfilesProfileIdGet: async (profileId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('getProfileApiV1ProfilesProfileIdGet', 'profileId', profileId)
            const localVarPath = `/api/v1/profiles/{profile_id}`
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get profile statistics.  Args:     current_user: Current authenticated user     profile_service: Profile service  Returns:     Profile statistics
         * @summary Get Profile Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileStatsApiV1ProfilesStatsOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/profiles/stats/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List user\'s profiles.  Args:     profile_type: Filter by profile type     llm_provider: Filter by LLM provider     tags: Filter by tags     is_public: Filter by public status     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     profile_service: Profile service  Returns:     List of profiles with pagination info
         * @summary List Profiles
         * @param {ProfileType | null} [profileType] Filter by profile type
         * @param {string | null} [llmProvider] Filter by LLM provider
         * @param {Array<string> | null} [tags] Filter by tags
         * @param {boolean | null} [isPublic] Filter by public status
         * @param {number} [limit] Maximum number of results
         * @param {number} [offset] Number of results to skip
         * @param {string} [sortBy] Sort field
         * @param {string} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProfilesApiV1ProfilesGet: async (profileType?: ProfileType | null, llmProvider?: string | null, tags?: Array<string> | null, isPublic?: boolean | null, limit?: number, offset?: number, sortBy?: string, sortOrder?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (profileType !== undefined) {
                localVarQueryParameter['profile_type'] = profileType;
            }

            if (llmProvider !== undefined) {
                localVarQueryParameter['llm_provider'] = llmProvider;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (isPublic !== undefined) {
                localVarQueryParameter['is_public'] = isPublic;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test profile with a sample message.  Args:     profile_id: Profile ID     test_request: Test request     current_user: Current authenticated user     profile_service: Profile service  Returns:     Test results
         * @summary Test Profile
         * @param {string} profileId 
         * @param {ProfileTestRequest} profileTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testProfileApiV1ProfilesProfileIdTestPost: async (profileId: string, profileTestRequest: ProfileTestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('testProfileApiV1ProfilesProfileIdTestPost', 'profileId', profileId)
            // verify required parameter 'profileTestRequest' is not null or undefined
            assertParamExists('testProfileApiV1ProfilesProfileIdTestPost', 'profileTestRequest', profileTestRequest)
            const localVarPath = `/api/v1/profiles/{profile_id}/test`
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileTestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update profile.  Args:     profile_id: Profile ID     update_data: Update data     current_user: Current authenticated user     profile_service: Profile service  Returns:     Updated profile information
         * @summary Update Profile
         * @param {string} profileId 
         * @param {ProfileUpdate} profileUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileApiV1ProfilesProfileIdPut: async (profileId: string, profileUpdate: ProfileUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'profileId' is not null or undefined
            assertParamExists('updateProfileApiV1ProfilesProfileIdPut', 'profileId', profileId)
            // verify required parameter 'profileUpdate' is not null or undefined
            assertParamExists('updateProfileApiV1ProfilesProfileIdPut', 'profileUpdate', profileUpdate)
            const localVarPath = `/api/v1/profiles/{profile_id}`
                .replace(`{${"profile_id"}}`, encodeURIComponent(String(profileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(profileUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProfilesApi - functional programming interface
 * @export
 */
export const ProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * Clone an existing profile.  Args:     profile_id: Source profile ID     clone_request: Clone request     current_user: Current authenticated user     profile_service: Profile service  Returns:     Cloned profile information
         * @summary Clone Profile
         * @param {string} profileId 
         * @param {ProfileCloneRequest} profileCloneRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cloneProfileApiV1ProfilesProfileIdClonePost(profileId: string, profileCloneRequest: ProfileCloneRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cloneProfileApiV1ProfilesProfileIdClonePost(profileId, profileCloneRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.cloneProfileApiV1ProfilesProfileIdClonePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new LLM profile.  Args:     profile_data: Profile creation data     current_user: Current authenticated user     profile_service: Profile service  Returns:     Created profile information
         * @summary Create Profile
         * @param {ProfileCreate} profileCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProfileApiV1ProfilesPost(profileCreate: ProfileCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProfileApiV1ProfilesPost(profileCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.createProfileApiV1ProfilesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete profile.  Args:     profile_id: Profile ID     request: Delete request parameters     current_user: Current authenticated user     profile_service: Profile service  Returns:     Success message
         * @summary Delete Profile
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProfileApiV1ProfilesProfileIdDelete(profileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProfileApiV1ProfilesProfileIdDelete(profileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.deleteProfileApiV1ProfilesProfileIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get available LLM providers.  Args:     request: Providers request parameters     current_user: Current authenticated user     profile_service: Profile service  Returns:     Available providers information
         * @summary Get Available Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableProvidersApiV1ProfilesProvidersAvailableGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableProvidersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableProvidersApiV1ProfilesProvidersAvailableGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.getAvailableProvidersApiV1ProfilesProvidersAvailableGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get profile details.  Args:     profile_id: Profile ID     current_user: Current authenticated user     profile_service: Profile service  Returns:     Profile information
         * @summary Get Profile
         * @param {string} profileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileApiV1ProfilesProfileIdGet(profileId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileApiV1ProfilesProfileIdGet(profileId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.getProfileApiV1ProfilesProfileIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get profile statistics.  Args:     current_user: Current authenticated user     profile_service: Profile service  Returns:     Profile statistics
         * @summary Get Profile Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileStatsApiV1ProfilesStatsOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileStatsApiV1ProfilesStatsOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.getProfileStatsApiV1ProfilesStatsOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List user\'s profiles.  Args:     profile_type: Filter by profile type     llm_provider: Filter by LLM provider     tags: Filter by tags     is_public: Filter by public status     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     profile_service: Profile service  Returns:     List of profiles with pagination info
         * @summary List Profiles
         * @param {ProfileType | null} [profileType] Filter by profile type
         * @param {string | null} [llmProvider] Filter by LLM provider
         * @param {Array<string> | null} [tags] Filter by tags
         * @param {boolean | null} [isPublic] Filter by public status
         * @param {number} [limit] Maximum number of results
         * @param {number} [offset] Number of results to skip
         * @param {string} [sortBy] Sort field
         * @param {string} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listProfilesApiV1ProfilesGet(profileType?: ProfileType | null, llmProvider?: string | null, tags?: Array<string> | null, isPublic?: boolean | null, limit?: number, offset?: number, sortBy?: string, sortOrder?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listProfilesApiV1ProfilesGet(profileType, llmProvider, tags, isPublic, limit, offset, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.listProfilesApiV1ProfilesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test profile with a sample message.  Args:     profile_id: Profile ID     test_request: Test request     current_user: Current authenticated user     profile_service: Profile service  Returns:     Test results
         * @summary Test Profile
         * @param {string} profileId 
         * @param {ProfileTestRequest} profileTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testProfileApiV1ProfilesProfileIdTestPost(profileId: string, profileTestRequest: ProfileTestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testProfileApiV1ProfilesProfileIdTestPost(profileId, profileTestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.testProfileApiV1ProfilesProfileIdTestPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update profile.  Args:     profile_id: Profile ID     update_data: Update data     current_user: Current authenticated user     profile_service: Profile service  Returns:     Updated profile information
         * @summary Update Profile
         * @param {string} profileId 
         * @param {ProfileUpdate} profileUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProfileApiV1ProfilesProfileIdPut(profileId: string, profileUpdate: ProfileUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProfileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProfileApiV1ProfilesProfileIdPut(profileId, profileUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProfilesApi.updateProfileApiV1ProfilesProfileIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProfilesApi - factory interface
 * @export
 */
export const ProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProfilesApiFp(configuration)
    return {
        /**
         * Clone an existing profile.  Args:     profile_id: Source profile ID     clone_request: Clone request     current_user: Current authenticated user     profile_service: Profile service  Returns:     Cloned profile information
         * @summary Clone Profile
         * @param {ProfilesApiCloneProfileApiV1ProfilesProfileIdClonePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cloneProfileApiV1ProfilesProfileIdClonePost(requestParameters: ProfilesApiCloneProfileApiV1ProfilesProfileIdClonePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileResponse> {
            return localVarFp.cloneProfileApiV1ProfilesProfileIdClonePost(requestParameters.profileId, requestParameters.profileCloneRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new LLM profile.  Args:     profile_data: Profile creation data     current_user: Current authenticated user     profile_service: Profile service  Returns:     Created profile information
         * @summary Create Profile
         * @param {ProfilesApiCreateProfileApiV1ProfilesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProfileApiV1ProfilesPost(requestParameters: ProfilesApiCreateProfileApiV1ProfilesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileResponse> {
            return localVarFp.createProfileApiV1ProfilesPost(requestParameters.profileCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete profile.  Args:     profile_id: Profile ID     request: Delete request parameters     current_user: Current authenticated user     profile_service: Profile service  Returns:     Success message
         * @summary Delete Profile
         * @param {ProfilesApiDeleteProfileApiV1ProfilesProfileIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProfileApiV1ProfilesProfileIdDelete(requestParameters: ProfilesApiDeleteProfileApiV1ProfilesProfileIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileDeleteResponse> {
            return localVarFp.deleteProfileApiV1ProfilesProfileIdDelete(requestParameters.profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get available LLM providers.  Args:     request: Providers request parameters     current_user: Current authenticated user     profile_service: Profile service  Returns:     Available providers information
         * @summary Get Available Providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableProvidersApiV1ProfilesProvidersAvailableGet(options?: RawAxiosRequestConfig): AxiosPromise<AvailableProvidersResponse> {
            return localVarFp.getAvailableProvidersApiV1ProfilesProvidersAvailableGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get profile details.  Args:     profile_id: Profile ID     current_user: Current authenticated user     profile_service: Profile service  Returns:     Profile information
         * @summary Get Profile
         * @param {ProfilesApiGetProfileApiV1ProfilesProfileIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileApiV1ProfilesProfileIdGet(requestParameters: ProfilesApiGetProfileApiV1ProfilesProfileIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileResponse> {
            return localVarFp.getProfileApiV1ProfilesProfileIdGet(requestParameters.profileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get profile statistics.  Args:     current_user: Current authenticated user     profile_service: Profile service  Returns:     Profile statistics
         * @summary Get Profile Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileStatsApiV1ProfilesStatsOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<ProfileStatsResponse> {
            return localVarFp.getProfileStatsApiV1ProfilesStatsOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * List user\'s profiles.  Args:     profile_type: Filter by profile type     llm_provider: Filter by LLM provider     tags: Filter by tags     is_public: Filter by public status     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     profile_service: Profile service  Returns:     List of profiles with pagination info
         * @summary List Profiles
         * @param {ProfilesApiListProfilesApiV1ProfilesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listProfilesApiV1ProfilesGet(requestParameters: ProfilesApiListProfilesApiV1ProfilesGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ProfileListResponse> {
            return localVarFp.listProfilesApiV1ProfilesGet(requestParameters.profileType, requestParameters.llmProvider, requestParameters.tags, requestParameters.isPublic, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Test profile with a sample message.  Args:     profile_id: Profile ID     test_request: Test request     current_user: Current authenticated user     profile_service: Profile service  Returns:     Test results
         * @summary Test Profile
         * @param {ProfilesApiTestProfileApiV1ProfilesProfileIdTestPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testProfileApiV1ProfilesProfileIdTestPost(requestParameters: ProfilesApiTestProfileApiV1ProfilesProfileIdTestPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileTestResponse> {
            return localVarFp.testProfileApiV1ProfilesProfileIdTestPost(requestParameters.profileId, requestParameters.profileTestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update profile.  Args:     profile_id: Profile ID     update_data: Update data     current_user: Current authenticated user     profile_service: Profile service  Returns:     Updated profile information
         * @summary Update Profile
         * @param {ProfilesApiUpdateProfileApiV1ProfilesProfileIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProfileApiV1ProfilesProfileIdPut(requestParameters: ProfilesApiUpdateProfileApiV1ProfilesProfileIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileResponse> {
            return localVarFp.updateProfileApiV1ProfilesProfileIdPut(requestParameters.profileId, requestParameters.profileUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProfilesApi - interface
 * @export
 * @interface ProfilesApi
 */
export interface ProfilesApiInterface {
    /**
     * Clone an existing profile.  Args:     profile_id: Source profile ID     clone_request: Clone request     current_user: Current authenticated user     profile_service: Profile service  Returns:     Cloned profile information
     * @summary Clone Profile
     * @param {ProfilesApiCloneProfileApiV1ProfilesProfileIdClonePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApiInterface
     */
    cloneProfileApiV1ProfilesProfileIdClonePost(requestParameters: ProfilesApiCloneProfileApiV1ProfilesProfileIdClonePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileResponse>;

    /**
     * Create a new LLM profile.  Args:     profile_data: Profile creation data     current_user: Current authenticated user     profile_service: Profile service  Returns:     Created profile information
     * @summary Create Profile
     * @param {ProfilesApiCreateProfileApiV1ProfilesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApiInterface
     */
    createProfileApiV1ProfilesPost(requestParameters: ProfilesApiCreateProfileApiV1ProfilesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileResponse>;

    /**
     * Delete profile.  Args:     profile_id: Profile ID     request: Delete request parameters     current_user: Current authenticated user     profile_service: Profile service  Returns:     Success message
     * @summary Delete Profile
     * @param {ProfilesApiDeleteProfileApiV1ProfilesProfileIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApiInterface
     */
    deleteProfileApiV1ProfilesProfileIdDelete(requestParameters: ProfilesApiDeleteProfileApiV1ProfilesProfileIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileDeleteResponse>;

    /**
     * Get available LLM providers.  Args:     request: Providers request parameters     current_user: Current authenticated user     profile_service: Profile service  Returns:     Available providers information
     * @summary Get Available Providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApiInterface
     */
    getAvailableProvidersApiV1ProfilesProvidersAvailableGet(options?: RawAxiosRequestConfig): AxiosPromise<AvailableProvidersResponse>;

    /**
     * Get profile details.  Args:     profile_id: Profile ID     current_user: Current authenticated user     profile_service: Profile service  Returns:     Profile information
     * @summary Get Profile
     * @param {ProfilesApiGetProfileApiV1ProfilesProfileIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApiInterface
     */
    getProfileApiV1ProfilesProfileIdGet(requestParameters: ProfilesApiGetProfileApiV1ProfilesProfileIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileResponse>;

    /**
     * Get profile statistics.  Args:     current_user: Current authenticated user     profile_service: Profile service  Returns:     Profile statistics
     * @summary Get Profile Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApiInterface
     */
    getProfileStatsApiV1ProfilesStatsOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<ProfileStatsResponse>;

    /**
     * List user\'s profiles.  Args:     profile_type: Filter by profile type     llm_provider: Filter by LLM provider     tags: Filter by tags     is_public: Filter by public status     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     profile_service: Profile service  Returns:     List of profiles with pagination info
     * @summary List Profiles
     * @param {ProfilesApiListProfilesApiV1ProfilesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApiInterface
     */
    listProfilesApiV1ProfilesGet(requestParameters?: ProfilesApiListProfilesApiV1ProfilesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileListResponse>;

    /**
     * Test profile with a sample message.  Args:     profile_id: Profile ID     test_request: Test request     current_user: Current authenticated user     profile_service: Profile service  Returns:     Test results
     * @summary Test Profile
     * @param {ProfilesApiTestProfileApiV1ProfilesProfileIdTestPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApiInterface
     */
    testProfileApiV1ProfilesProfileIdTestPost(requestParameters: ProfilesApiTestProfileApiV1ProfilesProfileIdTestPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileTestResponse>;

    /**
     * Update profile.  Args:     profile_id: Profile ID     update_data: Update data     current_user: Current authenticated user     profile_service: Profile service  Returns:     Updated profile information
     * @summary Update Profile
     * @param {ProfilesApiUpdateProfileApiV1ProfilesProfileIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApiInterface
     */
    updateProfileApiV1ProfilesProfileIdPut(requestParameters: ProfilesApiUpdateProfileApiV1ProfilesProfileIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProfileResponse>;

}

/**
 * Request parameters for cloneProfileApiV1ProfilesProfileIdClonePost operation in ProfilesApi.
 * @export
 * @interface ProfilesApiCloneProfileApiV1ProfilesProfileIdClonePostRequest
 */
export interface ProfilesApiCloneProfileApiV1ProfilesProfileIdClonePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfilesApiCloneProfileApiV1ProfilesProfileIdClonePost
     */
    readonly profileId: string

    /**
     * 
     * @type {ProfileCloneRequest}
     * @memberof ProfilesApiCloneProfileApiV1ProfilesProfileIdClonePost
     */
    readonly profileCloneRequest: ProfileCloneRequest
}

/**
 * Request parameters for createProfileApiV1ProfilesPost operation in ProfilesApi.
 * @export
 * @interface ProfilesApiCreateProfileApiV1ProfilesPostRequest
 */
export interface ProfilesApiCreateProfileApiV1ProfilesPostRequest {
    /**
     * 
     * @type {ProfileCreate}
     * @memberof ProfilesApiCreateProfileApiV1ProfilesPost
     */
    readonly profileCreate: ProfileCreate
}

/**
 * Request parameters for deleteProfileApiV1ProfilesProfileIdDelete operation in ProfilesApi.
 * @export
 * @interface ProfilesApiDeleteProfileApiV1ProfilesProfileIdDeleteRequest
 */
export interface ProfilesApiDeleteProfileApiV1ProfilesProfileIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfilesApiDeleteProfileApiV1ProfilesProfileIdDelete
     */
    readonly profileId: string
}

/**
 * Request parameters for getProfileApiV1ProfilesProfileIdGet operation in ProfilesApi.
 * @export
 * @interface ProfilesApiGetProfileApiV1ProfilesProfileIdGetRequest
 */
export interface ProfilesApiGetProfileApiV1ProfilesProfileIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfilesApiGetProfileApiV1ProfilesProfileIdGet
     */
    readonly profileId: string
}

/**
 * Request parameters for listProfilesApiV1ProfilesGet operation in ProfilesApi.
 * @export
 * @interface ProfilesApiListProfilesApiV1ProfilesGetRequest
 */
export interface ProfilesApiListProfilesApiV1ProfilesGetRequest {
    /**
     * Filter by profile type
     * @type {ProfileType}
     * @memberof ProfilesApiListProfilesApiV1ProfilesGet
     */
    readonly profileType?: ProfileType | null

    /**
     * Filter by LLM provider
     * @type {string}
     * @memberof ProfilesApiListProfilesApiV1ProfilesGet
     */
    readonly llmProvider?: string | null

    /**
     * Filter by tags
     * @type {Array<string>}
     * @memberof ProfilesApiListProfilesApiV1ProfilesGet
     */
    readonly tags?: Array<string> | null

    /**
     * Filter by public status
     * @type {boolean}
     * @memberof ProfilesApiListProfilesApiV1ProfilesGet
     */
    readonly isPublic?: boolean | null

    /**
     * Maximum number of results
     * @type {number}
     * @memberof ProfilesApiListProfilesApiV1ProfilesGet
     */
    readonly limit?: number

    /**
     * Number of results to skip
     * @type {number}
     * @memberof ProfilesApiListProfilesApiV1ProfilesGet
     */
    readonly offset?: number

    /**
     * Sort field
     * @type {string}
     * @memberof ProfilesApiListProfilesApiV1ProfilesGet
     */
    readonly sortBy?: string

    /**
     * Sort order
     * @type {string}
     * @memberof ProfilesApiListProfilesApiV1ProfilesGet
     */
    readonly sortOrder?: string
}

/**
 * Request parameters for testProfileApiV1ProfilesProfileIdTestPost operation in ProfilesApi.
 * @export
 * @interface ProfilesApiTestProfileApiV1ProfilesProfileIdTestPostRequest
 */
export interface ProfilesApiTestProfileApiV1ProfilesProfileIdTestPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfilesApiTestProfileApiV1ProfilesProfileIdTestPost
     */
    readonly profileId: string

    /**
     * 
     * @type {ProfileTestRequest}
     * @memberof ProfilesApiTestProfileApiV1ProfilesProfileIdTestPost
     */
    readonly profileTestRequest: ProfileTestRequest
}

/**
 * Request parameters for updateProfileApiV1ProfilesProfileIdPut operation in ProfilesApi.
 * @export
 * @interface ProfilesApiUpdateProfileApiV1ProfilesProfileIdPutRequest
 */
export interface ProfilesApiUpdateProfileApiV1ProfilesProfileIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ProfilesApiUpdateProfileApiV1ProfilesProfileIdPut
     */
    readonly profileId: string

    /**
     * 
     * @type {ProfileUpdate}
     * @memberof ProfilesApiUpdateProfileApiV1ProfilesProfileIdPut
     */
    readonly profileUpdate: ProfileUpdate
}

/**
 * ProfilesApi - object-oriented interface
 * @export
 * @class ProfilesApi
 * @extends {BaseAPI}
 */
export class ProfilesApi extends BaseAPI implements ProfilesApiInterface {
    /**
     * Clone an existing profile.  Args:     profile_id: Source profile ID     clone_request: Clone request     current_user: Current authenticated user     profile_service: Profile service  Returns:     Cloned profile information
     * @summary Clone Profile
     * @param {ProfilesApiCloneProfileApiV1ProfilesProfileIdClonePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public cloneProfileApiV1ProfilesProfileIdClonePost(requestParameters: ProfilesApiCloneProfileApiV1ProfilesProfileIdClonePostRequest, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).cloneProfileApiV1ProfilesProfileIdClonePost(requestParameters.profileId, requestParameters.profileCloneRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new LLM profile.  Args:     profile_data: Profile creation data     current_user: Current authenticated user     profile_service: Profile service  Returns:     Created profile information
     * @summary Create Profile
     * @param {ProfilesApiCreateProfileApiV1ProfilesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public createProfileApiV1ProfilesPost(requestParameters: ProfilesApiCreateProfileApiV1ProfilesPostRequest, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).createProfileApiV1ProfilesPost(requestParameters.profileCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete profile.  Args:     profile_id: Profile ID     request: Delete request parameters     current_user: Current authenticated user     profile_service: Profile service  Returns:     Success message
     * @summary Delete Profile
     * @param {ProfilesApiDeleteProfileApiV1ProfilesProfileIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public deleteProfileApiV1ProfilesProfileIdDelete(requestParameters: ProfilesApiDeleteProfileApiV1ProfilesProfileIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).deleteProfileApiV1ProfilesProfileIdDelete(requestParameters.profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get available LLM providers.  Args:     request: Providers request parameters     current_user: Current authenticated user     profile_service: Profile service  Returns:     Available providers information
     * @summary Get Available Providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public getAvailableProvidersApiV1ProfilesProvidersAvailableGet(options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).getAvailableProvidersApiV1ProfilesProvidersAvailableGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get profile details.  Args:     profile_id: Profile ID     current_user: Current authenticated user     profile_service: Profile service  Returns:     Profile information
     * @summary Get Profile
     * @param {ProfilesApiGetProfileApiV1ProfilesProfileIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public getProfileApiV1ProfilesProfileIdGet(requestParameters: ProfilesApiGetProfileApiV1ProfilesProfileIdGetRequest, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).getProfileApiV1ProfilesProfileIdGet(requestParameters.profileId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get profile statistics.  Args:     current_user: Current authenticated user     profile_service: Profile service  Returns:     Profile statistics
     * @summary Get Profile Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public getProfileStatsApiV1ProfilesStatsOverviewGet(options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).getProfileStatsApiV1ProfilesStatsOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List user\'s profiles.  Args:     profile_type: Filter by profile type     llm_provider: Filter by LLM provider     tags: Filter by tags     is_public: Filter by public status     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     profile_service: Profile service  Returns:     List of profiles with pagination info
     * @summary List Profiles
     * @param {ProfilesApiListProfilesApiV1ProfilesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public listProfilesApiV1ProfilesGet(requestParameters: ProfilesApiListProfilesApiV1ProfilesGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).listProfilesApiV1ProfilesGet(requestParameters.profileType, requestParameters.llmProvider, requestParameters.tags, requestParameters.isPublic, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test profile with a sample message.  Args:     profile_id: Profile ID     test_request: Test request     current_user: Current authenticated user     profile_service: Profile service  Returns:     Test results
     * @summary Test Profile
     * @param {ProfilesApiTestProfileApiV1ProfilesProfileIdTestPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public testProfileApiV1ProfilesProfileIdTestPost(requestParameters: ProfilesApiTestProfileApiV1ProfilesProfileIdTestPostRequest, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).testProfileApiV1ProfilesProfileIdTestPost(requestParameters.profileId, requestParameters.profileTestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update profile.  Args:     profile_id: Profile ID     update_data: Update data     current_user: Current authenticated user     profile_service: Profile service  Returns:     Updated profile information
     * @summary Update Profile
     * @param {ProfilesApiUpdateProfileApiV1ProfilesProfileIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProfilesApi
     */
    public updateProfileApiV1ProfilesProfileIdPut(requestParameters: ProfilesApiUpdateProfileApiV1ProfilesProfileIdPutRequest, options?: RawAxiosRequestConfig) {
        return ProfilesApiFp(this.configuration).updateProfileApiV1ProfilesProfileIdPut(requestParameters.profileId, requestParameters.profileUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PromptsApi - axios parameter creator
 * @export
 */
export const PromptsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Clone an existing prompt.  Args:     prompt_id: Source prompt ID     clone_request: Clone request     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Cloned prompt information
         * @summary Clone Prompt
         * @param {string} promptId 
         * @param {PromptCloneRequest} promptCloneRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clonePromptApiV1PromptsPromptIdClonePost: async (promptId: string, promptCloneRequest: PromptCloneRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('clonePromptApiV1PromptsPromptIdClonePost', 'promptId', promptId)
            // verify required parameter 'promptCloneRequest' is not null or undefined
            assertParamExists('clonePromptApiV1PromptsPromptIdClonePost', 'promptCloneRequest', promptCloneRequest)
            const localVarPath = `/api/v1/prompts/{prompt_id}/clone`
                .replace(`{${"prompt_id"}}`, encodeURIComponent(String(promptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptCloneRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new prompt.  Args:     prompt_data: Prompt creation data     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Created prompt information
         * @summary Create Prompt
         * @param {PromptCreate} promptCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPromptApiV1PromptsPost: async (promptCreate: PromptCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptCreate' is not null or undefined
            assertParamExists('createPromptApiV1PromptsPost', 'promptCreate', promptCreate)
            const localVarPath = `/api/v1/prompts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete prompt.  Args:     prompt_id: Prompt ID     request: Delete request parameters     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Success message
         * @summary Delete Prompt
         * @param {string} promptId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePromptApiV1PromptsPromptIdDelete: async (promptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('deletePromptApiV1PromptsPromptIdDelete', 'promptId', promptId)
            const localVarPath = `/api/v1/prompts/{prompt_id}`
                .replace(`{${"prompt_id"}}`, encodeURIComponent(String(promptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get prompt details.  Args:     prompt_id: Prompt ID     request: Get request parameters     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Prompt information
         * @summary Get Prompt
         * @param {string} promptId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromptApiV1PromptsPromptIdGet: async (promptId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('getPromptApiV1PromptsPromptIdGet', 'promptId', promptId)
            const localVarPath = `/api/v1/prompts/{prompt_id}`
                .replace(`{${"prompt_id"}}`, encodeURIComponent(String(promptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get prompt statistics.  Args:     request: Stats request parameters     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Prompt statistics
         * @summary Get Prompt Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromptStatsApiV1PromptsStatsOverviewGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/prompts/stats/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List user\'s prompts.  Args:     prompt_type: Filter by prompt type     category: Filter by category     tags: Filter by tags     is_public: Filter by public status     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     List of prompts with pagination info
         * @summary List Prompts
         * @param {PromptType | null} [promptType] Filter by prompt type
         * @param {PromptCategory | null} [category] Filter by category
         * @param {Array<string> | null} [tags] Filter by tags
         * @param {boolean | null} [isPublic] Filter by public status
         * @param {number} [limit] Maximum number of results
         * @param {number} [offset] Number of results to skip
         * @param {string} [sortBy] Sort field
         * @param {string} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptsApiV1PromptsGet: async (promptType?: PromptType | null, category?: PromptCategory | null, tags?: Array<string> | null, isPublic?: boolean | null, limit?: number, offset?: number, sortBy?: string, sortOrder?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/prompts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (promptType !== undefined) {
                localVarQueryParameter['prompt_type'] = promptType;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags;
            }

            if (isPublic !== undefined) {
                localVarQueryParameter['is_public'] = isPublic;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test prompt with given variables.  Args:     prompt_id: Prompt ID     test_request: Test request     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Test results
         * @summary Test Prompt
         * @param {string} promptId 
         * @param {PromptTestRequest} promptTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPromptApiV1PromptsPromptIdTestPost: async (promptId: string, promptTestRequest: PromptTestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('testPromptApiV1PromptsPromptIdTestPost', 'promptId', promptId)
            // verify required parameter 'promptTestRequest' is not null or undefined
            assertParamExists('testPromptApiV1PromptsPromptIdTestPost', 'promptTestRequest', promptTestRequest)
            const localVarPath = `/api/v1/prompts/{prompt_id}/test`
                .replace(`{${"prompt_id"}}`, encodeURIComponent(String(promptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptTestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update prompt.  Args:     prompt_id: Prompt ID     update_data: Update data     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Updated prompt information
         * @summary Update Prompt
         * @param {string} promptId 
         * @param {PromptUpdate} promptUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePromptApiV1PromptsPromptIdPut: async (promptId: string, promptUpdate: PromptUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promptId' is not null or undefined
            assertParamExists('updatePromptApiV1PromptsPromptIdPut', 'promptId', promptId)
            // verify required parameter 'promptUpdate' is not null or undefined
            assertParamExists('updatePromptApiV1PromptsPromptIdPut', 'promptUpdate', promptUpdate)
            const localVarPath = `/api/v1/prompts/{prompt_id}`
                .replace(`{${"prompt_id"}}`, encodeURIComponent(String(promptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promptUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PromptsApi - functional programming interface
 * @export
 */
export const PromptsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PromptsApiAxiosParamCreator(configuration)
    return {
        /**
         * Clone an existing prompt.  Args:     prompt_id: Source prompt ID     clone_request: Clone request     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Cloned prompt information
         * @summary Clone Prompt
         * @param {string} promptId 
         * @param {PromptCloneRequest} promptCloneRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clonePromptApiV1PromptsPromptIdClonePost(promptId: string, promptCloneRequest: PromptCloneRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clonePromptApiV1PromptsPromptIdClonePost(promptId, promptCloneRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.clonePromptApiV1PromptsPromptIdClonePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new prompt.  Args:     prompt_data: Prompt creation data     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Created prompt information
         * @summary Create Prompt
         * @param {PromptCreate} promptCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPromptApiV1PromptsPost(promptCreate: PromptCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPromptApiV1PromptsPost(promptCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.createPromptApiV1PromptsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete prompt.  Args:     prompt_id: Prompt ID     request: Delete request parameters     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Success message
         * @summary Delete Prompt
         * @param {string} promptId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePromptApiV1PromptsPromptIdDelete(promptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePromptApiV1PromptsPromptIdDelete(promptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.deletePromptApiV1PromptsPromptIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get prompt details.  Args:     prompt_id: Prompt ID     request: Get request parameters     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Prompt information
         * @summary Get Prompt
         * @param {string} promptId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPromptApiV1PromptsPromptIdGet(promptId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPromptApiV1PromptsPromptIdGet(promptId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.getPromptApiV1PromptsPromptIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get prompt statistics.  Args:     request: Stats request parameters     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Prompt statistics
         * @summary Get Prompt Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPromptStatsApiV1PromptsStatsOverviewGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptStatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPromptStatsApiV1PromptsStatsOverviewGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.getPromptStatsApiV1PromptsStatsOverviewGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List user\'s prompts.  Args:     prompt_type: Filter by prompt type     category: Filter by category     tags: Filter by tags     is_public: Filter by public status     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     List of prompts with pagination info
         * @summary List Prompts
         * @param {PromptType | null} [promptType] Filter by prompt type
         * @param {PromptCategory | null} [category] Filter by category
         * @param {Array<string> | null} [tags] Filter by tags
         * @param {boolean | null} [isPublic] Filter by public status
         * @param {number} [limit] Maximum number of results
         * @param {number} [offset] Number of results to skip
         * @param {string} [sortBy] Sort field
         * @param {string} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPromptsApiV1PromptsGet(promptType?: PromptType | null, category?: PromptCategory | null, tags?: Array<string> | null, isPublic?: boolean | null, limit?: number, offset?: number, sortBy?: string, sortOrder?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPromptsApiV1PromptsGet(promptType, category, tags, isPublic, limit, offset, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.listPromptsApiV1PromptsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test prompt with given variables.  Args:     prompt_id: Prompt ID     test_request: Test request     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Test results
         * @summary Test Prompt
         * @param {string} promptId 
         * @param {PromptTestRequest} promptTestRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testPromptApiV1PromptsPromptIdTestPost(promptId: string, promptTestRequest: PromptTestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testPromptApiV1PromptsPromptIdTestPost(promptId, promptTestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.testPromptApiV1PromptsPromptIdTestPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update prompt.  Args:     prompt_id: Prompt ID     update_data: Update data     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Updated prompt information
         * @summary Update Prompt
         * @param {string} promptId 
         * @param {PromptUpdate} promptUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePromptApiV1PromptsPromptIdPut(promptId: string, promptUpdate: PromptUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromptResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePromptApiV1PromptsPromptIdPut(promptId, promptUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PromptsApi.updatePromptApiV1PromptsPromptIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PromptsApi - factory interface
 * @export
 */
export const PromptsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PromptsApiFp(configuration)
    return {
        /**
         * Clone an existing prompt.  Args:     prompt_id: Source prompt ID     clone_request: Clone request     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Cloned prompt information
         * @summary Clone Prompt
         * @param {PromptsApiClonePromptApiV1PromptsPromptIdClonePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clonePromptApiV1PromptsPromptIdClonePost(requestParameters: PromptsApiClonePromptApiV1PromptsPromptIdClonePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptResponse> {
            return localVarFp.clonePromptApiV1PromptsPromptIdClonePost(requestParameters.promptId, requestParameters.promptCloneRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new prompt.  Args:     prompt_data: Prompt creation data     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Created prompt information
         * @summary Create Prompt
         * @param {PromptsApiCreatePromptApiV1PromptsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPromptApiV1PromptsPost(requestParameters: PromptsApiCreatePromptApiV1PromptsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptResponse> {
            return localVarFp.createPromptApiV1PromptsPost(requestParameters.promptCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete prompt.  Args:     prompt_id: Prompt ID     request: Delete request parameters     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Success message
         * @summary Delete Prompt
         * @param {PromptsApiDeletePromptApiV1PromptsPromptIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePromptApiV1PromptsPromptIdDelete(requestParameters: PromptsApiDeletePromptApiV1PromptsPromptIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptDeleteResponse> {
            return localVarFp.deletePromptApiV1PromptsPromptIdDelete(requestParameters.promptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get prompt details.  Args:     prompt_id: Prompt ID     request: Get request parameters     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Prompt information
         * @summary Get Prompt
         * @param {PromptsApiGetPromptApiV1PromptsPromptIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromptApiV1PromptsPromptIdGet(requestParameters: PromptsApiGetPromptApiV1PromptsPromptIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptResponse> {
            return localVarFp.getPromptApiV1PromptsPromptIdGet(requestParameters.promptId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get prompt statistics.  Args:     request: Stats request parameters     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Prompt statistics
         * @summary Get Prompt Stats
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPromptStatsApiV1PromptsStatsOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<PromptStatsResponse> {
            return localVarFp.getPromptStatsApiV1PromptsStatsOverviewGet(options).then((request) => request(axios, basePath));
        },
        /**
         * List user\'s prompts.  Args:     prompt_type: Filter by prompt type     category: Filter by category     tags: Filter by tags     is_public: Filter by public status     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     List of prompts with pagination info
         * @summary List Prompts
         * @param {PromptsApiListPromptsApiV1PromptsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPromptsApiV1PromptsGet(requestParameters: PromptsApiListPromptsApiV1PromptsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<PromptListResponse> {
            return localVarFp.listPromptsApiV1PromptsGet(requestParameters.promptType, requestParameters.category, requestParameters.tags, requestParameters.isPublic, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Test prompt with given variables.  Args:     prompt_id: Prompt ID     test_request: Test request     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Test results
         * @summary Test Prompt
         * @param {PromptsApiTestPromptApiV1PromptsPromptIdTestPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testPromptApiV1PromptsPromptIdTestPost(requestParameters: PromptsApiTestPromptApiV1PromptsPromptIdTestPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptTestResponse> {
            return localVarFp.testPromptApiV1PromptsPromptIdTestPost(requestParameters.promptId, requestParameters.promptTestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update prompt.  Args:     prompt_id: Prompt ID     update_data: Update data     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Updated prompt information
         * @summary Update Prompt
         * @param {PromptsApiUpdatePromptApiV1PromptsPromptIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePromptApiV1PromptsPromptIdPut(requestParameters: PromptsApiUpdatePromptApiV1PromptsPromptIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptResponse> {
            return localVarFp.updatePromptApiV1PromptsPromptIdPut(requestParameters.promptId, requestParameters.promptUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PromptsApi - interface
 * @export
 * @interface PromptsApi
 */
export interface PromptsApiInterface {
    /**
     * Clone an existing prompt.  Args:     prompt_id: Source prompt ID     clone_request: Clone request     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Cloned prompt information
     * @summary Clone Prompt
     * @param {PromptsApiClonePromptApiV1PromptsPromptIdClonePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    clonePromptApiV1PromptsPromptIdClonePost(requestParameters: PromptsApiClonePromptApiV1PromptsPromptIdClonePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptResponse>;

    /**
     * Create a new prompt.  Args:     prompt_data: Prompt creation data     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Created prompt information
     * @summary Create Prompt
     * @param {PromptsApiCreatePromptApiV1PromptsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    createPromptApiV1PromptsPost(requestParameters: PromptsApiCreatePromptApiV1PromptsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptResponse>;

    /**
     * Delete prompt.  Args:     prompt_id: Prompt ID     request: Delete request parameters     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Success message
     * @summary Delete Prompt
     * @param {PromptsApiDeletePromptApiV1PromptsPromptIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    deletePromptApiV1PromptsPromptIdDelete(requestParameters: PromptsApiDeletePromptApiV1PromptsPromptIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptDeleteResponse>;

    /**
     * Get prompt details.  Args:     prompt_id: Prompt ID     request: Get request parameters     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Prompt information
     * @summary Get Prompt
     * @param {PromptsApiGetPromptApiV1PromptsPromptIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    getPromptApiV1PromptsPromptIdGet(requestParameters: PromptsApiGetPromptApiV1PromptsPromptIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptResponse>;

    /**
     * Get prompt statistics.  Args:     request: Stats request parameters     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Prompt statistics
     * @summary Get Prompt Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    getPromptStatsApiV1PromptsStatsOverviewGet(options?: RawAxiosRequestConfig): AxiosPromise<PromptStatsResponse>;

    /**
     * List user\'s prompts.  Args:     prompt_type: Filter by prompt type     category: Filter by category     tags: Filter by tags     is_public: Filter by public status     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     List of prompts with pagination info
     * @summary List Prompts
     * @param {PromptsApiListPromptsApiV1PromptsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    listPromptsApiV1PromptsGet(requestParameters?: PromptsApiListPromptsApiV1PromptsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptListResponse>;

    /**
     * Test prompt with given variables.  Args:     prompt_id: Prompt ID     test_request: Test request     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Test results
     * @summary Test Prompt
     * @param {PromptsApiTestPromptApiV1PromptsPromptIdTestPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    testPromptApiV1PromptsPromptIdTestPost(requestParameters: PromptsApiTestPromptApiV1PromptsPromptIdTestPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptTestResponse>;

    /**
     * Update prompt.  Args:     prompt_id: Prompt ID     update_data: Update data     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Updated prompt information
     * @summary Update Prompt
     * @param {PromptsApiUpdatePromptApiV1PromptsPromptIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApiInterface
     */
    updatePromptApiV1PromptsPromptIdPut(requestParameters: PromptsApiUpdatePromptApiV1PromptsPromptIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromptResponse>;

}

/**
 * Request parameters for clonePromptApiV1PromptsPromptIdClonePost operation in PromptsApi.
 * @export
 * @interface PromptsApiClonePromptApiV1PromptsPromptIdClonePostRequest
 */
export interface PromptsApiClonePromptApiV1PromptsPromptIdClonePostRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiClonePromptApiV1PromptsPromptIdClonePost
     */
    readonly promptId: string

    /**
     * 
     * @type {PromptCloneRequest}
     * @memberof PromptsApiClonePromptApiV1PromptsPromptIdClonePost
     */
    readonly promptCloneRequest: PromptCloneRequest
}

/**
 * Request parameters for createPromptApiV1PromptsPost operation in PromptsApi.
 * @export
 * @interface PromptsApiCreatePromptApiV1PromptsPostRequest
 */
export interface PromptsApiCreatePromptApiV1PromptsPostRequest {
    /**
     * 
     * @type {PromptCreate}
     * @memberof PromptsApiCreatePromptApiV1PromptsPost
     */
    readonly promptCreate: PromptCreate
}

/**
 * Request parameters for deletePromptApiV1PromptsPromptIdDelete operation in PromptsApi.
 * @export
 * @interface PromptsApiDeletePromptApiV1PromptsPromptIdDeleteRequest
 */
export interface PromptsApiDeletePromptApiV1PromptsPromptIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiDeletePromptApiV1PromptsPromptIdDelete
     */
    readonly promptId: string
}

/**
 * Request parameters for getPromptApiV1PromptsPromptIdGet operation in PromptsApi.
 * @export
 * @interface PromptsApiGetPromptApiV1PromptsPromptIdGetRequest
 */
export interface PromptsApiGetPromptApiV1PromptsPromptIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiGetPromptApiV1PromptsPromptIdGet
     */
    readonly promptId: string
}

/**
 * Request parameters for listPromptsApiV1PromptsGet operation in PromptsApi.
 * @export
 * @interface PromptsApiListPromptsApiV1PromptsGetRequest
 */
export interface PromptsApiListPromptsApiV1PromptsGetRequest {
    /**
     * Filter by prompt type
     * @type {PromptType}
     * @memberof PromptsApiListPromptsApiV1PromptsGet
     */
    readonly promptType?: PromptType | null

    /**
     * Filter by category
     * @type {PromptCategory}
     * @memberof PromptsApiListPromptsApiV1PromptsGet
     */
    readonly category?: PromptCategory | null

    /**
     * Filter by tags
     * @type {Array<string>}
     * @memberof PromptsApiListPromptsApiV1PromptsGet
     */
    readonly tags?: Array<string> | null

    /**
     * Filter by public status
     * @type {boolean}
     * @memberof PromptsApiListPromptsApiV1PromptsGet
     */
    readonly isPublic?: boolean | null

    /**
     * Maximum number of results
     * @type {number}
     * @memberof PromptsApiListPromptsApiV1PromptsGet
     */
    readonly limit?: number

    /**
     * Number of results to skip
     * @type {number}
     * @memberof PromptsApiListPromptsApiV1PromptsGet
     */
    readonly offset?: number

    /**
     * Sort field
     * @type {string}
     * @memberof PromptsApiListPromptsApiV1PromptsGet
     */
    readonly sortBy?: string

    /**
     * Sort order
     * @type {string}
     * @memberof PromptsApiListPromptsApiV1PromptsGet
     */
    readonly sortOrder?: string
}

/**
 * Request parameters for testPromptApiV1PromptsPromptIdTestPost operation in PromptsApi.
 * @export
 * @interface PromptsApiTestPromptApiV1PromptsPromptIdTestPostRequest
 */
export interface PromptsApiTestPromptApiV1PromptsPromptIdTestPostRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiTestPromptApiV1PromptsPromptIdTestPost
     */
    readonly promptId: string

    /**
     * 
     * @type {PromptTestRequest}
     * @memberof PromptsApiTestPromptApiV1PromptsPromptIdTestPost
     */
    readonly promptTestRequest: PromptTestRequest
}

/**
 * Request parameters for updatePromptApiV1PromptsPromptIdPut operation in PromptsApi.
 * @export
 * @interface PromptsApiUpdatePromptApiV1PromptsPromptIdPutRequest
 */
export interface PromptsApiUpdatePromptApiV1PromptsPromptIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof PromptsApiUpdatePromptApiV1PromptsPromptIdPut
     */
    readonly promptId: string

    /**
     * 
     * @type {PromptUpdate}
     * @memberof PromptsApiUpdatePromptApiV1PromptsPromptIdPut
     */
    readonly promptUpdate: PromptUpdate
}

/**
 * PromptsApi - object-oriented interface
 * @export
 * @class PromptsApi
 * @extends {BaseAPI}
 */
export class PromptsApi extends BaseAPI implements PromptsApiInterface {
    /**
     * Clone an existing prompt.  Args:     prompt_id: Source prompt ID     clone_request: Clone request     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Cloned prompt information
     * @summary Clone Prompt
     * @param {PromptsApiClonePromptApiV1PromptsPromptIdClonePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public clonePromptApiV1PromptsPromptIdClonePost(requestParameters: PromptsApiClonePromptApiV1PromptsPromptIdClonePostRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).clonePromptApiV1PromptsPromptIdClonePost(requestParameters.promptId, requestParameters.promptCloneRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new prompt.  Args:     prompt_data: Prompt creation data     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Created prompt information
     * @summary Create Prompt
     * @param {PromptsApiCreatePromptApiV1PromptsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public createPromptApiV1PromptsPost(requestParameters: PromptsApiCreatePromptApiV1PromptsPostRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).createPromptApiV1PromptsPost(requestParameters.promptCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete prompt.  Args:     prompt_id: Prompt ID     request: Delete request parameters     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Success message
     * @summary Delete Prompt
     * @param {PromptsApiDeletePromptApiV1PromptsPromptIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public deletePromptApiV1PromptsPromptIdDelete(requestParameters: PromptsApiDeletePromptApiV1PromptsPromptIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).deletePromptApiV1PromptsPromptIdDelete(requestParameters.promptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get prompt details.  Args:     prompt_id: Prompt ID     request: Get request parameters     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Prompt information
     * @summary Get Prompt
     * @param {PromptsApiGetPromptApiV1PromptsPromptIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public getPromptApiV1PromptsPromptIdGet(requestParameters: PromptsApiGetPromptApiV1PromptsPromptIdGetRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).getPromptApiV1PromptsPromptIdGet(requestParameters.promptId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get prompt statistics.  Args:     request: Stats request parameters     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Prompt statistics
     * @summary Get Prompt Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public getPromptStatsApiV1PromptsStatsOverviewGet(options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).getPromptStatsApiV1PromptsStatsOverviewGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List user\'s prompts.  Args:     prompt_type: Filter by prompt type     category: Filter by category     tags: Filter by tags     is_public: Filter by public status     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     List of prompts with pagination info
     * @summary List Prompts
     * @param {PromptsApiListPromptsApiV1PromptsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public listPromptsApiV1PromptsGet(requestParameters: PromptsApiListPromptsApiV1PromptsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).listPromptsApiV1PromptsGet(requestParameters.promptType, requestParameters.category, requestParameters.tags, requestParameters.isPublic, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test prompt with given variables.  Args:     prompt_id: Prompt ID     test_request: Test request     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Test results
     * @summary Test Prompt
     * @param {PromptsApiTestPromptApiV1PromptsPromptIdTestPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public testPromptApiV1PromptsPromptIdTestPost(requestParameters: PromptsApiTestPromptApiV1PromptsPromptIdTestPostRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).testPromptApiV1PromptsPromptIdTestPost(requestParameters.promptId, requestParameters.promptTestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update prompt.  Args:     prompt_id: Prompt ID     update_data: Update data     current_user: Current authenticated user     prompt_service: Prompt service  Returns:     Updated prompt information
     * @summary Update Prompt
     * @param {PromptsApiUpdatePromptApiV1PromptsPromptIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PromptsApi
     */
    public updatePromptApiV1PromptsPromptIdPut(requestParameters: PromptsApiUpdatePromptApiV1PromptsPromptIdPutRequest, options?: RawAxiosRequestConfig) {
        return PromptsApiFp(this.configuration).updatePromptApiV1PromptsPromptIdPut(requestParameters.promptId, requestParameters.promptUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ToolServersApi - axios parameter creator
 * @export
 */
export const ToolServersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Perform bulk operations on multiple servers.  Args:     operation_data: Bulk operation data     current_user: Current authenticated user     service: Tool server service  Returns:     Bulk operation result
         * @summary Bulk Server Operation
         * @param {BulkToolServerOperation} bulkToolServerOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkServerOperationApiV1ToolserversServersBulkPost: async (bulkToolServerOperation: BulkToolServerOperation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bulkToolServerOperation' is not null or undefined
            assertParamExists('bulkServerOperationApiV1ToolserversServersBulkPost', 'bulkToolServerOperation', bulkToolServerOperation)
            const localVarPath = `/api/v1/toolservers/servers/bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkToolServerOperation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Perform health check on a server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Health check result
         * @summary Check Server Health
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkServerHealthApiV1ToolserversServersServerIdHealthGet: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('checkServerHealthApiV1ToolserversServersServerIdHealthGet', 'serverId', serverId)
            const localVarPath = `/api/v1/toolservers/servers/{server_id}/health`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new tool server.  Args:     server_data: Server creation data     current_user: Current authenticated user     service: Tool server service  Returns:     Created server response
         * @summary Create Tool Server
         * @param {ToolServerCreate} toolServerCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createToolServerApiV1ToolserversServersPost: async (toolServerCreate: ToolServerCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolServerCreate' is not null or undefined
            assertParamExists('createToolServerApiV1ToolserversServersPost', 'toolServerCreate', toolServerCreate)
            const localVarPath = `/api/v1/toolservers/servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolServerCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Success message
         * @summary Delete Tool Server
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToolServerApiV1ToolserversServersServerIdDelete: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('deleteToolServerApiV1ToolserversServersServerIdDelete', 'serverId', serverId)
            const localVarPath = `/api/v1/toolservers/servers/{server_id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable a specific tool.  Args:     tool_id: Tool ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Disable Tool
         * @param {string} toolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableToolApiV1ToolserversToolsToolIdDisablePost: async (toolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolId' is not null or undefined
            assertParamExists('disableToolApiV1ToolserversToolsToolIdDisablePost', 'toolId', toolId)
            const localVarPath = `/api/v1/toolservers/tools/{tool_id}/disable`
                .replace(`{${"tool_id"}}`, encodeURIComponent(String(toolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Disable a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Disable Tool Server
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableToolServerApiV1ToolserversServersServerIdDisablePost: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('disableToolServerApiV1ToolserversServersServerIdDisablePost', 'serverId', serverId)
            const localVarPath = `/api/v1/toolservers/servers/{server_id}/disable`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable a specific tool.  Args:     tool_id: Tool ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Enable Tool
         * @param {string} toolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableToolApiV1ToolserversToolsToolIdEnablePost: async (toolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'toolId' is not null or undefined
            assertParamExists('enableToolApiV1ToolserversToolsToolIdEnablePost', 'toolId', toolId)
            const localVarPath = `/api/v1/toolservers/tools/{tool_id}/enable`
                .replace(`{${"tool_id"}}`, encodeURIComponent(String(toolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Enable a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Enable Tool Server
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableToolServerApiV1ToolserversServersServerIdEnablePost: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('enableToolServerApiV1ToolserversServersServerIdEnablePost', 'serverId', serverId)
            const localVarPath = `/api/v1/toolservers/servers/{server_id}/enable`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get analytics for a specific server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Server metrics
         * @summary Get Server Metrics
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerMetricsApiV1ToolserversServersServerIdMetricsGet: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('getServerMetricsApiV1ToolserversServersServerIdMetricsGet', 'serverId', serverId)
            const localVarPath = `/api/v1/toolservers/servers/{server_id}/metrics`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get tools for a specific server.  Args:     server_id: Server ID     request: Server tools request with pagination     current_user: Current authenticated user     service: Tool server service  Returns:     List of server tools with pagination
         * @summary Get Server Tools
         * @param {string} serverId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerToolsApiV1ToolserversServersServerIdToolsGet: async (serverId: string, limit?: number, offset?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('getServerToolsApiV1ToolserversServersServerIdToolsGet', 'serverId', serverId)
            const localVarPath = `/api/v1/toolservers/servers/{server_id}/tools`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a tool server by ID.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Server response
         * @summary Get Tool Server
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolServerApiV1ToolserversServersServerIdGet: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('getToolServerApiV1ToolserversServersServerIdGet', 'serverId', serverId)
            const localVarPath = `/api/v1/toolservers/servers/{server_id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all tools across all servers.  Args:     current_user: Current authenticated user     tool_server_service: Tool server service  Returns:     List of all available tools across all servers
         * @summary List All Tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllToolsApiV1ToolserversToolsAllGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/toolservers/tools/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List tool servers with optional filtering.  Args:     request: List request with filter parameters     current_user: Current authenticated user     service: Tool server service  Returns:     List of server responses
         * @summary List Tool Servers
         * @param {ServerStatus | null} [status] 
         * @param {boolean} [includeBuiltin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listToolServersApiV1ToolserversServersGet: async (status?: ServerStatus | null, includeBuiltin?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/toolservers/servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (includeBuiltin !== undefined) {
                localVarQueryParameter['include_builtin'] = includeBuiltin;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restart a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Restart Tool Server
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartToolServerApiV1ToolserversServersServerIdRestartPost: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('restartToolServerApiV1ToolserversServersServerIdRestartPost', 'serverId', serverId)
            const localVarPath = `/api/v1/toolservers/servers/{server_id}/restart`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Start a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Start Tool Server
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startToolServerApiV1ToolserversServersServerIdStartPost: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('startToolServerApiV1ToolserversServersServerIdStartPost', 'serverId', serverId)
            const localVarPath = `/api/v1/toolservers/servers/{server_id}/start`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stop a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Stop Tool Server
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopToolServerApiV1ToolserversServersServerIdStopPost: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('stopToolServerApiV1ToolserversServersServerIdStopPost', 'serverId', serverId)
            const localVarPath = `/api/v1/toolservers/servers/{server_id}/stop`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test connectivity to an external MCP server.  Args:     server_id: Tool server ID     current_user: Current authenticated user     tool_server_service: Tool server service  Returns:     Connectivity test results
         * @summary Test Server Connectivity
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPost: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('testServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPost', 'serverId', serverId)
            const localVarPath = `/api/v1/toolservers/servers/{server_id}/test-connectivity`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a tool server.  Args:     server_id: Server ID     update_data: Update data     current_user: Current authenticated user     service: Tool server service  Returns:     Updated server response
         * @summary Update Tool Server
         * @param {string} serverId 
         * @param {ToolServerUpdate} toolServerUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateToolServerApiV1ToolserversServersServerIdPut: async (serverId: string, toolServerUpdate: ToolServerUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('updateToolServerApiV1ToolserversServersServerIdPut', 'serverId', serverId)
            // verify required parameter 'toolServerUpdate' is not null or undefined
            assertParamExists('updateToolServerApiV1ToolserversServersServerIdPut', 'toolServerUpdate', toolServerUpdate)
            const localVarPath = `/api/v1/toolservers/servers/{server_id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(toolServerUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ToolServersApi - functional programming interface
 * @export
 */
export const ToolServersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ToolServersApiAxiosParamCreator(configuration)
    return {
        /**
         * Perform bulk operations on multiple servers.  Args:     operation_data: Bulk operation data     current_user: Current authenticated user     service: Tool server service  Returns:     Bulk operation result
         * @summary Bulk Server Operation
         * @param {BulkToolServerOperation} bulkToolServerOperation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkServerOperationApiV1ToolserversServersBulkPost(bulkToolServerOperation: BulkToolServerOperation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkOperationResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkServerOperationApiV1ToolserversServersBulkPost(bulkToolServerOperation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.bulkServerOperationApiV1ToolserversServersBulkPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Perform health check on a server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Health check result
         * @summary Check Server Health
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async checkServerHealthApiV1ToolserversServersServerIdHealthGet(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolServerHealthCheck>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.checkServerHealthApiV1ToolserversServersServerIdHealthGet(serverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.checkServerHealthApiV1ToolserversServersServerIdHealthGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new tool server.  Args:     server_data: Server creation data     current_user: Current authenticated user     service: Tool server service  Returns:     Created server response
         * @summary Create Tool Server
         * @param {ToolServerCreate} toolServerCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createToolServerApiV1ToolserversServersPost(toolServerCreate: ToolServerCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolServerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createToolServerApiV1ToolserversServersPost(toolServerCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.createToolServerApiV1ToolserversServersPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Success message
         * @summary Delete Tool Server
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteToolServerApiV1ToolserversServersServerIdDelete(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolServerDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteToolServerApiV1ToolserversServersServerIdDelete(serverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.deleteToolServerApiV1ToolserversServersServerIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable a specific tool.  Args:     tool_id: Tool ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Disable Tool
         * @param {string} toolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableToolApiV1ToolserversToolsToolIdDisablePost(toolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableToolApiV1ToolserversToolsToolIdDisablePost(toolId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.disableToolApiV1ToolserversToolsToolIdDisablePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Disable a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Disable Tool Server
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async disableToolServerApiV1ToolserversServersServerIdDisablePost(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolServerOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.disableToolServerApiV1ToolserversServersServerIdDisablePost(serverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.disableToolServerApiV1ToolserversServersServerIdDisablePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable a specific tool.  Args:     tool_id: Tool ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Enable Tool
         * @param {string} toolId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableToolApiV1ToolserversToolsToolIdEnablePost(toolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableToolApiV1ToolserversToolsToolIdEnablePost(toolId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.enableToolApiV1ToolserversToolsToolIdEnablePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Enable a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Enable Tool Server
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async enableToolServerApiV1ToolserversServersServerIdEnablePost(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolServerOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.enableToolServerApiV1ToolserversServersServerIdEnablePost(serverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.enableToolServerApiV1ToolserversServersServerIdEnablePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get analytics for a specific server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Server metrics
         * @summary Get Server Metrics
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerMetricsApiV1ToolserversServersServerIdMetricsGet(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolServerMetrics>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerMetricsApiV1ToolserversServersServerIdMetricsGet(serverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.getServerMetricsApiV1ToolserversServersServerIdMetricsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get tools for a specific server.  Args:     server_id: Server ID     request: Server tools request with pagination     current_user: Current authenticated user     service: Tool server service  Returns:     List of server tools with pagination
         * @summary Get Server Tools
         * @param {string} serverId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerToolsApiV1ToolserversServersServerIdToolsGet(serverId: string, limit?: number, offset?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerToolsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerToolsApiV1ToolserversServersServerIdToolsGet(serverId, limit, offset, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.getServerToolsApiV1ToolserversServersServerIdToolsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a tool server by ID.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Server response
         * @summary Get Tool Server
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToolServerApiV1ToolserversServersServerIdGet(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolServerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToolServerApiV1ToolserversServersServerIdGet(serverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.getToolServerApiV1ToolserversServersServerIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all tools across all servers.  Args:     current_user: Current authenticated user     tool_server_service: Tool server service  Returns:     List of all available tools across all servers
         * @summary List All Tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listAllToolsApiV1ToolserversToolsAllGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<{ [key: string]: any; }>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listAllToolsApiV1ToolserversToolsAllGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.listAllToolsApiV1ToolserversToolsAllGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List tool servers with optional filtering.  Args:     request: List request with filter parameters     current_user: Current authenticated user     service: Tool server service  Returns:     List of server responses
         * @summary List Tool Servers
         * @param {ServerStatus | null} [status] 
         * @param {boolean} [includeBuiltin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listToolServersApiV1ToolserversServersGet(status?: ServerStatus | null, includeBuiltin?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ToolServerResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listToolServersApiV1ToolserversServersGet(status, includeBuiltin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.listToolServersApiV1ToolserversServersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restart a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Restart Tool Server
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restartToolServerApiV1ToolserversServersServerIdRestartPost(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolServerOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restartToolServerApiV1ToolserversServersServerIdRestartPost(serverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.restartToolServerApiV1ToolserversServersServerIdRestartPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Start a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Start Tool Server
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async startToolServerApiV1ToolserversServersServerIdStartPost(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolServerOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.startToolServerApiV1ToolserversServersServerIdStartPost(serverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.startToolServerApiV1ToolserversServersServerIdStartPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stop a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Stop Tool Server
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async stopToolServerApiV1ToolserversServersServerIdStopPost(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolServerOperationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.stopToolServerApiV1ToolserversServersServerIdStopPost(serverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.stopToolServerApiV1ToolserversServersServerIdStopPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Test connectivity to an external MCP server.  Args:     server_id: Tool server ID     current_user: Current authenticated user     tool_server_service: Tool server service  Returns:     Connectivity test results
         * @summary Test Server Connectivity
         * @param {string} serverId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPost(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPost(serverId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.testServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a tool server.  Args:     server_id: Server ID     update_data: Update data     current_user: Current authenticated user     service: Tool server service  Returns:     Updated server response
         * @summary Update Tool Server
         * @param {string} serverId 
         * @param {ToolServerUpdate} toolServerUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateToolServerApiV1ToolserversServersServerIdPut(serverId: string, toolServerUpdate: ToolServerUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ToolServerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateToolServerApiV1ToolserversServersServerIdPut(serverId, toolServerUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ToolServersApi.updateToolServerApiV1ToolserversServersServerIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ToolServersApi - factory interface
 * @export
 */
export const ToolServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ToolServersApiFp(configuration)
    return {
        /**
         * Perform bulk operations on multiple servers.  Args:     operation_data: Bulk operation data     current_user: Current authenticated user     service: Tool server service  Returns:     Bulk operation result
         * @summary Bulk Server Operation
         * @param {ToolServersApiBulkServerOperationApiV1ToolserversServersBulkPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkServerOperationApiV1ToolserversServersBulkPost(requestParameters: ToolServersApiBulkServerOperationApiV1ToolserversServersBulkPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkOperationResult> {
            return localVarFp.bulkServerOperationApiV1ToolserversServersBulkPost(requestParameters.bulkToolServerOperation, options).then((request) => request(axios, basePath));
        },
        /**
         * Perform health check on a server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Health check result
         * @summary Check Server Health
         * @param {ToolServersApiCheckServerHealthApiV1ToolserversServersServerIdHealthGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkServerHealthApiV1ToolserversServersServerIdHealthGet(requestParameters: ToolServersApiCheckServerHealthApiV1ToolserversServersServerIdHealthGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerHealthCheck> {
            return localVarFp.checkServerHealthApiV1ToolserversServersServerIdHealthGet(requestParameters.serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new tool server.  Args:     server_data: Server creation data     current_user: Current authenticated user     service: Tool server service  Returns:     Created server response
         * @summary Create Tool Server
         * @param {ToolServersApiCreateToolServerApiV1ToolserversServersPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createToolServerApiV1ToolserversServersPost(requestParameters: ToolServersApiCreateToolServerApiV1ToolserversServersPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerResponse> {
            return localVarFp.createToolServerApiV1ToolserversServersPost(requestParameters.toolServerCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Success message
         * @summary Delete Tool Server
         * @param {ToolServersApiDeleteToolServerApiV1ToolserversServersServerIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToolServerApiV1ToolserversServersServerIdDelete(requestParameters: ToolServersApiDeleteToolServerApiV1ToolserversServersServerIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerDeleteResponse> {
            return localVarFp.deleteToolServerApiV1ToolserversServersServerIdDelete(requestParameters.serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable a specific tool.  Args:     tool_id: Tool ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Disable Tool
         * @param {ToolServersApiDisableToolApiV1ToolserversToolsToolIdDisablePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableToolApiV1ToolserversToolsToolIdDisablePost(requestParameters: ToolServersApiDisableToolApiV1ToolserversToolsToolIdDisablePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolOperationResponse> {
            return localVarFp.disableToolApiV1ToolserversToolsToolIdDisablePost(requestParameters.toolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Disable a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Disable Tool Server
         * @param {ToolServersApiDisableToolServerApiV1ToolserversServersServerIdDisablePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        disableToolServerApiV1ToolserversServersServerIdDisablePost(requestParameters: ToolServersApiDisableToolServerApiV1ToolserversServersServerIdDisablePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerOperationResponse> {
            return localVarFp.disableToolServerApiV1ToolserversServersServerIdDisablePost(requestParameters.serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable a specific tool.  Args:     tool_id: Tool ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Enable Tool
         * @param {ToolServersApiEnableToolApiV1ToolserversToolsToolIdEnablePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableToolApiV1ToolserversToolsToolIdEnablePost(requestParameters: ToolServersApiEnableToolApiV1ToolserversToolsToolIdEnablePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolOperationResponse> {
            return localVarFp.enableToolApiV1ToolserversToolsToolIdEnablePost(requestParameters.toolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Enable a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Enable Tool Server
         * @param {ToolServersApiEnableToolServerApiV1ToolserversServersServerIdEnablePostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enableToolServerApiV1ToolserversServersServerIdEnablePost(requestParameters: ToolServersApiEnableToolServerApiV1ToolserversServersServerIdEnablePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerOperationResponse> {
            return localVarFp.enableToolServerApiV1ToolserversServersServerIdEnablePost(requestParameters.serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get analytics for a specific server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Server metrics
         * @summary Get Server Metrics
         * @param {ToolServersApiGetServerMetricsApiV1ToolserversServersServerIdMetricsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerMetricsApiV1ToolserversServersServerIdMetricsGet(requestParameters: ToolServersApiGetServerMetricsApiV1ToolserversServersServerIdMetricsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerMetrics> {
            return localVarFp.getServerMetricsApiV1ToolserversServersServerIdMetricsGet(requestParameters.serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get tools for a specific server.  Args:     server_id: Server ID     request: Server tools request with pagination     current_user: Current authenticated user     service: Tool server service  Returns:     List of server tools with pagination
         * @summary Get Server Tools
         * @param {ToolServersApiGetServerToolsApiV1ToolserversServersServerIdToolsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerToolsApiV1ToolserversServersServerIdToolsGet(requestParameters: ToolServersApiGetServerToolsApiV1ToolserversServersServerIdToolsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ServerToolsResponse> {
            return localVarFp.getServerToolsApiV1ToolserversServersServerIdToolsGet(requestParameters.serverId, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a tool server by ID.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Server response
         * @summary Get Tool Server
         * @param {ToolServersApiGetToolServerApiV1ToolserversServersServerIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToolServerApiV1ToolserversServersServerIdGet(requestParameters: ToolServersApiGetToolServerApiV1ToolserversServersServerIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerResponse> {
            return localVarFp.getToolServerApiV1ToolserversServersServerIdGet(requestParameters.serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all tools across all servers.  Args:     current_user: Current authenticated user     tool_server_service: Tool server service  Returns:     List of all available tools across all servers
         * @summary List All Tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listAllToolsApiV1ToolserversToolsAllGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<{ [key: string]: any; }>> {
            return localVarFp.listAllToolsApiV1ToolserversToolsAllGet(options).then((request) => request(axios, basePath));
        },
        /**
         * List tool servers with optional filtering.  Args:     request: List request with filter parameters     current_user: Current authenticated user     service: Tool server service  Returns:     List of server responses
         * @summary List Tool Servers
         * @param {ToolServersApiListToolServersApiV1ToolserversServersGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listToolServersApiV1ToolserversServersGet(requestParameters: ToolServersApiListToolServersApiV1ToolserversServersGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<Array<ToolServerResponse>> {
            return localVarFp.listToolServersApiV1ToolserversServersGet(requestParameters.status, requestParameters.includeBuiltin, options).then((request) => request(axios, basePath));
        },
        /**
         * Restart a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Restart Tool Server
         * @param {ToolServersApiRestartToolServerApiV1ToolserversServersServerIdRestartPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartToolServerApiV1ToolserversServersServerIdRestartPost(requestParameters: ToolServersApiRestartToolServerApiV1ToolserversServersServerIdRestartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerOperationResponse> {
            return localVarFp.restartToolServerApiV1ToolserversServersServerIdRestartPost(requestParameters.serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * Start a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Start Tool Server
         * @param {ToolServersApiStartToolServerApiV1ToolserversServersServerIdStartPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startToolServerApiV1ToolserversServersServerIdStartPost(requestParameters: ToolServersApiStartToolServerApiV1ToolserversServersServerIdStartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerOperationResponse> {
            return localVarFp.startToolServerApiV1ToolserversServersServerIdStartPost(requestParameters.serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * Stop a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
         * @summary Stop Tool Server
         * @param {ToolServersApiStopToolServerApiV1ToolserversServersServerIdStopPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        stopToolServerApiV1ToolserversServersServerIdStopPost(requestParameters: ToolServersApiStopToolServerApiV1ToolserversServersServerIdStopPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerOperationResponse> {
            return localVarFp.stopToolServerApiV1ToolserversServersServerIdStopPost(requestParameters.serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * Test connectivity to an external MCP server.  Args:     server_id: Tool server ID     current_user: Current authenticated user     tool_server_service: Tool server service  Returns:     Connectivity test results
         * @summary Test Server Connectivity
         * @param {ToolServersApiTestServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPost(requestParameters: ToolServersApiTestServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.testServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPost(requestParameters.serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a tool server.  Args:     server_id: Server ID     update_data: Update data     current_user: Current authenticated user     service: Tool server service  Returns:     Updated server response
         * @summary Update Tool Server
         * @param {ToolServersApiUpdateToolServerApiV1ToolserversServersServerIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateToolServerApiV1ToolserversServersServerIdPut(requestParameters: ToolServersApiUpdateToolServerApiV1ToolserversServersServerIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerResponse> {
            return localVarFp.updateToolServerApiV1ToolserversServersServerIdPut(requestParameters.serverId, requestParameters.toolServerUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ToolServersApi - interface
 * @export
 * @interface ToolServersApi
 */
export interface ToolServersApiInterface {
    /**
     * Perform bulk operations on multiple servers.  Args:     operation_data: Bulk operation data     current_user: Current authenticated user     service: Tool server service  Returns:     Bulk operation result
     * @summary Bulk Server Operation
     * @param {ToolServersApiBulkServerOperationApiV1ToolserversServersBulkPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    bulkServerOperationApiV1ToolserversServersBulkPost(requestParameters: ToolServersApiBulkServerOperationApiV1ToolserversServersBulkPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkOperationResult>;

    /**
     * Perform health check on a server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Health check result
     * @summary Check Server Health
     * @param {ToolServersApiCheckServerHealthApiV1ToolserversServersServerIdHealthGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    checkServerHealthApiV1ToolserversServersServerIdHealthGet(requestParameters: ToolServersApiCheckServerHealthApiV1ToolserversServersServerIdHealthGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerHealthCheck>;

    /**
     * Create a new tool server.  Args:     server_data: Server creation data     current_user: Current authenticated user     service: Tool server service  Returns:     Created server response
     * @summary Create Tool Server
     * @param {ToolServersApiCreateToolServerApiV1ToolserversServersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    createToolServerApiV1ToolserversServersPost(requestParameters: ToolServersApiCreateToolServerApiV1ToolserversServersPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerResponse>;

    /**
     * Delete a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Success message
     * @summary Delete Tool Server
     * @param {ToolServersApiDeleteToolServerApiV1ToolserversServersServerIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    deleteToolServerApiV1ToolserversServersServerIdDelete(requestParameters: ToolServersApiDeleteToolServerApiV1ToolserversServersServerIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerDeleteResponse>;

    /**
     * Disable a specific tool.  Args:     tool_id: Tool ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
     * @summary Disable Tool
     * @param {ToolServersApiDisableToolApiV1ToolserversToolsToolIdDisablePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    disableToolApiV1ToolserversToolsToolIdDisablePost(requestParameters: ToolServersApiDisableToolApiV1ToolserversToolsToolIdDisablePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolOperationResponse>;

    /**
     * Disable a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
     * @summary Disable Tool Server
     * @param {ToolServersApiDisableToolServerApiV1ToolserversServersServerIdDisablePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    disableToolServerApiV1ToolserversServersServerIdDisablePost(requestParameters: ToolServersApiDisableToolServerApiV1ToolserversServersServerIdDisablePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerOperationResponse>;

    /**
     * Enable a specific tool.  Args:     tool_id: Tool ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
     * @summary Enable Tool
     * @param {ToolServersApiEnableToolApiV1ToolserversToolsToolIdEnablePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    enableToolApiV1ToolserversToolsToolIdEnablePost(requestParameters: ToolServersApiEnableToolApiV1ToolserversToolsToolIdEnablePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolOperationResponse>;

    /**
     * Enable a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
     * @summary Enable Tool Server
     * @param {ToolServersApiEnableToolServerApiV1ToolserversServersServerIdEnablePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    enableToolServerApiV1ToolserversServersServerIdEnablePost(requestParameters: ToolServersApiEnableToolServerApiV1ToolserversServersServerIdEnablePostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerOperationResponse>;

    /**
     * Get analytics for a specific server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Server metrics
     * @summary Get Server Metrics
     * @param {ToolServersApiGetServerMetricsApiV1ToolserversServersServerIdMetricsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    getServerMetricsApiV1ToolserversServersServerIdMetricsGet(requestParameters: ToolServersApiGetServerMetricsApiV1ToolserversServersServerIdMetricsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerMetrics>;

    /**
     * Get tools for a specific server.  Args:     server_id: Server ID     request: Server tools request with pagination     current_user: Current authenticated user     service: Tool server service  Returns:     List of server tools with pagination
     * @summary Get Server Tools
     * @param {ToolServersApiGetServerToolsApiV1ToolserversServersServerIdToolsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    getServerToolsApiV1ToolserversServersServerIdToolsGet(requestParameters: ToolServersApiGetServerToolsApiV1ToolserversServersServerIdToolsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ServerToolsResponse>;

    /**
     * Get a tool server by ID.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Server response
     * @summary Get Tool Server
     * @param {ToolServersApiGetToolServerApiV1ToolserversServersServerIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    getToolServerApiV1ToolserversServersServerIdGet(requestParameters: ToolServersApiGetToolServerApiV1ToolserversServersServerIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerResponse>;

    /**
     * List all tools across all servers.  Args:     current_user: Current authenticated user     tool_server_service: Tool server service  Returns:     List of all available tools across all servers
     * @summary List All Tools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    listAllToolsApiV1ToolserversToolsAllGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<{ [key: string]: any; }>>;

    /**
     * List tool servers with optional filtering.  Args:     request: List request with filter parameters     current_user: Current authenticated user     service: Tool server service  Returns:     List of server responses
     * @summary List Tool Servers
     * @param {ToolServersApiListToolServersApiV1ToolserversServersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    listToolServersApiV1ToolserversServersGet(requestParameters?: ToolServersApiListToolServersApiV1ToolserversServersGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ToolServerResponse>>;

    /**
     * Restart a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
     * @summary Restart Tool Server
     * @param {ToolServersApiRestartToolServerApiV1ToolserversServersServerIdRestartPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    restartToolServerApiV1ToolserversServersServerIdRestartPost(requestParameters: ToolServersApiRestartToolServerApiV1ToolserversServersServerIdRestartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerOperationResponse>;

    /**
     * Start a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
     * @summary Start Tool Server
     * @param {ToolServersApiStartToolServerApiV1ToolserversServersServerIdStartPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    startToolServerApiV1ToolserversServersServerIdStartPost(requestParameters: ToolServersApiStartToolServerApiV1ToolserversServersServerIdStartPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerOperationResponse>;

    /**
     * Stop a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
     * @summary Stop Tool Server
     * @param {ToolServersApiStopToolServerApiV1ToolserversServersServerIdStopPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    stopToolServerApiV1ToolserversServersServerIdStopPost(requestParameters: ToolServersApiStopToolServerApiV1ToolserversServersServerIdStopPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerOperationResponse>;

    /**
     * Test connectivity to an external MCP server.  Args:     server_id: Tool server ID     current_user: Current authenticated user     tool_server_service: Tool server service  Returns:     Connectivity test results
     * @summary Test Server Connectivity
     * @param {ToolServersApiTestServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    testServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPost(requestParameters: ToolServersApiTestServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

    /**
     * Update a tool server.  Args:     server_id: Server ID     update_data: Update data     current_user: Current authenticated user     service: Tool server service  Returns:     Updated server response
     * @summary Update Tool Server
     * @param {ToolServersApiUpdateToolServerApiV1ToolserversServersServerIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApiInterface
     */
    updateToolServerApiV1ToolserversServersServerIdPut(requestParameters: ToolServersApiUpdateToolServerApiV1ToolserversServersServerIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ToolServerResponse>;

}

/**
 * Request parameters for bulkServerOperationApiV1ToolserversServersBulkPost operation in ToolServersApi.
 * @export
 * @interface ToolServersApiBulkServerOperationApiV1ToolserversServersBulkPostRequest
 */
export interface ToolServersApiBulkServerOperationApiV1ToolserversServersBulkPostRequest {
    /**
     * 
     * @type {BulkToolServerOperation}
     * @memberof ToolServersApiBulkServerOperationApiV1ToolserversServersBulkPost
     */
    readonly bulkToolServerOperation: BulkToolServerOperation
}

/**
 * Request parameters for checkServerHealthApiV1ToolserversServersServerIdHealthGet operation in ToolServersApi.
 * @export
 * @interface ToolServersApiCheckServerHealthApiV1ToolserversServersServerIdHealthGetRequest
 */
export interface ToolServersApiCheckServerHealthApiV1ToolserversServersServerIdHealthGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ToolServersApiCheckServerHealthApiV1ToolserversServersServerIdHealthGet
     */
    readonly serverId: string
}

/**
 * Request parameters for createToolServerApiV1ToolserversServersPost operation in ToolServersApi.
 * @export
 * @interface ToolServersApiCreateToolServerApiV1ToolserversServersPostRequest
 */
export interface ToolServersApiCreateToolServerApiV1ToolserversServersPostRequest {
    /**
     * 
     * @type {ToolServerCreate}
     * @memberof ToolServersApiCreateToolServerApiV1ToolserversServersPost
     */
    readonly toolServerCreate: ToolServerCreate
}

/**
 * Request parameters for deleteToolServerApiV1ToolserversServersServerIdDelete operation in ToolServersApi.
 * @export
 * @interface ToolServersApiDeleteToolServerApiV1ToolserversServersServerIdDeleteRequest
 */
export interface ToolServersApiDeleteToolServerApiV1ToolserversServersServerIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ToolServersApiDeleteToolServerApiV1ToolserversServersServerIdDelete
     */
    readonly serverId: string
}

/**
 * Request parameters for disableToolApiV1ToolserversToolsToolIdDisablePost operation in ToolServersApi.
 * @export
 * @interface ToolServersApiDisableToolApiV1ToolserversToolsToolIdDisablePostRequest
 */
export interface ToolServersApiDisableToolApiV1ToolserversToolsToolIdDisablePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ToolServersApiDisableToolApiV1ToolserversToolsToolIdDisablePost
     */
    readonly toolId: string
}

/**
 * Request parameters for disableToolServerApiV1ToolserversServersServerIdDisablePost operation in ToolServersApi.
 * @export
 * @interface ToolServersApiDisableToolServerApiV1ToolserversServersServerIdDisablePostRequest
 */
export interface ToolServersApiDisableToolServerApiV1ToolserversServersServerIdDisablePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ToolServersApiDisableToolServerApiV1ToolserversServersServerIdDisablePost
     */
    readonly serverId: string
}

/**
 * Request parameters for enableToolApiV1ToolserversToolsToolIdEnablePost operation in ToolServersApi.
 * @export
 * @interface ToolServersApiEnableToolApiV1ToolserversToolsToolIdEnablePostRequest
 */
export interface ToolServersApiEnableToolApiV1ToolserversToolsToolIdEnablePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ToolServersApiEnableToolApiV1ToolserversToolsToolIdEnablePost
     */
    readonly toolId: string
}

/**
 * Request parameters for enableToolServerApiV1ToolserversServersServerIdEnablePost operation in ToolServersApi.
 * @export
 * @interface ToolServersApiEnableToolServerApiV1ToolserversServersServerIdEnablePostRequest
 */
export interface ToolServersApiEnableToolServerApiV1ToolserversServersServerIdEnablePostRequest {
    /**
     * 
     * @type {string}
     * @memberof ToolServersApiEnableToolServerApiV1ToolserversServersServerIdEnablePost
     */
    readonly serverId: string
}

/**
 * Request parameters for getServerMetricsApiV1ToolserversServersServerIdMetricsGet operation in ToolServersApi.
 * @export
 * @interface ToolServersApiGetServerMetricsApiV1ToolserversServersServerIdMetricsGetRequest
 */
export interface ToolServersApiGetServerMetricsApiV1ToolserversServersServerIdMetricsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ToolServersApiGetServerMetricsApiV1ToolserversServersServerIdMetricsGet
     */
    readonly serverId: string
}

/**
 * Request parameters for getServerToolsApiV1ToolserversServersServerIdToolsGet operation in ToolServersApi.
 * @export
 * @interface ToolServersApiGetServerToolsApiV1ToolserversServersServerIdToolsGetRequest
 */
export interface ToolServersApiGetServerToolsApiV1ToolserversServersServerIdToolsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ToolServersApiGetServerToolsApiV1ToolserversServersServerIdToolsGet
     */
    readonly serverId: string

    /**
     * 
     * @type {number}
     * @memberof ToolServersApiGetServerToolsApiV1ToolserversServersServerIdToolsGet
     */
    readonly limit?: number

    /**
     * 
     * @type {number}
     * @memberof ToolServersApiGetServerToolsApiV1ToolserversServersServerIdToolsGet
     */
    readonly offset?: number
}

/**
 * Request parameters for getToolServerApiV1ToolserversServersServerIdGet operation in ToolServersApi.
 * @export
 * @interface ToolServersApiGetToolServerApiV1ToolserversServersServerIdGetRequest
 */
export interface ToolServersApiGetToolServerApiV1ToolserversServersServerIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ToolServersApiGetToolServerApiV1ToolserversServersServerIdGet
     */
    readonly serverId: string
}

/**
 * Request parameters for listToolServersApiV1ToolserversServersGet operation in ToolServersApi.
 * @export
 * @interface ToolServersApiListToolServersApiV1ToolserversServersGetRequest
 */
export interface ToolServersApiListToolServersApiV1ToolserversServersGetRequest {
    /**
     * 
     * @type {ServerStatus}
     * @memberof ToolServersApiListToolServersApiV1ToolserversServersGet
     */
    readonly status?: ServerStatus | null

    /**
     * 
     * @type {boolean}
     * @memberof ToolServersApiListToolServersApiV1ToolserversServersGet
     */
    readonly includeBuiltin?: boolean
}

/**
 * Request parameters for restartToolServerApiV1ToolserversServersServerIdRestartPost operation in ToolServersApi.
 * @export
 * @interface ToolServersApiRestartToolServerApiV1ToolserversServersServerIdRestartPostRequest
 */
export interface ToolServersApiRestartToolServerApiV1ToolserversServersServerIdRestartPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ToolServersApiRestartToolServerApiV1ToolserversServersServerIdRestartPost
     */
    readonly serverId: string
}

/**
 * Request parameters for startToolServerApiV1ToolserversServersServerIdStartPost operation in ToolServersApi.
 * @export
 * @interface ToolServersApiStartToolServerApiV1ToolserversServersServerIdStartPostRequest
 */
export interface ToolServersApiStartToolServerApiV1ToolserversServersServerIdStartPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ToolServersApiStartToolServerApiV1ToolserversServersServerIdStartPost
     */
    readonly serverId: string
}

/**
 * Request parameters for stopToolServerApiV1ToolserversServersServerIdStopPost operation in ToolServersApi.
 * @export
 * @interface ToolServersApiStopToolServerApiV1ToolserversServersServerIdStopPostRequest
 */
export interface ToolServersApiStopToolServerApiV1ToolserversServersServerIdStopPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ToolServersApiStopToolServerApiV1ToolserversServersServerIdStopPost
     */
    readonly serverId: string
}

/**
 * Request parameters for testServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPost operation in ToolServersApi.
 * @export
 * @interface ToolServersApiTestServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPostRequest
 */
export interface ToolServersApiTestServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ToolServersApiTestServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPost
     */
    readonly serverId: string
}

/**
 * Request parameters for updateToolServerApiV1ToolserversServersServerIdPut operation in ToolServersApi.
 * @export
 * @interface ToolServersApiUpdateToolServerApiV1ToolserversServersServerIdPutRequest
 */
export interface ToolServersApiUpdateToolServerApiV1ToolserversServersServerIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ToolServersApiUpdateToolServerApiV1ToolserversServersServerIdPut
     */
    readonly serverId: string

    /**
     * 
     * @type {ToolServerUpdate}
     * @memberof ToolServersApiUpdateToolServerApiV1ToolserversServersServerIdPut
     */
    readonly toolServerUpdate: ToolServerUpdate
}

/**
 * ToolServersApi - object-oriented interface
 * @export
 * @class ToolServersApi
 * @extends {BaseAPI}
 */
export class ToolServersApi extends BaseAPI implements ToolServersApiInterface {
    /**
     * Perform bulk operations on multiple servers.  Args:     operation_data: Bulk operation data     current_user: Current authenticated user     service: Tool server service  Returns:     Bulk operation result
     * @summary Bulk Server Operation
     * @param {ToolServersApiBulkServerOperationApiV1ToolserversServersBulkPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public bulkServerOperationApiV1ToolserversServersBulkPost(requestParameters: ToolServersApiBulkServerOperationApiV1ToolserversServersBulkPostRequest, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).bulkServerOperationApiV1ToolserversServersBulkPost(requestParameters.bulkToolServerOperation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Perform health check on a server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Health check result
     * @summary Check Server Health
     * @param {ToolServersApiCheckServerHealthApiV1ToolserversServersServerIdHealthGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public checkServerHealthApiV1ToolserversServersServerIdHealthGet(requestParameters: ToolServersApiCheckServerHealthApiV1ToolserversServersServerIdHealthGetRequest, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).checkServerHealthApiV1ToolserversServersServerIdHealthGet(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new tool server.  Args:     server_data: Server creation data     current_user: Current authenticated user     service: Tool server service  Returns:     Created server response
     * @summary Create Tool Server
     * @param {ToolServersApiCreateToolServerApiV1ToolserversServersPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public createToolServerApiV1ToolserversServersPost(requestParameters: ToolServersApiCreateToolServerApiV1ToolserversServersPostRequest, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).createToolServerApiV1ToolserversServersPost(requestParameters.toolServerCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Success message
     * @summary Delete Tool Server
     * @param {ToolServersApiDeleteToolServerApiV1ToolserversServersServerIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public deleteToolServerApiV1ToolserversServersServerIdDelete(requestParameters: ToolServersApiDeleteToolServerApiV1ToolserversServersServerIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).deleteToolServerApiV1ToolserversServersServerIdDelete(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable a specific tool.  Args:     tool_id: Tool ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
     * @summary Disable Tool
     * @param {ToolServersApiDisableToolApiV1ToolserversToolsToolIdDisablePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public disableToolApiV1ToolserversToolsToolIdDisablePost(requestParameters: ToolServersApiDisableToolApiV1ToolserversToolsToolIdDisablePostRequest, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).disableToolApiV1ToolserversToolsToolIdDisablePost(requestParameters.toolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Disable a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
     * @summary Disable Tool Server
     * @param {ToolServersApiDisableToolServerApiV1ToolserversServersServerIdDisablePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public disableToolServerApiV1ToolserversServersServerIdDisablePost(requestParameters: ToolServersApiDisableToolServerApiV1ToolserversServersServerIdDisablePostRequest, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).disableToolServerApiV1ToolserversServersServerIdDisablePost(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable a specific tool.  Args:     tool_id: Tool ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
     * @summary Enable Tool
     * @param {ToolServersApiEnableToolApiV1ToolserversToolsToolIdEnablePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public enableToolApiV1ToolserversToolsToolIdEnablePost(requestParameters: ToolServersApiEnableToolApiV1ToolserversToolsToolIdEnablePostRequest, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).enableToolApiV1ToolserversToolsToolIdEnablePost(requestParameters.toolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Enable a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
     * @summary Enable Tool Server
     * @param {ToolServersApiEnableToolServerApiV1ToolserversServersServerIdEnablePostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public enableToolServerApiV1ToolserversServersServerIdEnablePost(requestParameters: ToolServersApiEnableToolServerApiV1ToolserversServersServerIdEnablePostRequest, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).enableToolServerApiV1ToolserversServersServerIdEnablePost(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get analytics for a specific server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Server metrics
     * @summary Get Server Metrics
     * @param {ToolServersApiGetServerMetricsApiV1ToolserversServersServerIdMetricsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public getServerMetricsApiV1ToolserversServersServerIdMetricsGet(requestParameters: ToolServersApiGetServerMetricsApiV1ToolserversServersServerIdMetricsGetRequest, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).getServerMetricsApiV1ToolserversServersServerIdMetricsGet(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get tools for a specific server.  Args:     server_id: Server ID     request: Server tools request with pagination     current_user: Current authenticated user     service: Tool server service  Returns:     List of server tools with pagination
     * @summary Get Server Tools
     * @param {ToolServersApiGetServerToolsApiV1ToolserversServersServerIdToolsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public getServerToolsApiV1ToolserversServersServerIdToolsGet(requestParameters: ToolServersApiGetServerToolsApiV1ToolserversServersServerIdToolsGetRequest, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).getServerToolsApiV1ToolserversServersServerIdToolsGet(requestParameters.serverId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a tool server by ID.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Server response
     * @summary Get Tool Server
     * @param {ToolServersApiGetToolServerApiV1ToolserversServersServerIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public getToolServerApiV1ToolserversServersServerIdGet(requestParameters: ToolServersApiGetToolServerApiV1ToolserversServersServerIdGetRequest, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).getToolServerApiV1ToolserversServersServerIdGet(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all tools across all servers.  Args:     current_user: Current authenticated user     tool_server_service: Tool server service  Returns:     List of all available tools across all servers
     * @summary List All Tools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public listAllToolsApiV1ToolserversToolsAllGet(options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).listAllToolsApiV1ToolserversToolsAllGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List tool servers with optional filtering.  Args:     request: List request with filter parameters     current_user: Current authenticated user     service: Tool server service  Returns:     List of server responses
     * @summary List Tool Servers
     * @param {ToolServersApiListToolServersApiV1ToolserversServersGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public listToolServersApiV1ToolserversServersGet(requestParameters: ToolServersApiListToolServersApiV1ToolserversServersGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).listToolServersApiV1ToolserversServersGet(requestParameters.status, requestParameters.includeBuiltin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restart a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
     * @summary Restart Tool Server
     * @param {ToolServersApiRestartToolServerApiV1ToolserversServersServerIdRestartPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public restartToolServerApiV1ToolserversServersServerIdRestartPost(requestParameters: ToolServersApiRestartToolServerApiV1ToolserversServersServerIdRestartPostRequest, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).restartToolServerApiV1ToolserversServersServerIdRestartPost(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Start a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
     * @summary Start Tool Server
     * @param {ToolServersApiStartToolServerApiV1ToolserversServersServerIdStartPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public startToolServerApiV1ToolserversServersServerIdStartPost(requestParameters: ToolServersApiStartToolServerApiV1ToolserversServersServerIdStartPostRequest, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).startToolServerApiV1ToolserversServersServerIdStartPost(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stop a tool server.  Args:     server_id: Server ID     current_user: Current authenticated user     service: Tool server service  Returns:     Operation result
     * @summary Stop Tool Server
     * @param {ToolServersApiStopToolServerApiV1ToolserversServersServerIdStopPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public stopToolServerApiV1ToolserversServersServerIdStopPost(requestParameters: ToolServersApiStopToolServerApiV1ToolserversServersServerIdStopPostRequest, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).stopToolServerApiV1ToolserversServersServerIdStopPost(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test connectivity to an external MCP server.  Args:     server_id: Tool server ID     current_user: Current authenticated user     tool_server_service: Tool server service  Returns:     Connectivity test results
     * @summary Test Server Connectivity
     * @param {ToolServersApiTestServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public testServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPost(requestParameters: ToolServersApiTestServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPostRequest, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).testServerConnectivityApiV1ToolserversServersServerIdTestConnectivityPost(requestParameters.serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a tool server.  Args:     server_id: Server ID     update_data: Update data     current_user: Current authenticated user     service: Tool server service  Returns:     Updated server response
     * @summary Update Tool Server
     * @param {ToolServersApiUpdateToolServerApiV1ToolserversServersServerIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ToolServersApi
     */
    public updateToolServerApiV1ToolserversServersServerIdPut(requestParameters: ToolServersApiUpdateToolServerApiV1ToolserversServersServerIdPutRequest, options?: RawAxiosRequestConfig) {
        return ToolServersApiFp(this.configuration).updateToolServerApiV1ToolserversServersServerIdPut(requestParameters.serverId, requestParameters.toolServerUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



