/* tslint:disable */
/* eslint-disable */
/**
 * Chatter API
 * # Advanced AI Chatbot Backend API Platform  A comprehensive Python-based backend API platform for building advanced AI chatbots, implemented with FastAPI, LangChain, LangGraph, Postgres, PGVector, and SQLAlchemy.  ## Features  ### Core API Features - **RESTful API** with FastAPI and OpenAPI/Swagger documentation - **Async-first architecture** with uvloop and hypercorn - **Streaming responses** for real-time LLM output - **Authentication** with JWT/OAuth2 and session management - **Rate limiting** and security validations - **Health checks** with `/healthz` and `/readyz` endpoints - **API versioning** with modular router architecture  ### LLM & AI Features - **LangChain integration** for LLM orchestration and chain management - **LangGraph workflows** for advanced conversation logic - **Multiple LLM providers** with pluggable architecture (OpenAI, Anthropic, etc.) - **Prompt management** with storage and versioning - **Tool calling** with MCP (Model Context Protocol) integration - **Multi-turn context** management and conversation history - **Profile management** for LLM parameters (temperature, top_k, etc.)  ### Vector Store & Knowledge Base - **Multiple vector stores** (PGVector, Pinecone, Qdrant, ChromaDB) - **Document processing** with unstructured data support - **Semantic search** and retrieval-augmented generation (RAG) - **Chunking strategies** for optimal retrieval - **Embedding management** with multiple providers  ### Data & Analytics - **Comprehensive analytics** for conversations, usage, and performance - **Cost tracking** and token usage monitoring - **User behavior analytics** and system health metrics - **Export capabilities** for reporting and analysis  ## Authentication  All API endpoints (except health checks and documentation) require authentication. Use the `/api/v1/auth/login` endpoint to obtain access tokens.  ## Rate Limiting  API requests are rate-limited. Check response headers for current limits.  ## SDK  A Python SDK is available for easy integration. See the SDK documentation for details.  ## Support  - GitHub: https://github.com/lllucius/chatter - Documentation: https://github.com/lllucius/chatter#readme - Issues: https://github.com/lllucius/chatter/issues
 *
 * The version of the OpenAPI document: 0.1.0
 * Contact: support@chatter.ai
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { AvailableToolsResponse } from '../models';
// @ts-ignore
import type { ChatRequest } from '../models';
// @ts-ignore
import type { ChatResponse } from '../models';
// @ts-ignore
import type { ConversationCreate } from '../models';
// @ts-ignore
import type { ConversationDeleteResponse } from '../models';
// @ts-ignore
import type { ConversationResponse } from '../models';
// @ts-ignore
import type { ConversationSearchResponse } from '../models';
// @ts-ignore
import type { ConversationStatus } from '../models';
// @ts-ignore
import type { ConversationUpdate } from '../models';
// @ts-ignore
import type { ConversationWithMessages } from '../models';
// @ts-ignore
import type { HTTPValidationError } from '../models';
// @ts-ignore
import type { McpStatusResponse } from '../models';
// @ts-ignore
import type { MessageCreate } from '../models';
// @ts-ignore
import type { MessageResponse } from '../models';
/**
 * ChatApi - axios parameter creator
 * @export
 */
export const ChatApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a new message to existing conversation.
         * @summary Add Message To Conversation
         * @param {string} conversationId 
         * @param {MessageCreate} messageCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost: async (conversationId: string, messageCreate: MessageCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost', 'conversationId', conversationId)
            // verify required parameter 'messageCreate' is not null or undefined
            assertParamExists('addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost', 'messageCreate', messageCreate)
            const localVarPath = `/api/v1/chat/conversations/{conversation_id}/messages`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Single chat endpoint supporting plain, rag, tools, and full workflows.  - If chat_request.stream is True, returns SSE stream. - Otherwise returns ChatResponse JSON.
         * @summary Chat
         * @param {ChatRequest} chatRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatApiV1ChatChatPost: async (chatRequest: ChatRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'chatRequest' is not null or undefined
            assertParamExists('chatApiV1ChatChatPost', 'chatRequest', chatRequest)
            const localVarPath = `/api/v1/chat/chat`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(chatRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new conversation.  Args:     conversation_data: Conversation creation data     current_user: Current authenticated user     chat_service: Chat service  Returns:     Created conversation
         * @summary Create Conversation
         * @param {ConversationCreate} conversationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationApiV1ChatConversationsPost: async (conversationCreate: ConversationCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationCreate' is not null or undefined
            assertParamExists('createConversationApiV1ChatConversationsPost', 'conversationCreate', conversationCreate)
            const localVarPath = `/api/v1/chat/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conversationCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete conversation.
         * @summary Delete Conversation
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationApiV1ChatConversationsConversationIdDelete: async (conversationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('deleteConversationApiV1ChatConversationsConversationIdDelete', 'conversationId', conversationId)
            const localVarPath = `/api/v1/chat/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a message from conversation.
         * @summary Delete Message
         * @param {string} conversationId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete: async (conversationId: string, messageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete', 'conversationId', conversationId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete', 'messageId', messageId)
            const localVarPath = `/api/v1/chat/conversations/{conversation_id}/messages/{message_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)))
                .replace(`{${"message_id"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of available MCP tools.
         * @summary Get Available Tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableToolsApiV1ChatToolsAvailableGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/chat/tools/available`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get conversation details with messages.
         * @summary Get Conversation
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationApiV1ChatConversationsConversationIdGet: async (conversationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('getConversationApiV1ChatConversationsConversationIdGet', 'conversationId', conversationId)
            const localVarPath = `/api/v1/chat/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get conversation messages.
         * @summary Get Conversation Messages
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet: async (conversationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet', 'conversationId', conversationId)
            const localVarPath = `/api/v1/chat/conversations/{conversation_id}/messages`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get MCP service status.
         * @summary Get Mcp Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMcpStatusApiV1ChatMcpStatusGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/chat/mcp/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List user\'s conversations.  Note: Filters may be ignored if not supported by the service implementation.
         * @summary List Conversations
         * @param {string | null} [query] Search query
         * @param {ConversationStatus | null} [status] Filter by status
         * @param {number} [limit] Maximum number of results
         * @param {number} [offset] Number of results to skip
         * @param {string} [sortBy] Sort field
         * @param {string} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsApiV1ChatConversationsGet: async (query?: string | null, status?: ConversationStatus | null, limit?: number, offset?: number, sortBy?: string, sortOrder?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/chat/conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sort_order'] = sortOrder;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update conversation.
         * @summary Update Conversation
         * @param {string} conversationId 
         * @param {ConversationUpdate} conversationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationApiV1ChatConversationsConversationIdPut: async (conversationId: string, conversationUpdate: ConversationUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationId' is not null or undefined
            assertParamExists('updateConversationApiV1ChatConversationsConversationIdPut', 'conversationId', conversationId)
            // verify required parameter 'conversationUpdate' is not null or undefined
            assertParamExists('updateConversationApiV1ChatConversationsConversationIdPut', 'conversationUpdate', conversationUpdate)
            const localVarPath = `/api/v1/chat/conversations/{conversation_id}`
                .replace(`{${"conversation_id"}}`, encodeURIComponent(String(conversationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication HTTPBearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conversationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChatApi - functional programming interface
 * @export
 */
export const ChatApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChatApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a new message to existing conversation.
         * @summary Add Message To Conversation
         * @param {string} conversationId 
         * @param {MessageCreate} messageCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost(conversationId: string, messageCreate: MessageCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost(conversationId, messageCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Single chat endpoint supporting plain, rag, tools, and full workflows.  - If chat_request.stream is True, returns SSE stream. - Otherwise returns ChatResponse JSON.
         * @summary Chat
         * @param {ChatRequest} chatRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async chatApiV1ChatChatPost(chatRequest: ChatRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChatResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.chatApiV1ChatChatPost(chatRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.chatApiV1ChatChatPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new conversation.  Args:     conversation_data: Conversation creation data     current_user: Current authenticated user     chat_service: Chat service  Returns:     Created conversation
         * @summary Create Conversation
         * @param {ConversationCreate} conversationCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversationApiV1ChatConversationsPost(conversationCreate: ConversationCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConversationApiV1ChatConversationsPost(conversationCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.createConversationApiV1ChatConversationsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete conversation.
         * @summary Delete Conversation
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversationApiV1ChatConversationsConversationIdDelete(conversationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationDeleteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConversationApiV1ChatConversationsConversationIdDelete(conversationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.deleteConversationApiV1ChatConversationsConversationIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a message from conversation.
         * @summary Delete Message
         * @param {string} conversationId 
         * @param {string} messageId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete(conversationId: string, messageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete(conversationId, messageId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of available MCP tools.
         * @summary Get Available Tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAvailableToolsApiV1ChatToolsAvailableGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailableToolsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAvailableToolsApiV1ChatToolsAvailableGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.getAvailableToolsApiV1ChatToolsAvailableGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get conversation details with messages.
         * @summary Get Conversation
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationApiV1ChatConversationsConversationIdGet(conversationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationWithMessages>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversationApiV1ChatConversationsConversationIdGet(conversationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.getConversationApiV1ChatConversationsConversationIdGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get conversation messages.
         * @summary Get Conversation Messages
         * @param {string} conversationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet(conversationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet(conversationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get MCP service status.
         * @summary Get Mcp Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMcpStatusApiV1ChatMcpStatusGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<McpStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMcpStatusApiV1ChatMcpStatusGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.getMcpStatusApiV1ChatMcpStatusGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List user\'s conversations.  Note: Filters may be ignored if not supported by the service implementation.
         * @summary List Conversations
         * @param {string | null} [query] Search query
         * @param {ConversationStatus | null} [status] Filter by status
         * @param {number} [limit] Maximum number of results
         * @param {number} [offset] Number of results to skip
         * @param {string} [sortBy] Sort field
         * @param {string} [sortOrder] Sort order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConversationsApiV1ChatConversationsGet(query?: string | null, status?: ConversationStatus | null, limit?: number, offset?: number, sortBy?: string, sortOrder?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationSearchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConversationsApiV1ChatConversationsGet(query, status, limit, offset, sortBy, sortOrder, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.listConversationsApiV1ChatConversationsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update conversation.
         * @summary Update Conversation
         * @param {string} conversationId 
         * @param {ConversationUpdate} conversationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConversationApiV1ChatConversationsConversationIdPut(conversationId: string, conversationUpdate: ConversationUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConversationApiV1ChatConversationsConversationIdPut(conversationId, conversationUpdate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ChatApi.updateConversationApiV1ChatConversationsConversationIdPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ChatApi - factory interface
 * @export
 */
export const ChatApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChatApiFp(configuration)
    return {
        /**
         * Add a new message to existing conversation.
         * @summary Add Message To Conversation
         * @param {ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost(requestParameters: ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse> {
            return localVarFp.addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost(requestParameters.conversationId, requestParameters.messageCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Single chat endpoint supporting plain, rag, tools, and full workflows.  - If chat_request.stream is True, returns SSE stream. - Otherwise returns ChatResponse JSON.
         * @summary Chat
         * @param {ChatApiChatApiV1ChatChatPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chatApiV1ChatChatPost(requestParameters: ChatApiChatApiV1ChatChatPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatResponse> {
            return localVarFp.chatApiV1ChatChatPost(requestParameters.chatRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new conversation.  Args:     conversation_data: Conversation creation data     current_user: Current authenticated user     chat_service: Chat service  Returns:     Created conversation
         * @summary Create Conversation
         * @param {ChatApiCreateConversationApiV1ChatConversationsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversationApiV1ChatConversationsPost(requestParameters: ChatApiCreateConversationApiV1ChatConversationsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationResponse> {
            return localVarFp.createConversationApiV1ChatConversationsPost(requestParameters.conversationCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete conversation.
         * @summary Delete Conversation
         * @param {ChatApiDeleteConversationApiV1ChatConversationsConversationIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversationApiV1ChatConversationsConversationIdDelete(requestParameters: ChatApiDeleteConversationApiV1ChatConversationsConversationIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationDeleteResponse> {
            return localVarFp.deleteConversationApiV1ChatConversationsConversationIdDelete(requestParameters.conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a message from conversation.
         * @summary Delete Message
         * @param {ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete(requestParameters: ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete(requestParameters.conversationId, requestParameters.messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of available MCP tools.
         * @summary Get Available Tools
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableToolsApiV1ChatToolsAvailableGet(options?: RawAxiosRequestConfig): AxiosPromise<AvailableToolsResponse> {
            return localVarFp.getAvailableToolsApiV1ChatToolsAvailableGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get conversation details with messages.
         * @summary Get Conversation
         * @param {ChatApiGetConversationApiV1ChatConversationsConversationIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationApiV1ChatConversationsConversationIdGet(requestParameters: ChatApiGetConversationApiV1ChatConversationsConversationIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationWithMessages> {
            return localVarFp.getConversationApiV1ChatConversationsConversationIdGet(requestParameters.conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get conversation messages.
         * @summary Get Conversation Messages
         * @param {ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet(requestParameters: ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MessageResponse>> {
            return localVarFp.getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet(requestParameters.conversationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get MCP service status.
         * @summary Get Mcp Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMcpStatusApiV1ChatMcpStatusGet(options?: RawAxiosRequestConfig): AxiosPromise<McpStatusResponse> {
            return localVarFp.getMcpStatusApiV1ChatMcpStatusGet(options).then((request) => request(axios, basePath));
        },
        /**
         * List user\'s conversations.  Note: Filters may be ignored if not supported by the service implementation.
         * @summary List Conversations
         * @param {ChatApiListConversationsApiV1ChatConversationsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConversationsApiV1ChatConversationsGet(requestParameters: ChatApiListConversationsApiV1ChatConversationsGetRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ConversationSearchResponse> {
            return localVarFp.listConversationsApiV1ChatConversationsGet(requestParameters.query, requestParameters.status, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(axios, basePath));
        },
        /**
         * Update conversation.
         * @summary Update Conversation
         * @param {ChatApiUpdateConversationApiV1ChatConversationsConversationIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversationApiV1ChatConversationsConversationIdPut(requestParameters: ChatApiUpdateConversationApiV1ChatConversationsConversationIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationResponse> {
            return localVarFp.updateConversationApiV1ChatConversationsConversationIdPut(requestParameters.conversationId, requestParameters.conversationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChatApi - interface
 * @export
 * @interface ChatApi
 */
export interface ChatApiInterface {
    /**
     * Add a new message to existing conversation.
     * @summary Add Message To Conversation
     * @param {ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost(requestParameters: ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<MessageResponse>;

    /**
     * Single chat endpoint supporting plain, rag, tools, and full workflows.  - If chat_request.stream is True, returns SSE stream. - Otherwise returns ChatResponse JSON.
     * @summary Chat
     * @param {ChatApiChatApiV1ChatChatPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    chatApiV1ChatChatPost(requestParameters: ChatApiChatApiV1ChatChatPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ChatResponse>;

    /**
     * Create a new conversation.  Args:     conversation_data: Conversation creation data     current_user: Current authenticated user     chat_service: Chat service  Returns:     Created conversation
     * @summary Create Conversation
     * @param {ChatApiCreateConversationApiV1ChatConversationsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    createConversationApiV1ChatConversationsPost(requestParameters: ChatApiCreateConversationApiV1ChatConversationsPostRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationResponse>;

    /**
     * Delete conversation.
     * @summary Delete Conversation
     * @param {ChatApiDeleteConversationApiV1ChatConversationsConversationIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    deleteConversationApiV1ChatConversationsConversationIdDelete(requestParameters: ChatApiDeleteConversationApiV1ChatConversationsConversationIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationDeleteResponse>;

    /**
     * Delete a message from conversation.
     * @summary Delete Message
     * @param {ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete(requestParameters: ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any; }>;

    /**
     * Get list of available MCP tools.
     * @summary Get Available Tools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    getAvailableToolsApiV1ChatToolsAvailableGet(options?: RawAxiosRequestConfig): AxiosPromise<AvailableToolsResponse>;

    /**
     * Get conversation details with messages.
     * @summary Get Conversation
     * @param {ChatApiGetConversationApiV1ChatConversationsConversationIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    getConversationApiV1ChatConversationsConversationIdGet(requestParameters: ChatApiGetConversationApiV1ChatConversationsConversationIdGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationWithMessages>;

    /**
     * Get conversation messages.
     * @summary Get Conversation Messages
     * @param {ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet(requestParameters: ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<MessageResponse>>;

    /**
     * Get MCP service status.
     * @summary Get Mcp Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    getMcpStatusApiV1ChatMcpStatusGet(options?: RawAxiosRequestConfig): AxiosPromise<McpStatusResponse>;

    /**
     * List user\'s conversations.  Note: Filters may be ignored if not supported by the service implementation.
     * @summary List Conversations
     * @param {ChatApiListConversationsApiV1ChatConversationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    listConversationsApiV1ChatConversationsGet(requestParameters?: ChatApiListConversationsApiV1ChatConversationsGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationSearchResponse>;

    /**
     * Update conversation.
     * @summary Update Conversation
     * @param {ChatApiUpdateConversationApiV1ChatConversationsConversationIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    updateConversationApiV1ChatConversationsConversationIdPut(requestParameters: ChatApiUpdateConversationApiV1ChatConversationsConversationIdPutRequest, options?: RawAxiosRequestConfig): AxiosPromise<ConversationResponse>;

}

/**
 * Request parameters for addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost operation in ChatApi.
 * @export
 * @interface ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPostRequest
 */
export interface ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPost
     */
    readonly conversationId: string

    /**
     * 
     * @type {MessageCreate}
     * @memberof ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPost
     */
    readonly messageCreate: MessageCreate
}

/**
 * Request parameters for chatApiV1ChatChatPost operation in ChatApi.
 * @export
 * @interface ChatApiChatApiV1ChatChatPostRequest
 */
export interface ChatApiChatApiV1ChatChatPostRequest {
    /**
     * 
     * @type {ChatRequest}
     * @memberof ChatApiChatApiV1ChatChatPost
     */
    readonly chatRequest: ChatRequest
}

/**
 * Request parameters for createConversationApiV1ChatConversationsPost operation in ChatApi.
 * @export
 * @interface ChatApiCreateConversationApiV1ChatConversationsPostRequest
 */
export interface ChatApiCreateConversationApiV1ChatConversationsPostRequest {
    /**
     * 
     * @type {ConversationCreate}
     * @memberof ChatApiCreateConversationApiV1ChatConversationsPost
     */
    readonly conversationCreate: ConversationCreate
}

/**
 * Request parameters for deleteConversationApiV1ChatConversationsConversationIdDelete operation in ChatApi.
 * @export
 * @interface ChatApiDeleteConversationApiV1ChatConversationsConversationIdDeleteRequest
 */
export interface ChatApiDeleteConversationApiV1ChatConversationsConversationIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatApiDeleteConversationApiV1ChatConversationsConversationIdDelete
     */
    readonly conversationId: string
}

/**
 * Request parameters for deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete operation in ChatApi.
 * @export
 * @interface ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest
 */
export interface ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete
     */
    readonly conversationId: string

    /**
     * 
     * @type {string}
     * @memberof ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete
     */
    readonly messageId: string
}

/**
 * Request parameters for getConversationApiV1ChatConversationsConversationIdGet operation in ChatApi.
 * @export
 * @interface ChatApiGetConversationApiV1ChatConversationsConversationIdGetRequest
 */
export interface ChatApiGetConversationApiV1ChatConversationsConversationIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatApiGetConversationApiV1ChatConversationsConversationIdGet
     */
    readonly conversationId: string
}

/**
 * Request parameters for getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet operation in ChatApi.
 * @export
 * @interface ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest
 */
export interface ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGet
     */
    readonly conversationId: string
}

/**
 * Request parameters for listConversationsApiV1ChatConversationsGet operation in ChatApi.
 * @export
 * @interface ChatApiListConversationsApiV1ChatConversationsGetRequest
 */
export interface ChatApiListConversationsApiV1ChatConversationsGetRequest {
    /**
     * Search query
     * @type {string}
     * @memberof ChatApiListConversationsApiV1ChatConversationsGet
     */
    readonly query?: string | null

    /**
     * Filter by status
     * @type {ConversationStatus}
     * @memberof ChatApiListConversationsApiV1ChatConversationsGet
     */
    readonly status?: ConversationStatus | null

    /**
     * Maximum number of results
     * @type {number}
     * @memberof ChatApiListConversationsApiV1ChatConversationsGet
     */
    readonly limit?: number

    /**
     * Number of results to skip
     * @type {number}
     * @memberof ChatApiListConversationsApiV1ChatConversationsGet
     */
    readonly offset?: number

    /**
     * Sort field
     * @type {string}
     * @memberof ChatApiListConversationsApiV1ChatConversationsGet
     */
    readonly sortBy?: string

    /**
     * Sort order
     * @type {string}
     * @memberof ChatApiListConversationsApiV1ChatConversationsGet
     */
    readonly sortOrder?: string
}

/**
 * Request parameters for updateConversationApiV1ChatConversationsConversationIdPut operation in ChatApi.
 * @export
 * @interface ChatApiUpdateConversationApiV1ChatConversationsConversationIdPutRequest
 */
export interface ChatApiUpdateConversationApiV1ChatConversationsConversationIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof ChatApiUpdateConversationApiV1ChatConversationsConversationIdPut
     */
    readonly conversationId: string

    /**
     * 
     * @type {ConversationUpdate}
     * @memberof ChatApiUpdateConversationApiV1ChatConversationsConversationIdPut
     */
    readonly conversationUpdate: ConversationUpdate
}

/**
 * ChatApi - object-oriented interface
 * @export
 * @class ChatApi
 * @extends {BaseAPI}
 */
export class ChatApi extends BaseAPI implements ChatApiInterface {
    /**
     * Add a new message to existing conversation.
     * @summary Add Message To Conversation
     * @param {ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost(requestParameters: ChatApiAddMessageToConversationApiV1ChatConversationsConversationIdMessagesPostRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).addMessageToConversationApiV1ChatConversationsConversationIdMessagesPost(requestParameters.conversationId, requestParameters.messageCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Single chat endpoint supporting plain, rag, tools, and full workflows.  - If chat_request.stream is True, returns SSE stream. - Otherwise returns ChatResponse JSON.
     * @summary Chat
     * @param {ChatApiChatApiV1ChatChatPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public chatApiV1ChatChatPost(requestParameters: ChatApiChatApiV1ChatChatPostRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).chatApiV1ChatChatPost(requestParameters.chatRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new conversation.  Args:     conversation_data: Conversation creation data     current_user: Current authenticated user     chat_service: Chat service  Returns:     Created conversation
     * @summary Create Conversation
     * @param {ChatApiCreateConversationApiV1ChatConversationsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public createConversationApiV1ChatConversationsPost(requestParameters: ChatApiCreateConversationApiV1ChatConversationsPostRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).createConversationApiV1ChatConversationsPost(requestParameters.conversationCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete conversation.
     * @summary Delete Conversation
     * @param {ChatApiDeleteConversationApiV1ChatConversationsConversationIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public deleteConversationApiV1ChatConversationsConversationIdDelete(requestParameters: ChatApiDeleteConversationApiV1ChatConversationsConversationIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).deleteConversationApiV1ChatConversationsConversationIdDelete(requestParameters.conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a message from conversation.
     * @summary Delete Message
     * @param {ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete(requestParameters: ChatApiDeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete(requestParameters.conversationId, requestParameters.messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of available MCP tools.
     * @summary Get Available Tools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public getAvailableToolsApiV1ChatToolsAvailableGet(options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).getAvailableToolsApiV1ChatToolsAvailableGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get conversation details with messages.
     * @summary Get Conversation
     * @param {ChatApiGetConversationApiV1ChatConversationsConversationIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public getConversationApiV1ChatConversationsConversationIdGet(requestParameters: ChatApiGetConversationApiV1ChatConversationsConversationIdGetRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).getConversationApiV1ChatConversationsConversationIdGet(requestParameters.conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get conversation messages.
     * @summary Get Conversation Messages
     * @param {ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet(requestParameters: ChatApiGetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet(requestParameters.conversationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get MCP service status.
     * @summary Get Mcp Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public getMcpStatusApiV1ChatMcpStatusGet(options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).getMcpStatusApiV1ChatMcpStatusGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List user\'s conversations.  Note: Filters may be ignored if not supported by the service implementation.
     * @summary List Conversations
     * @param {ChatApiListConversationsApiV1ChatConversationsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public listConversationsApiV1ChatConversationsGet(requestParameters: ChatApiListConversationsApiV1ChatConversationsGetRequest = {}, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).listConversationsApiV1ChatConversationsGet(requestParameters.query, requestParameters.status, requestParameters.limit, requestParameters.offset, requestParameters.sortBy, requestParameters.sortOrder, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update conversation.
     * @summary Update Conversation
     * @param {ChatApiUpdateConversationApiV1ChatConversationsConversationIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApi
     */
    public updateConversationApiV1ChatConversationsConversationIdPut(requestParameters: ChatApiUpdateConversationApiV1ChatConversationsConversationIdPutRequest, options?: RawAxiosRequestConfig) {
        return ChatApiFp(this.configuration).updateConversationApiV1ChatConversationsConversationIdPut(requestParameters.conversationId, requestParameters.conversationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}

