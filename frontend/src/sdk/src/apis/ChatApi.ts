/* tslint:disable */
/* eslint-disable */
/**
 * Chatter API
 * Advanced AI Chatbot Backend API Platform
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AvailableToolsResponse,
  ChatRequest,
  ChatResponse,
  ChatResponse1,
  ChatterSchemasChatWorkflowTemplatesResponse,
  ConversationCreate,
  ConversationDeleteResponse,
  ConversationResponse,
  ConversationSearchResponse,
  ConversationUpdate,
  ConversationWithMessages,
  HTTPValidationError,
  McpStatusResponse,
  MessageDeleteResponse,
  MessageResponse,
  PerformanceStatsResponse,
} from '../models/index';
import {
    AvailableToolsResponseFromJSON,
    AvailableToolsResponseToJSON,
    ChatRequestFromJSON,
    ChatRequestToJSON,
    ChatResponseFromJSON,
    ChatResponseToJSON,
    ChatResponse1FromJSON,
    ChatResponse1ToJSON,
    ChatterSchemasChatWorkflowTemplatesResponseFromJSON,
    ChatterSchemasChatWorkflowTemplatesResponseToJSON,
    ConversationCreateFromJSON,
    ConversationCreateToJSON,
    ConversationDeleteResponseFromJSON,
    ConversationDeleteResponseToJSON,
    ConversationResponseFromJSON,
    ConversationResponseToJSON,
    ConversationSearchResponseFromJSON,
    ConversationSearchResponseToJSON,
    ConversationUpdateFromJSON,
    ConversationUpdateToJSON,
    ConversationWithMessagesFromJSON,
    ConversationWithMessagesToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    McpStatusResponseFromJSON,
    McpStatusResponseToJSON,
    MessageDeleteResponseFromJSON,
    MessageDeleteResponseToJSON,
    MessageResponseFromJSON,
    MessageResponseToJSON,
    PerformanceStatsResponseFromJSON,
    PerformanceStatsResponseToJSON,
} from '../models/index';

export interface ChatApiV1ChatChatPostRequest {
    chatRequest: ChatRequest;
}

export interface ChatWithTemplateApiV1ChatTemplateTemplateNamePostRequest {
    templateName: string;
    chatRequest: ChatRequest;
}

export interface CreateConversationApiV1ChatConversationsPostRequest {
    conversationCreate: ConversationCreate;
}

export interface DeleteConversationApiV1ChatConversationsConversationIdDeleteRequest {
    conversationId: string;
}

export interface DeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest {
    conversationId: string;
    messageId: string;
}

export interface GetConversationApiV1ChatConversationsConversationIdGetRequest {
    conversationId: string;
    includeMessages?: boolean;
}

export interface GetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest {
    conversationId: string;
    limit?: number;
    offset?: number;
}

export interface ListConversationsApiV1ChatConversationsGetRequest {
    limit?: number;
    offset?: number;
}

export interface UpdateConversationApiV1ChatConversationsConversationIdPutRequest {
    conversationId: string;
    conversationUpdate: ConversationUpdate;
}

/**
 * ChatApi - interface
 * 
 * @export
 * @interface ChatApiInterface
 */
export interface ChatApiInterface {
    /**
     * Unified chat endpoint supporting all workflow types with optional streaming. ## Workflow Types  This endpoint supports multiple workflow types through the `workflow` parameter:  ### Plain Chat (`plain`) Basic conversation without tools or retrieval. ```json {     \"message\": \"Hello, how are you?\",     \"workflow\": \"plain\" } ```  ### RAG Workflow (`rag`) Retrieval-Augmented Generation with document search. ```json {     \"message\": \"What are the latest sales figures?\",     \"workflow\": \"rag\",     \"enable_retrieval\": true } ```  ### Tools Workflow (`tools`) Function calling with available tools. ```json {     \"message\": \"Calculate the square root of 144\",     \"workflow\": \"tools\" } ```  ### Full Workflow (`full`) Combination of RAG and tools for complex tasks. ```json {     \"message\": \"Find recent customer feedback and create a summary report\",     \"workflow\": \"full\",     \"enable_retrieval\": true } ```  ## Streaming  Set `stream: true` to receive real-time responses: ```json {     \"message\": \"Tell me a story\",     \"workflow\": \"plain\",     \"stream\": true } ```  Streaming responses use Server-Sent Events (SSE) format with event types: - `token`: Content chunks - `node_start`: Workflow node started - `node_complete`: Workflow node completed - `usage`: Final usage statistics - `error`: Error occurred  ## Templates  Use pre-configured templates for common scenarios: ```json {     \"message\": \"I need help with my order\",     \"workflow_template\": \"customer_support\" } ```  Available templates: - `customer_support`: Customer service with knowledge base - `code_assistant`: Programming help with code tools - `research_assistant`: Document research and analysis - `general_chat`: General conversation - `document_qa`: Document question answering - `data_analyst`: Data analysis with computation tools 
     * @summary Chat
     * @param {ChatRequest} chatRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    chatApiV1ChatChatPostRaw(requestParameters: ChatApiV1ChatChatPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatResponse1>>;

    /**
     * Unified chat endpoint supporting all workflow types with optional streaming. ## Workflow Types  This endpoint supports multiple workflow types through the `workflow` parameter:  ### Plain Chat (`plain`) Basic conversation without tools or retrieval. ```json {     \"message\": \"Hello, how are you?\",     \"workflow\": \"plain\" } ```  ### RAG Workflow (`rag`) Retrieval-Augmented Generation with document search. ```json {     \"message\": \"What are the latest sales figures?\",     \"workflow\": \"rag\",     \"enable_retrieval\": true } ```  ### Tools Workflow (`tools`) Function calling with available tools. ```json {     \"message\": \"Calculate the square root of 144\",     \"workflow\": \"tools\" } ```  ### Full Workflow (`full`) Combination of RAG and tools for complex tasks. ```json {     \"message\": \"Find recent customer feedback and create a summary report\",     \"workflow\": \"full\",     \"enable_retrieval\": true } ```  ## Streaming  Set `stream: true` to receive real-time responses: ```json {     \"message\": \"Tell me a story\",     \"workflow\": \"plain\",     \"stream\": true } ```  Streaming responses use Server-Sent Events (SSE) format with event types: - `token`: Content chunks - `node_start`: Workflow node started - `node_complete`: Workflow node completed - `usage`: Final usage statistics - `error`: Error occurred  ## Templates  Use pre-configured templates for common scenarios: ```json {     \"message\": \"I need help with my order\",     \"workflow_template\": \"customer_support\" } ```  Available templates: - `customer_support`: Customer service with knowledge base - `code_assistant`: Programming help with code tools - `research_assistant`: Document research and analysis - `general_chat`: General conversation - `document_qa`: Document question answering - `data_analyst`: Data analysis with computation tools 
     * Chat
     */
    chatApiV1ChatChatPost(requestParameters: ChatApiV1ChatChatPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatResponse1>;

    /**
     * Chat using a specific workflow template. ## Workflow Types  This endpoint supports multiple workflow types through the `workflow` parameter:  ### Plain Chat (`plain`) Basic conversation without tools or retrieval. ```json {     \"message\": \"Hello, how are you?\",     \"workflow\": \"plain\" } ```  ### RAG Workflow (`rag`) Retrieval-Augmented Generation with document search. ```json {     \"message\": \"What are the latest sales figures?\",     \"workflow\": \"rag\",     \"enable_retrieval\": true } ```  ### Tools Workflow (`tools`) Function calling with available tools. ```json {     \"message\": \"Calculate the square root of 144\",     \"workflow\": \"tools\" } ```  ### Full Workflow (`full`) Combination of RAG and tools for complex tasks. ```json {     \"message\": \"Find recent customer feedback and create a summary report\",     \"workflow\": \"full\",     \"enable_retrieval\": true } ```  ## Streaming  Set `stream: true` to receive real-time responses: ```json {     \"message\": \"Tell me a story\",     \"workflow\": \"plain\",     \"stream\": true } ```  Streaming responses use Server-Sent Events (SSE) format with event types: - `token`: Content chunks - `node_start`: Workflow node started - `node_complete`: Workflow node completed - `usage`: Final usage statistics - `error`: Error occurred  ## Templates  Use pre-configured templates for common scenarios: ```json {     \"message\": \"I need help with my order\",     \"workflow_template\": \"customer_support\" } ```  Available templates: - `customer_support`: Customer service with knowledge base - `code_assistant`: Programming help with code tools - `research_assistant`: Document research and analysis - `general_chat`: General conversation - `document_qa`: Document question answering - `data_analyst`: Data analysis with computation tools 
     * @summary Chat With Template
     * @param {string} templateName 
     * @param {ChatRequest} chatRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    chatWithTemplateApiV1ChatTemplateTemplateNamePostRaw(requestParameters: ChatWithTemplateApiV1ChatTemplateTemplateNamePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatResponse>>;

    /**
     * Chat using a specific workflow template. ## Workflow Types  This endpoint supports multiple workflow types through the `workflow` parameter:  ### Plain Chat (`plain`) Basic conversation without tools or retrieval. ```json {     \"message\": \"Hello, how are you?\",     \"workflow\": \"plain\" } ```  ### RAG Workflow (`rag`) Retrieval-Augmented Generation with document search. ```json {     \"message\": \"What are the latest sales figures?\",     \"workflow\": \"rag\",     \"enable_retrieval\": true } ```  ### Tools Workflow (`tools`) Function calling with available tools. ```json {     \"message\": \"Calculate the square root of 144\",     \"workflow\": \"tools\" } ```  ### Full Workflow (`full`) Combination of RAG and tools for complex tasks. ```json {     \"message\": \"Find recent customer feedback and create a summary report\",     \"workflow\": \"full\",     \"enable_retrieval\": true } ```  ## Streaming  Set `stream: true` to receive real-time responses: ```json {     \"message\": \"Tell me a story\",     \"workflow\": \"plain\",     \"stream\": true } ```  Streaming responses use Server-Sent Events (SSE) format with event types: - `token`: Content chunks - `node_start`: Workflow node started - `node_complete`: Workflow node completed - `usage`: Final usage statistics - `error`: Error occurred  ## Templates  Use pre-configured templates for common scenarios: ```json {     \"message\": \"I need help with my order\",     \"workflow_template\": \"customer_support\" } ```  Available templates: - `customer_support`: Customer service with knowledge base - `code_assistant`: Programming help with code tools - `research_assistant`: Document research and analysis - `general_chat`: General conversation - `document_qa`: Document question answering - `data_analyst`: Data analysis with computation tools 
     * Chat With Template
     */
    chatWithTemplateApiV1ChatTemplateTemplateNamePost(requestParameters: ChatWithTemplateApiV1ChatTemplateTemplateNamePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatResponse>;

    /**
     * Create a new conversation.  Create a new conversation with specified configuration ## Workflow Types  This endpoint supports multiple workflow types through the `workflow` parameter:  ### Plain Chat (`plain`) Basic conversation without tools or retrieval. ```json {     \"message\": \"Hello, how are you?\",     \"workflow\": \"plain\" } ```  ### RAG Workflow (`rag`) Retrieval-Augmented Generation with document search. ```json {     \"message\": \"What are the latest sales figures?\",     \"workflow\": \"rag\",     \"enable_retrieval\": true } ```  ### Tools Workflow (`tools`) Function calling with available tools. ```json {     \"message\": \"Calculate the square root of 144\",     \"workflow\": \"tools\" } ```  ### Full Workflow (`full`) Combination of RAG and tools for complex tasks. ```json {     \"message\": \"Find recent customer feedback and create a summary report\",     \"workflow\": \"full\",     \"enable_retrieval\": true } ```  ## Streaming  Set `stream: true` to receive real-time responses: ```json {     \"message\": \"Tell me a story\",     \"workflow\": \"plain\",     \"stream\": true } ```  Streaming responses use Server-Sent Events (SSE) format with event types: - `token`: Content chunks - `node_start`: Workflow node started - `node_complete`: Workflow node completed - `usage`: Final usage statistics - `error`: Error occurred  ## Templates  Use pre-configured templates for common scenarios: ```json {     \"message\": \"I need help with my order\",     \"workflow_template\": \"customer_support\" } ```  Available templates: - `customer_support`: Customer service with knowledge base - `code_assistant`: Programming help with code tools - `research_assistant`: Document research and analysis - `general_chat`: General conversation - `document_qa`: Document question answering - `data_analyst`: Data analysis with computation tools 
     * @summary Create Conversation
     * @param {ConversationCreate} conversationCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    createConversationApiV1ChatConversationsPostRaw(requestParameters: CreateConversationApiV1ChatConversationsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationResponse>>;

    /**
     * Create a new conversation.  Create a new conversation with specified configuration ## Workflow Types  This endpoint supports multiple workflow types through the `workflow` parameter:  ### Plain Chat (`plain`) Basic conversation without tools or retrieval. ```json {     \"message\": \"Hello, how are you?\",     \"workflow\": \"plain\" } ```  ### RAG Workflow (`rag`) Retrieval-Augmented Generation with document search. ```json {     \"message\": \"What are the latest sales figures?\",     \"workflow\": \"rag\",     \"enable_retrieval\": true } ```  ### Tools Workflow (`tools`) Function calling with available tools. ```json {     \"message\": \"Calculate the square root of 144\",     \"workflow\": \"tools\" } ```  ### Full Workflow (`full`) Combination of RAG and tools for complex tasks. ```json {     \"message\": \"Find recent customer feedback and create a summary report\",     \"workflow\": \"full\",     \"enable_retrieval\": true } ```  ## Streaming  Set `stream: true` to receive real-time responses: ```json {     \"message\": \"Tell me a story\",     \"workflow\": \"plain\",     \"stream\": true } ```  Streaming responses use Server-Sent Events (SSE) format with event types: - `token`: Content chunks - `node_start`: Workflow node started - `node_complete`: Workflow node completed - `usage`: Final usage statistics - `error`: Error occurred  ## Templates  Use pre-configured templates for common scenarios: ```json {     \"message\": \"I need help with my order\",     \"workflow_template\": \"customer_support\" } ```  Available templates: - `customer_support`: Customer service with knowledge base - `code_assistant`: Programming help with code tools - `research_assistant`: Document research and analysis - `general_chat`: General conversation - `document_qa`: Document question answering - `data_analyst`: Data analysis with computation tools 
     * Create Conversation
     */
    createConversationApiV1ChatConversationsPost(requestParameters: CreateConversationApiV1ChatConversationsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationResponse>;

    /**
     * Delete conversation.
     * @summary Delete Conversation
     * @param {string} conversationId Conversation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    deleteConversationApiV1ChatConversationsConversationIdDeleteRaw(requestParameters: DeleteConversationApiV1ChatConversationsConversationIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationDeleteResponse>>;

    /**
     * Delete conversation.
     * Delete Conversation
     */
    deleteConversationApiV1ChatConversationsConversationIdDelete(requestParameters: DeleteConversationApiV1ChatConversationsConversationIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationDeleteResponse>;

    /**
     * Delete a message from a conversation.
     * @summary Delete Message
     * @param {string} conversationId Conversation ID
     * @param {string} messageId Message ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRaw(requestParameters: DeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageDeleteResponse>>;

    /**
     * Delete a message from a conversation.
     * Delete Message
     */
    deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete(requestParameters: DeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageDeleteResponse>;

    /**
     * Get list of available MCP tools.
     * @summary Get Available Tools
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    getAvailableToolsApiV1ChatToolsAvailableGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AvailableToolsResponse>>;

    /**
     * Get list of available MCP tools.
     * Get Available Tools
     */
    getAvailableToolsApiV1ChatToolsAvailableGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AvailableToolsResponse>;

    /**
     * Get conversation details with optional messages.
     * @summary Get Conversation
     * @param {string} conversationId Conversation ID
     * @param {boolean} [includeMessages] Include messages in response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    getConversationApiV1ChatConversationsConversationIdGetRaw(requestParameters: GetConversationApiV1ChatConversationsConversationIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationWithMessages>>;

    /**
     * Get conversation details with optional messages.
     * Get Conversation
     */
    getConversationApiV1ChatConversationsConversationIdGet(requestParameters: GetConversationApiV1ChatConversationsConversationIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationWithMessages>;

    /**
     * Get messages from a conversation.
     * @summary Get Conversation Messages
     * @param {string} conversationId Conversation ID
     * @param {number} [limit] Number of results per page
     * @param {number} [offset] Number of results to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    getConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRaw(requestParameters: GetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MessageResponse>>>;

    /**
     * Get messages from a conversation.
     * Get Conversation Messages
     */
    getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet(requestParameters: GetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MessageResponse>>;

    /**
     * Get MCP service status.
     * @summary Get Mcp Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    getMcpStatusApiV1ChatMcpStatusGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<McpStatusResponse>>;

    /**
     * Get MCP service status.
     * Get Mcp Status
     */
    getMcpStatusApiV1ChatMcpStatusGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<McpStatusResponse>;

    /**
     * Get workflow performance statistics.
     * @summary Get Performance Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    getPerformanceStatsApiV1ChatPerformanceStatsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PerformanceStatsResponse>>;

    /**
     * Get workflow performance statistics.
     * Get Performance Stats
     */
    getPerformanceStatsApiV1ChatPerformanceStatsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PerformanceStatsResponse>;

    /**
     * Get available workflow templates.
     * @summary Get Workflow Templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    getWorkflowTemplatesApiV1ChatTemplatesGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatterSchemasChatWorkflowTemplatesResponse>>;

    /**
     * Get available workflow templates.
     * Get Workflow Templates
     */
    getWorkflowTemplatesApiV1ChatTemplatesGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatterSchemasChatWorkflowTemplatesResponse>;

    /**
     * List conversations for the current user.
     * @summary List Conversations
     * @param {number} [limit] Number of results per page
     * @param {number} [offset] Number of results to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    listConversationsApiV1ChatConversationsGetRaw(requestParameters: ListConversationsApiV1ChatConversationsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationSearchResponse>>;

    /**
     * List conversations for the current user.
     * List Conversations
     */
    listConversationsApiV1ChatConversationsGet(requestParameters: ListConversationsApiV1ChatConversationsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationSearchResponse>;

    /**
     * Update conversation.
     * @summary Update Conversation
     * @param {string} conversationId Conversation ID
     * @param {ConversationUpdate} conversationUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChatApiInterface
     */
    updateConversationApiV1ChatConversationsConversationIdPutRaw(requestParameters: UpdateConversationApiV1ChatConversationsConversationIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationResponse>>;

    /**
     * Update conversation.
     * Update Conversation
     */
    updateConversationApiV1ChatConversationsConversationIdPut(requestParameters: UpdateConversationApiV1ChatConversationsConversationIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationResponse>;

}

/**
 * 
 */
export class ChatApi extends runtime.BaseAPI implements ChatApiInterface {

    /**
     * Unified chat endpoint supporting all workflow types with optional streaming. ## Workflow Types  This endpoint supports multiple workflow types through the `workflow` parameter:  ### Plain Chat (`plain`) Basic conversation without tools or retrieval. ```json {     \"message\": \"Hello, how are you?\",     \"workflow\": \"plain\" } ```  ### RAG Workflow (`rag`) Retrieval-Augmented Generation with document search. ```json {     \"message\": \"What are the latest sales figures?\",     \"workflow\": \"rag\",     \"enable_retrieval\": true } ```  ### Tools Workflow (`tools`) Function calling with available tools. ```json {     \"message\": \"Calculate the square root of 144\",     \"workflow\": \"tools\" } ```  ### Full Workflow (`full`) Combination of RAG and tools for complex tasks. ```json {     \"message\": \"Find recent customer feedback and create a summary report\",     \"workflow\": \"full\",     \"enable_retrieval\": true } ```  ## Streaming  Set `stream: true` to receive real-time responses: ```json {     \"message\": \"Tell me a story\",     \"workflow\": \"plain\",     \"stream\": true } ```  Streaming responses use Server-Sent Events (SSE) format with event types: - `token`: Content chunks - `node_start`: Workflow node started - `node_complete`: Workflow node completed - `usage`: Final usage statistics - `error`: Error occurred  ## Templates  Use pre-configured templates for common scenarios: ```json {     \"message\": \"I need help with my order\",     \"workflow_template\": \"customer_support\" } ```  Available templates: - `customer_support`: Customer service with knowledge base - `code_assistant`: Programming help with code tools - `research_assistant`: Document research and analysis - `general_chat`: General conversation - `document_qa`: Document question answering - `data_analyst`: Data analysis with computation tools 
     * Chat
     */
    async chatApiV1ChatChatPostRaw(requestParameters: ChatApiV1ChatChatPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatResponse1>> {
        if (requestParameters['chatRequest'] == null) {
            throw new runtime.RequiredError(
                'chatRequest',
                'Required parameter "chatRequest" was null or undefined when calling chatApiV1ChatChatPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/chat/chat`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ChatRequestToJSON(requestParameters['chatRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatResponse1FromJSON(jsonValue));
    }

    /**
     * Unified chat endpoint supporting all workflow types with optional streaming. ## Workflow Types  This endpoint supports multiple workflow types through the `workflow` parameter:  ### Plain Chat (`plain`) Basic conversation without tools or retrieval. ```json {     \"message\": \"Hello, how are you?\",     \"workflow\": \"plain\" } ```  ### RAG Workflow (`rag`) Retrieval-Augmented Generation with document search. ```json {     \"message\": \"What are the latest sales figures?\",     \"workflow\": \"rag\",     \"enable_retrieval\": true } ```  ### Tools Workflow (`tools`) Function calling with available tools. ```json {     \"message\": \"Calculate the square root of 144\",     \"workflow\": \"tools\" } ```  ### Full Workflow (`full`) Combination of RAG and tools for complex tasks. ```json {     \"message\": \"Find recent customer feedback and create a summary report\",     \"workflow\": \"full\",     \"enable_retrieval\": true } ```  ## Streaming  Set `stream: true` to receive real-time responses: ```json {     \"message\": \"Tell me a story\",     \"workflow\": \"plain\",     \"stream\": true } ```  Streaming responses use Server-Sent Events (SSE) format with event types: - `token`: Content chunks - `node_start`: Workflow node started - `node_complete`: Workflow node completed - `usage`: Final usage statistics - `error`: Error occurred  ## Templates  Use pre-configured templates for common scenarios: ```json {     \"message\": \"I need help with my order\",     \"workflow_template\": \"customer_support\" } ```  Available templates: - `customer_support`: Customer service with knowledge base - `code_assistant`: Programming help with code tools - `research_assistant`: Document research and analysis - `general_chat`: General conversation - `document_qa`: Document question answering - `data_analyst`: Data analysis with computation tools 
     * Chat
     */
    async chatApiV1ChatChatPost(requestParameters: ChatApiV1ChatChatPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatResponse1> {
        const response = await this.chatApiV1ChatChatPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Chat using a specific workflow template. ## Workflow Types  This endpoint supports multiple workflow types through the `workflow` parameter:  ### Plain Chat (`plain`) Basic conversation without tools or retrieval. ```json {     \"message\": \"Hello, how are you?\",     \"workflow\": \"plain\" } ```  ### RAG Workflow (`rag`) Retrieval-Augmented Generation with document search. ```json {     \"message\": \"What are the latest sales figures?\",     \"workflow\": \"rag\",     \"enable_retrieval\": true } ```  ### Tools Workflow (`tools`) Function calling with available tools. ```json {     \"message\": \"Calculate the square root of 144\",     \"workflow\": \"tools\" } ```  ### Full Workflow (`full`) Combination of RAG and tools for complex tasks. ```json {     \"message\": \"Find recent customer feedback and create a summary report\",     \"workflow\": \"full\",     \"enable_retrieval\": true } ```  ## Streaming  Set `stream: true` to receive real-time responses: ```json {     \"message\": \"Tell me a story\",     \"workflow\": \"plain\",     \"stream\": true } ```  Streaming responses use Server-Sent Events (SSE) format with event types: - `token`: Content chunks - `node_start`: Workflow node started - `node_complete`: Workflow node completed - `usage`: Final usage statistics - `error`: Error occurred  ## Templates  Use pre-configured templates for common scenarios: ```json {     \"message\": \"I need help with my order\",     \"workflow_template\": \"customer_support\" } ```  Available templates: - `customer_support`: Customer service with knowledge base - `code_assistant`: Programming help with code tools - `research_assistant`: Document research and analysis - `general_chat`: General conversation - `document_qa`: Document question answering - `data_analyst`: Data analysis with computation tools 
     * Chat With Template
     */
    async chatWithTemplateApiV1ChatTemplateTemplateNamePostRaw(requestParameters: ChatWithTemplateApiV1ChatTemplateTemplateNamePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatResponse>> {
        if (requestParameters['templateName'] == null) {
            throw new runtime.RequiredError(
                'templateName',
                'Required parameter "templateName" was null or undefined when calling chatWithTemplateApiV1ChatTemplateTemplateNamePost().'
            );
        }

        if (requestParameters['chatRequest'] == null) {
            throw new runtime.RequiredError(
                'chatRequest',
                'Required parameter "chatRequest" was null or undefined when calling chatWithTemplateApiV1ChatTemplateTemplateNamePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/chat/template/{template_name}`;
        urlPath = urlPath.replace(`{${"template_name"}}`, encodeURIComponent(String(requestParameters['templateName'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ChatRequestToJSON(requestParameters['chatRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatResponseFromJSON(jsonValue));
    }

    /**
     * Chat using a specific workflow template. ## Workflow Types  This endpoint supports multiple workflow types through the `workflow` parameter:  ### Plain Chat (`plain`) Basic conversation without tools or retrieval. ```json {     \"message\": \"Hello, how are you?\",     \"workflow\": \"plain\" } ```  ### RAG Workflow (`rag`) Retrieval-Augmented Generation with document search. ```json {     \"message\": \"What are the latest sales figures?\",     \"workflow\": \"rag\",     \"enable_retrieval\": true } ```  ### Tools Workflow (`tools`) Function calling with available tools. ```json {     \"message\": \"Calculate the square root of 144\",     \"workflow\": \"tools\" } ```  ### Full Workflow (`full`) Combination of RAG and tools for complex tasks. ```json {     \"message\": \"Find recent customer feedback and create a summary report\",     \"workflow\": \"full\",     \"enable_retrieval\": true } ```  ## Streaming  Set `stream: true` to receive real-time responses: ```json {     \"message\": \"Tell me a story\",     \"workflow\": \"plain\",     \"stream\": true } ```  Streaming responses use Server-Sent Events (SSE) format with event types: - `token`: Content chunks - `node_start`: Workflow node started - `node_complete`: Workflow node completed - `usage`: Final usage statistics - `error`: Error occurred  ## Templates  Use pre-configured templates for common scenarios: ```json {     \"message\": \"I need help with my order\",     \"workflow_template\": \"customer_support\" } ```  Available templates: - `customer_support`: Customer service with knowledge base - `code_assistant`: Programming help with code tools - `research_assistant`: Document research and analysis - `general_chat`: General conversation - `document_qa`: Document question answering - `data_analyst`: Data analysis with computation tools 
     * Chat With Template
     */
    async chatWithTemplateApiV1ChatTemplateTemplateNamePost(requestParameters: ChatWithTemplateApiV1ChatTemplateTemplateNamePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatResponse> {
        const response = await this.chatWithTemplateApiV1ChatTemplateTemplateNamePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new conversation.  Create a new conversation with specified configuration ## Workflow Types  This endpoint supports multiple workflow types through the `workflow` parameter:  ### Plain Chat (`plain`) Basic conversation without tools or retrieval. ```json {     \"message\": \"Hello, how are you?\",     \"workflow\": \"plain\" } ```  ### RAG Workflow (`rag`) Retrieval-Augmented Generation with document search. ```json {     \"message\": \"What are the latest sales figures?\",     \"workflow\": \"rag\",     \"enable_retrieval\": true } ```  ### Tools Workflow (`tools`) Function calling with available tools. ```json {     \"message\": \"Calculate the square root of 144\",     \"workflow\": \"tools\" } ```  ### Full Workflow (`full`) Combination of RAG and tools for complex tasks. ```json {     \"message\": \"Find recent customer feedback and create a summary report\",     \"workflow\": \"full\",     \"enable_retrieval\": true } ```  ## Streaming  Set `stream: true` to receive real-time responses: ```json {     \"message\": \"Tell me a story\",     \"workflow\": \"plain\",     \"stream\": true } ```  Streaming responses use Server-Sent Events (SSE) format with event types: - `token`: Content chunks - `node_start`: Workflow node started - `node_complete`: Workflow node completed - `usage`: Final usage statistics - `error`: Error occurred  ## Templates  Use pre-configured templates for common scenarios: ```json {     \"message\": \"I need help with my order\",     \"workflow_template\": \"customer_support\" } ```  Available templates: - `customer_support`: Customer service with knowledge base - `code_assistant`: Programming help with code tools - `research_assistant`: Document research and analysis - `general_chat`: General conversation - `document_qa`: Document question answering - `data_analyst`: Data analysis with computation tools 
     * Create Conversation
     */
    async createConversationApiV1ChatConversationsPostRaw(requestParameters: CreateConversationApiV1ChatConversationsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationResponse>> {
        if (requestParameters['conversationCreate'] == null) {
            throw new runtime.RequiredError(
                'conversationCreate',
                'Required parameter "conversationCreate" was null or undefined when calling createConversationApiV1ChatConversationsPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/chat/conversations`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationCreateToJSON(requestParameters['conversationCreate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationResponseFromJSON(jsonValue));
    }

    /**
     * Create a new conversation.  Create a new conversation with specified configuration ## Workflow Types  This endpoint supports multiple workflow types through the `workflow` parameter:  ### Plain Chat (`plain`) Basic conversation without tools or retrieval. ```json {     \"message\": \"Hello, how are you?\",     \"workflow\": \"plain\" } ```  ### RAG Workflow (`rag`) Retrieval-Augmented Generation with document search. ```json {     \"message\": \"What are the latest sales figures?\",     \"workflow\": \"rag\",     \"enable_retrieval\": true } ```  ### Tools Workflow (`tools`) Function calling with available tools. ```json {     \"message\": \"Calculate the square root of 144\",     \"workflow\": \"tools\" } ```  ### Full Workflow (`full`) Combination of RAG and tools for complex tasks. ```json {     \"message\": \"Find recent customer feedback and create a summary report\",     \"workflow\": \"full\",     \"enable_retrieval\": true } ```  ## Streaming  Set `stream: true` to receive real-time responses: ```json {     \"message\": \"Tell me a story\",     \"workflow\": \"plain\",     \"stream\": true } ```  Streaming responses use Server-Sent Events (SSE) format with event types: - `token`: Content chunks - `node_start`: Workflow node started - `node_complete`: Workflow node completed - `usage`: Final usage statistics - `error`: Error occurred  ## Templates  Use pre-configured templates for common scenarios: ```json {     \"message\": \"I need help with my order\",     \"workflow_template\": \"customer_support\" } ```  Available templates: - `customer_support`: Customer service with knowledge base - `code_assistant`: Programming help with code tools - `research_assistant`: Document research and analysis - `general_chat`: General conversation - `document_qa`: Document question answering - `data_analyst`: Data analysis with computation tools 
     * Create Conversation
     */
    async createConversationApiV1ChatConversationsPost(requestParameters: CreateConversationApiV1ChatConversationsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationResponse> {
        const response = await this.createConversationApiV1ChatConversationsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete conversation.
     * Delete Conversation
     */
    async deleteConversationApiV1ChatConversationsConversationIdDeleteRaw(requestParameters: DeleteConversationApiV1ChatConversationsConversationIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationDeleteResponse>> {
        if (requestParameters['conversationId'] == null) {
            throw new runtime.RequiredError(
                'conversationId',
                'Required parameter "conversationId" was null or undefined when calling deleteConversationApiV1ChatConversationsConversationIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/chat/conversations/{conversation_id}`;
        urlPath = urlPath.replace(`{${"conversation_id"}}`, encodeURIComponent(String(requestParameters['conversationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationDeleteResponseFromJSON(jsonValue));
    }

    /**
     * Delete conversation.
     * Delete Conversation
     */
    async deleteConversationApiV1ChatConversationsConversationIdDelete(requestParameters: DeleteConversationApiV1ChatConversationsConversationIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationDeleteResponse> {
        const response = await this.deleteConversationApiV1ChatConversationsConversationIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a message from a conversation.
     * Delete Message
     */
    async deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRaw(requestParameters: DeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MessageDeleteResponse>> {
        if (requestParameters['conversationId'] == null) {
            throw new runtime.RequiredError(
                'conversationId',
                'Required parameter "conversationId" was null or undefined when calling deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete().'
            );
        }

        if (requestParameters['messageId'] == null) {
            throw new runtime.RequiredError(
                'messageId',
                'Required parameter "messageId" was null or undefined when calling deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/chat/conversations/{conversation_id}/messages/{message_id}`;
        urlPath = urlPath.replace(`{${"conversation_id"}}`, encodeURIComponent(String(requestParameters['conversationId'])));
        urlPath = urlPath.replace(`{${"message_id"}}`, encodeURIComponent(String(requestParameters['messageId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MessageDeleteResponseFromJSON(jsonValue));
    }

    /**
     * Delete a message from a conversation.
     * Delete Message
     */
    async deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDelete(requestParameters: DeleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MessageDeleteResponse> {
        const response = await this.deleteMessageApiV1ChatConversationsConversationIdMessagesMessageIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get list of available MCP tools.
     * Get Available Tools
     */
    async getAvailableToolsApiV1ChatToolsAvailableGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AvailableToolsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/chat/tools/available`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AvailableToolsResponseFromJSON(jsonValue));
    }

    /**
     * Get list of available MCP tools.
     * Get Available Tools
     */
    async getAvailableToolsApiV1ChatToolsAvailableGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AvailableToolsResponse> {
        const response = await this.getAvailableToolsApiV1ChatToolsAvailableGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get conversation details with optional messages.
     * Get Conversation
     */
    async getConversationApiV1ChatConversationsConversationIdGetRaw(requestParameters: GetConversationApiV1ChatConversationsConversationIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationWithMessages>> {
        if (requestParameters['conversationId'] == null) {
            throw new runtime.RequiredError(
                'conversationId',
                'Required parameter "conversationId" was null or undefined when calling getConversationApiV1ChatConversationsConversationIdGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['includeMessages'] != null) {
            queryParameters['include_messages'] = requestParameters['includeMessages'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/chat/conversations/{conversation_id}`;
        urlPath = urlPath.replace(`{${"conversation_id"}}`, encodeURIComponent(String(requestParameters['conversationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationWithMessagesFromJSON(jsonValue));
    }

    /**
     * Get conversation details with optional messages.
     * Get Conversation
     */
    async getConversationApiV1ChatConversationsConversationIdGet(requestParameters: GetConversationApiV1ChatConversationsConversationIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationWithMessages> {
        const response = await this.getConversationApiV1ChatConversationsConversationIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get messages from a conversation.
     * Get Conversation Messages
     */
    async getConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRaw(requestParameters: GetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<MessageResponse>>> {
        if (requestParameters['conversationId'] == null) {
            throw new runtime.RequiredError(
                'conversationId',
                'Required parameter "conversationId" was null or undefined when calling getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/chat/conversations/{conversation_id}/messages`;
        urlPath = urlPath.replace(`{${"conversation_id"}}`, encodeURIComponent(String(requestParameters['conversationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(MessageResponseFromJSON));
    }

    /**
     * Get messages from a conversation.
     * Get Conversation Messages
     */
    async getConversationMessagesApiV1ChatConversationsConversationIdMessagesGet(requestParameters: GetConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<MessageResponse>> {
        const response = await this.getConversationMessagesApiV1ChatConversationsConversationIdMessagesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get MCP service status.
     * Get Mcp Status
     */
    async getMcpStatusApiV1ChatMcpStatusGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<McpStatusResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/chat/mcp/status`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => McpStatusResponseFromJSON(jsonValue));
    }

    /**
     * Get MCP service status.
     * Get Mcp Status
     */
    async getMcpStatusApiV1ChatMcpStatusGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<McpStatusResponse> {
        const response = await this.getMcpStatusApiV1ChatMcpStatusGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get workflow performance statistics.
     * Get Performance Stats
     */
    async getPerformanceStatsApiV1ChatPerformanceStatsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PerformanceStatsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/chat/performance/stats`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PerformanceStatsResponseFromJSON(jsonValue));
    }

    /**
     * Get workflow performance statistics.
     * Get Performance Stats
     */
    async getPerformanceStatsApiV1ChatPerformanceStatsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PerformanceStatsResponse> {
        const response = await this.getPerformanceStatsApiV1ChatPerformanceStatsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get available workflow templates.
     * Get Workflow Templates
     */
    async getWorkflowTemplatesApiV1ChatTemplatesGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatterSchemasChatWorkflowTemplatesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/chat/templates`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatterSchemasChatWorkflowTemplatesResponseFromJSON(jsonValue));
    }

    /**
     * Get available workflow templates.
     * Get Workflow Templates
     */
    async getWorkflowTemplatesApiV1ChatTemplatesGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatterSchemasChatWorkflowTemplatesResponse> {
        const response = await this.getWorkflowTemplatesApiV1ChatTemplatesGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * List conversations for the current user.
     * List Conversations
     */
    async listConversationsApiV1ChatConversationsGetRaw(requestParameters: ListConversationsApiV1ChatConversationsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationSearchResponse>> {
        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/chat/conversations`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationSearchResponseFromJSON(jsonValue));
    }

    /**
     * List conversations for the current user.
     * List Conversations
     */
    async listConversationsApiV1ChatConversationsGet(requestParameters: ListConversationsApiV1ChatConversationsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationSearchResponse> {
        const response = await this.listConversationsApiV1ChatConversationsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update conversation.
     * Update Conversation
     */
    async updateConversationApiV1ChatConversationsConversationIdPutRaw(requestParameters: UpdateConversationApiV1ChatConversationsConversationIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ConversationResponse>> {
        if (requestParameters['conversationId'] == null) {
            throw new runtime.RequiredError(
                'conversationId',
                'Required parameter "conversationId" was null or undefined when calling updateConversationApiV1ChatConversationsConversationIdPut().'
            );
        }

        if (requestParameters['conversationUpdate'] == null) {
            throw new runtime.RequiredError(
                'conversationUpdate',
                'Required parameter "conversationUpdate" was null or undefined when calling updateConversationApiV1ChatConversationsConversationIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/chat/conversations/{conversation_id}`;
        urlPath = urlPath.replace(`{${"conversation_id"}}`, encodeURIComponent(String(requestParameters['conversationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ConversationUpdateToJSON(requestParameters['conversationUpdate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ConversationResponseFromJSON(jsonValue));
    }

    /**
     * Update conversation.
     * Update Conversation
     */
    async updateConversationApiV1ChatConversationsConversationIdPut(requestParameters: UpdateConversationApiV1ChatConversationsConversationIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ConversationResponse> {
        const response = await this.updateConversationApiV1ChatConversationsConversationIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
