/* tslint:disable */
/* eslint-disable */
/**
 * Chatter API
 * Advanced AI Chatbot Backend API Platform
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DocumentChunksResponse,
  DocumentDeleteResponse,
  DocumentListResponse,
  DocumentProcessingRequest,
  DocumentProcessingResponse,
  DocumentResponse,
  DocumentSearchRequest,
  DocumentSearchResponse,
  DocumentStatsResponse,
  DocumentStatus,
  DocumentType,
  DocumentUpdate,
  HTTPValidationError,
} from '../models/index';
import {
    DocumentChunksResponseFromJSON,
    DocumentChunksResponseToJSON,
    DocumentDeleteResponseFromJSON,
    DocumentDeleteResponseToJSON,
    DocumentListResponseFromJSON,
    DocumentListResponseToJSON,
    DocumentProcessingRequestFromJSON,
    DocumentProcessingRequestToJSON,
    DocumentProcessingResponseFromJSON,
    DocumentProcessingResponseToJSON,
    DocumentResponseFromJSON,
    DocumentResponseToJSON,
    DocumentSearchRequestFromJSON,
    DocumentSearchRequestToJSON,
    DocumentSearchResponseFromJSON,
    DocumentSearchResponseToJSON,
    DocumentStatsResponseFromJSON,
    DocumentStatsResponseToJSON,
    DocumentStatusFromJSON,
    DocumentStatusToJSON,
    DocumentTypeFromJSON,
    DocumentTypeToJSON,
    DocumentUpdateFromJSON,
    DocumentUpdateToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
} from '../models/index';

export interface DeleteDocumentApiV1DocumentsDocumentIdDeleteRequest {
    documentId: string;
}

export interface DownloadDocumentApiV1DocumentsDocumentIdDownloadGetRequest {
    documentId: string;
}

export interface GetDocumentApiV1DocumentsDocumentIdGetRequest {
    documentId: string;
}

export interface GetDocumentChunksApiV1DocumentsDocumentIdChunksGetRequest {
    documentId: string;
    limit?: number;
    offset?: number;
}

export interface ListDocumentsApiV1DocumentsGetRequest {
    status?: DocumentStatus | null;
    documentType?: DocumentType | null;
    tags?: Array<string> | null;
    ownerId?: string | null;
    limit?: number;
    offset?: number;
    sortBy?: string;
    sortOrder?: string;
}

export interface ProcessDocumentApiV1DocumentsDocumentIdProcessPostRequest {
    documentId: string;
    documentProcessingRequest: DocumentProcessingRequest;
}

export interface ReprocessDocumentApiV1DocumentsDocumentIdReprocessPostRequest {
    documentId: string;
}

export interface SearchDocumentsApiV1DocumentsSearchPostRequest {
    documentSearchRequest: DocumentSearchRequest;
}

export interface UpdateDocumentApiV1DocumentsDocumentIdPutRequest {
    documentId: string;
    documentUpdate: DocumentUpdate;
}

export interface UploadDocumentApiV1DocumentsUploadPostRequest {
    file: Blob;
    title?: string;
    description?: string;
    tags?: string;
    chunkSize?: number;
    chunkOverlap?: number;
    isPublic?: boolean;
}

/**
 * DocumentsApi - interface
 * 
 * @export
 * @interface DocumentsApiInterface
 */
export interface DocumentsApiInterface {
    /**
     * Delete document.  Args:     document_id: Document ID     request: Delete request parameters     current_user: Current authenticated user     document_service: Document service  Returns:     Success message
     * @summary Delete Document
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    deleteDocumentApiV1DocumentsDocumentIdDeleteRaw(requestParameters: DeleteDocumentApiV1DocumentsDocumentIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentDeleteResponse>>;

    /**
     * Delete document.  Args:     document_id: Document ID     request: Delete request parameters     current_user: Current authenticated user     document_service: Document service  Returns:     Success message
     * Delete Document
     */
    deleteDocumentApiV1DocumentsDocumentIdDelete(requestParameters: DeleteDocumentApiV1DocumentsDocumentIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentDeleteResponse>;

    /**
     * Download original document file.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     File download response
     * @summary Download Document
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    downloadDocumentApiV1DocumentsDocumentIdDownloadGetRaw(requestParameters: DownloadDocumentApiV1DocumentsDocumentIdDownloadGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Download original document file.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     File download response
     * Download Document
     */
    downloadDocumentApiV1DocumentsDocumentIdDownloadGet(requestParameters: DownloadDocumentApiV1DocumentsDocumentIdDownloadGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Get document details.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Document information
     * @summary Get Document
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    getDocumentApiV1DocumentsDocumentIdGetRaw(requestParameters: GetDocumentApiV1DocumentsDocumentIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentResponse>>;

    /**
     * Get document details.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Document information
     * Get Document
     */
    getDocumentApiV1DocumentsDocumentIdGet(requestParameters: GetDocumentApiV1DocumentsDocumentIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentResponse>;

    /**
     * Get document chunks.  Args:     document_id: Document ID     limit: Maximum number of results     offset: Number of results to skip     current_user: Current authenticated user     document_service: Document service  Returns:     List of document chunks with pagination
     * @summary Get Document Chunks
     * @param {string} documentId 
     * @param {number} [limit] Maximum number of results
     * @param {number} [offset] Number of results to skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    getDocumentChunksApiV1DocumentsDocumentIdChunksGetRaw(requestParameters: GetDocumentChunksApiV1DocumentsDocumentIdChunksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentChunksResponse>>;

    /**
     * Get document chunks.  Args:     document_id: Document ID     limit: Maximum number of results     offset: Number of results to skip     current_user: Current authenticated user     document_service: Document service  Returns:     List of document chunks with pagination
     * Get Document Chunks
     */
    getDocumentChunksApiV1DocumentsDocumentIdChunksGet(requestParameters: GetDocumentChunksApiV1DocumentsDocumentIdChunksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentChunksResponse>;

    /**
     * Get document statistics.  Args:     current_user: Current authenticated user     document_service: Document service  Returns:     Document statistics
     * @summary Get Document Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    getDocumentStatsApiV1DocumentsStatsOverviewGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentStatsResponse>>;

    /**
     * Get document statistics.  Args:     current_user: Current authenticated user     document_service: Document service  Returns:     Document statistics
     * Get Document Stats
     */
    getDocumentStatsApiV1DocumentsStatsOverviewGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentStatsResponse>;

    /**
     * List user\'s documents.  Args:     status: Filter by document status     document_type: Filter by document type     tags: Filter by tags     owner_id: Filter by owner (admin only)     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     document_service: Document service  Returns:     List of documents with pagination info
     * @summary List Documents
     * @param {DocumentStatus} [status] Filter by status
     * @param {DocumentType} [documentType] Filter by document type
     * @param {Array<string>} [tags] Filter by tags
     * @param {string} [ownerId] Filter by owner (admin only)
     * @param {number} [limit] Maximum number of results
     * @param {number} [offset] Number of results to skip
     * @param {string} [sortBy] Sort field
     * @param {string} [sortOrder] Sort order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    listDocumentsApiV1DocumentsGetRaw(requestParameters: ListDocumentsApiV1DocumentsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentListResponse>>;

    /**
     * List user\'s documents.  Args:     status: Filter by document status     document_type: Filter by document type     tags: Filter by tags     owner_id: Filter by owner (admin only)     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     document_service: Document service  Returns:     List of documents with pagination info
     * List Documents
     */
    listDocumentsApiV1DocumentsGet(requestParameters: ListDocumentsApiV1DocumentsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentListResponse>;

    /**
     * Trigger document processing.  Args:     document_id: Document ID     processing_request: Processing request     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
     * @summary Process Document
     * @param {string} documentId 
     * @param {DocumentProcessingRequest} documentProcessingRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    processDocumentApiV1DocumentsDocumentIdProcessPostRaw(requestParameters: ProcessDocumentApiV1DocumentsDocumentIdProcessPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentProcessingResponse>>;

    /**
     * Trigger document processing.  Args:     document_id: Document ID     processing_request: Processing request     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
     * Process Document
     */
    processDocumentApiV1DocumentsDocumentIdProcessPost(requestParameters: ProcessDocumentApiV1DocumentsDocumentIdProcessPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentProcessingResponse>;

    /**
     * Reprocess an existing document.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
     * @summary Reprocess Document
     * @param {string} documentId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    reprocessDocumentApiV1DocumentsDocumentIdReprocessPostRaw(requestParameters: ReprocessDocumentApiV1DocumentsDocumentIdReprocessPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentProcessingResponse>>;

    /**
     * Reprocess an existing document.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
     * Reprocess Document
     */
    reprocessDocumentApiV1DocumentsDocumentIdReprocessPost(requestParameters: ReprocessDocumentApiV1DocumentsDocumentIdReprocessPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentProcessingResponse>;

    /**
     * Search documents using vector similarity.  Args:     search_request: Search request     current_user: Current authenticated user     document_service: Document service  Returns:     Search results
     * @summary Search Documents
     * @param {DocumentSearchRequest} documentSearchRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    searchDocumentsApiV1DocumentsSearchPostRaw(requestParameters: SearchDocumentsApiV1DocumentsSearchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentSearchResponse>>;

    /**
     * Search documents using vector similarity.  Args:     search_request: Search request     current_user: Current authenticated user     document_service: Document service  Returns:     Search results
     * Search Documents
     */
    searchDocumentsApiV1DocumentsSearchPost(requestParameters: SearchDocumentsApiV1DocumentsSearchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentSearchResponse>;

    /**
     * Update document metadata.  Args:     document_id: Document ID     update_data: Update data     current_user: Current authenticated user     document_service: Document service  Returns:     Updated document information
     * @summary Update Document
     * @param {string} documentId 
     * @param {DocumentUpdate} documentUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    updateDocumentApiV1DocumentsDocumentIdPutRaw(requestParameters: UpdateDocumentApiV1DocumentsDocumentIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentResponse>>;

    /**
     * Update document metadata.  Args:     document_id: Document ID     update_data: Update data     current_user: Current authenticated user     document_service: Document service  Returns:     Updated document information
     * Update Document
     */
    updateDocumentApiV1DocumentsDocumentIdPut(requestParameters: UpdateDocumentApiV1DocumentsDocumentIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentResponse>;

    /**
     * Upload a document.  Args:     file: Document file to upload     title: Document title     description: Document description     tags: Document tags (JSON array string)     chunk_size: Text chunk size for processing     chunk_overlap: Text chunk overlap     is_public: Whether document is public     current_user: Current authenticated user     document_service: Document service  Returns:     Created document information
     * @summary Upload Document
     * @param {Blob} file 
     * @param {string} [title] 
     * @param {string} [description] 
     * @param {string} [tags] 
     * @param {number} [chunkSize] 
     * @param {number} [chunkOverlap] 
     * @param {boolean} [isPublic] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentsApiInterface
     */
    uploadDocumentApiV1DocumentsUploadPostRaw(requestParameters: UploadDocumentApiV1DocumentsUploadPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentResponse>>;

    /**
     * Upload a document.  Args:     file: Document file to upload     title: Document title     description: Document description     tags: Document tags (JSON array string)     chunk_size: Text chunk size for processing     chunk_overlap: Text chunk overlap     is_public: Whether document is public     current_user: Current authenticated user     document_service: Document service  Returns:     Created document information
     * Upload Document
     */
    uploadDocumentApiV1DocumentsUploadPost(requestParameters: UploadDocumentApiV1DocumentsUploadPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentResponse>;

}

/**
 * 
 */
export class DocumentsApi extends runtime.BaseAPI implements DocumentsApiInterface {

    /**
     * Delete document.  Args:     document_id: Document ID     request: Delete request parameters     current_user: Current authenticated user     document_service: Document service  Returns:     Success message
     * Delete Document
     */
    async deleteDocumentApiV1DocumentsDocumentIdDeleteRaw(requestParameters: DeleteDocumentApiV1DocumentsDocumentIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentDeleteResponse>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling deleteDocumentApiV1DocumentsDocumentIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/documents/{document_id}`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentDeleteResponseFromJSON(jsonValue));
    }

    /**
     * Delete document.  Args:     document_id: Document ID     request: Delete request parameters     current_user: Current authenticated user     document_service: Document service  Returns:     Success message
     * Delete Document
     */
    async deleteDocumentApiV1DocumentsDocumentIdDelete(requestParameters: DeleteDocumentApiV1DocumentsDocumentIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentDeleteResponse> {
        const response = await this.deleteDocumentApiV1DocumentsDocumentIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download original document file.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     File download response
     * Download Document
     */
    async downloadDocumentApiV1DocumentsDocumentIdDownloadGetRaw(requestParameters: DownloadDocumentApiV1DocumentsDocumentIdDownloadGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling downloadDocumentApiV1DocumentsDocumentIdDownloadGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/documents/{document_id}/download`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download original document file.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     File download response
     * Download Document
     */
    async downloadDocumentApiV1DocumentsDocumentIdDownloadGet(requestParameters: DownloadDocumentApiV1DocumentsDocumentIdDownloadGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.downloadDocumentApiV1DocumentsDocumentIdDownloadGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get document details.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Document information
     * Get Document
     */
    async getDocumentApiV1DocumentsDocumentIdGetRaw(requestParameters: GetDocumentApiV1DocumentsDocumentIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentResponse>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling getDocumentApiV1DocumentsDocumentIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/documents/{document_id}`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentResponseFromJSON(jsonValue));
    }

    /**
     * Get document details.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Document information
     * Get Document
     */
    async getDocumentApiV1DocumentsDocumentIdGet(requestParameters: GetDocumentApiV1DocumentsDocumentIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentResponse> {
        const response = await this.getDocumentApiV1DocumentsDocumentIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get document chunks.  Args:     document_id: Document ID     limit: Maximum number of results     offset: Number of results to skip     current_user: Current authenticated user     document_service: Document service  Returns:     List of document chunks with pagination
     * Get Document Chunks
     */
    async getDocumentChunksApiV1DocumentsDocumentIdChunksGetRaw(requestParameters: GetDocumentChunksApiV1DocumentsDocumentIdChunksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentChunksResponse>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling getDocumentChunksApiV1DocumentsDocumentIdChunksGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/documents/{document_id}/chunks`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentChunksResponseFromJSON(jsonValue));
    }

    /**
     * Get document chunks.  Args:     document_id: Document ID     limit: Maximum number of results     offset: Number of results to skip     current_user: Current authenticated user     document_service: Document service  Returns:     List of document chunks with pagination
     * Get Document Chunks
     */
    async getDocumentChunksApiV1DocumentsDocumentIdChunksGet(requestParameters: GetDocumentChunksApiV1DocumentsDocumentIdChunksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentChunksResponse> {
        const response = await this.getDocumentChunksApiV1DocumentsDocumentIdChunksGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get document statistics.  Args:     current_user: Current authenticated user     document_service: Document service  Returns:     Document statistics
     * Get Document Stats
     */
    async getDocumentStatsApiV1DocumentsStatsOverviewGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentStatsResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/documents/stats/overview`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentStatsResponseFromJSON(jsonValue));
    }

    /**
     * Get document statistics.  Args:     current_user: Current authenticated user     document_service: Document service  Returns:     Document statistics
     * Get Document Stats
     */
    async getDocumentStatsApiV1DocumentsStatsOverviewGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentStatsResponse> {
        const response = await this.getDocumentStatsApiV1DocumentsStatsOverviewGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * List user\'s documents.  Args:     status: Filter by document status     document_type: Filter by document type     tags: Filter by tags     owner_id: Filter by owner (admin only)     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     document_service: Document service  Returns:     List of documents with pagination info
     * List Documents
     */
    async listDocumentsApiV1DocumentsGetRaw(requestParameters: ListDocumentsApiV1DocumentsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentListResponse>> {
        const queryParameters: any = {};

        if (requestParameters['status'] != null) {
            queryParameters['status'] = requestParameters['status'];
        }

        if (requestParameters['documentType'] != null) {
            queryParameters['document_type'] = requestParameters['documentType'];
        }

        if (requestParameters['tags'] != null) {
            queryParameters['tags'] = requestParameters['tags'];
        }

        if (requestParameters['ownerId'] != null) {
            queryParameters['owner_id'] = requestParameters['ownerId'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sort_by'] = requestParameters['sortBy'];
        }

        if (requestParameters['sortOrder'] != null) {
            queryParameters['sort_order'] = requestParameters['sortOrder'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/documents`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentListResponseFromJSON(jsonValue));
    }

    /**
     * List user\'s documents.  Args:     status: Filter by document status     document_type: Filter by document type     tags: Filter by tags     owner_id: Filter by owner (admin only)     limit: Maximum number of results     offset: Number of results to skip     sort_by: Sort field     sort_order: Sort order (asc/desc)     current_user: Current authenticated user     document_service: Document service  Returns:     List of documents with pagination info
     * List Documents
     */
    async listDocumentsApiV1DocumentsGet(requestParameters: ListDocumentsApiV1DocumentsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentListResponse> {
        const response = await this.listDocumentsApiV1DocumentsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Trigger document processing.  Args:     document_id: Document ID     processing_request: Processing request     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
     * Process Document
     */
    async processDocumentApiV1DocumentsDocumentIdProcessPostRaw(requestParameters: ProcessDocumentApiV1DocumentsDocumentIdProcessPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentProcessingResponse>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling processDocumentApiV1DocumentsDocumentIdProcessPost().'
            );
        }

        if (requestParameters['documentProcessingRequest'] == null) {
            throw new runtime.RequiredError(
                'documentProcessingRequest',
                'Required parameter "documentProcessingRequest" was null or undefined when calling processDocumentApiV1DocumentsDocumentIdProcessPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/documents/{document_id}/process`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentProcessingRequestToJSON(requestParameters['documentProcessingRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentProcessingResponseFromJSON(jsonValue));
    }

    /**
     * Trigger document processing.  Args:     document_id: Document ID     processing_request: Processing request     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
     * Process Document
     */
    async processDocumentApiV1DocumentsDocumentIdProcessPost(requestParameters: ProcessDocumentApiV1DocumentsDocumentIdProcessPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentProcessingResponse> {
        const response = await this.processDocumentApiV1DocumentsDocumentIdProcessPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Reprocess an existing document.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
     * Reprocess Document
     */
    async reprocessDocumentApiV1DocumentsDocumentIdReprocessPostRaw(requestParameters: ReprocessDocumentApiV1DocumentsDocumentIdReprocessPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentProcessingResponse>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling reprocessDocumentApiV1DocumentsDocumentIdReprocessPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/documents/{document_id}/reprocess`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentProcessingResponseFromJSON(jsonValue));
    }

    /**
     * Reprocess an existing document.  Args:     document_id: Document ID     current_user: Current authenticated user     document_service: Document service  Returns:     Processing status
     * Reprocess Document
     */
    async reprocessDocumentApiV1DocumentsDocumentIdReprocessPost(requestParameters: ReprocessDocumentApiV1DocumentsDocumentIdReprocessPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentProcessingResponse> {
        const response = await this.reprocessDocumentApiV1DocumentsDocumentIdReprocessPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Search documents using vector similarity.  Args:     search_request: Search request     current_user: Current authenticated user     document_service: Document service  Returns:     Search results
     * Search Documents
     */
    async searchDocumentsApiV1DocumentsSearchPostRaw(requestParameters: SearchDocumentsApiV1DocumentsSearchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentSearchResponse>> {
        if (requestParameters['documentSearchRequest'] == null) {
            throw new runtime.RequiredError(
                'documentSearchRequest',
                'Required parameter "documentSearchRequest" was null or undefined when calling searchDocumentsApiV1DocumentsSearchPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/documents/search`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentSearchRequestToJSON(requestParameters['documentSearchRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentSearchResponseFromJSON(jsonValue));
    }

    /**
     * Search documents using vector similarity.  Args:     search_request: Search request     current_user: Current authenticated user     document_service: Document service  Returns:     Search results
     * Search Documents
     */
    async searchDocumentsApiV1DocumentsSearchPost(requestParameters: SearchDocumentsApiV1DocumentsSearchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentSearchResponse> {
        const response = await this.searchDocumentsApiV1DocumentsSearchPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update document metadata.  Args:     document_id: Document ID     update_data: Update data     current_user: Current authenticated user     document_service: Document service  Returns:     Updated document information
     * Update Document
     */
    async updateDocumentApiV1DocumentsDocumentIdPutRaw(requestParameters: UpdateDocumentApiV1DocumentsDocumentIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentResponse>> {
        if (requestParameters['documentId'] == null) {
            throw new runtime.RequiredError(
                'documentId',
                'Required parameter "documentId" was null or undefined when calling updateDocumentApiV1DocumentsDocumentIdPut().'
            );
        }

        if (requestParameters['documentUpdate'] == null) {
            throw new runtime.RequiredError(
                'documentUpdate',
                'Required parameter "documentUpdate" was null or undefined when calling updateDocumentApiV1DocumentsDocumentIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/documents/{document_id}`;
        urlPath = urlPath.replace(`{${"document_id"}}`, encodeURIComponent(String(requestParameters['documentId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DocumentUpdateToJSON(requestParameters['documentUpdate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentResponseFromJSON(jsonValue));
    }

    /**
     * Update document metadata.  Args:     document_id: Document ID     update_data: Update data     current_user: Current authenticated user     document_service: Document service  Returns:     Updated document information
     * Update Document
     */
    async updateDocumentApiV1DocumentsDocumentIdPut(requestParameters: UpdateDocumentApiV1DocumentsDocumentIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentResponse> {
        const response = await this.updateDocumentApiV1DocumentsDocumentIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a document.  Args:     file: Document file to upload     title: Document title     description: Document description     tags: Document tags (JSON array string)     chunk_size: Text chunk size for processing     chunk_overlap: Text chunk overlap     is_public: Whether document is public     current_user: Current authenticated user     document_service: Document service  Returns:     Created document information
     * Upload Document
     */
    async uploadDocumentApiV1DocumentsUploadPostRaw(requestParameters: UploadDocumentApiV1DocumentsUploadPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DocumentResponse>> {
        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling uploadDocumentApiV1DocumentsUploadPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("CustomHTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['title'] != null) {
            formParams.append('title', requestParameters['title'] as any);
        }

        if (requestParameters['description'] != null) {
            formParams.append('description', requestParameters['description'] as any);
        }

        if (requestParameters['tags'] != null) {
            formParams.append('tags', requestParameters['tags'] as any);
        }

        if (requestParameters['chunkSize'] != null) {
            formParams.append('chunk_size', requestParameters['chunkSize'] as any);
        }

        if (requestParameters['chunkOverlap'] != null) {
            formParams.append('chunk_overlap', requestParameters['chunkOverlap'] as any);
        }

        if (requestParameters['isPublic'] != null) {
            formParams.append('is_public', requestParameters['isPublic'] as any);
        }


        let urlPath = `/api/v1/documents/upload`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DocumentResponseFromJSON(jsonValue));
    }

    /**
     * Upload a document.  Args:     file: Document file to upload     title: Document title     description: Document description     tags: Document tags (JSON array string)     chunk_size: Text chunk size for processing     chunk_overlap: Text chunk overlap     is_public: Whether document is public     current_user: Current authenticated user     document_service: Document service  Returns:     Created document information
     * Upload Document
     */
    async uploadDocumentApiV1DocumentsUploadPost(requestParameters: UploadDocumentApiV1DocumentsUploadPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DocumentResponse> {
        const response = await this.uploadDocumentApiV1DocumentsUploadPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
