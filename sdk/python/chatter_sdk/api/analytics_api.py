
"""
    Chatter API

    Advanced AI Chatbot Backend API Platform

    The version of the OpenAPI document: 0.1.0
    Contact: support@chatter.ai
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from datetime import datetime
from typing import Any

from pydantic import (
    Field,
    StrictFloat,
    StrictInt,
    StrictStr,
    validate_call,
)
from typing import Annotated

from chatter_sdk.api_client import ApiClient, RequestSerialized
from chatter_sdk.api_response import ApiResponse
from chatter_sdk.models.conversation_stats_response import (
    ConversationStatsResponse,
)
from chatter_sdk.models.dashboard_response import DashboardResponse
from chatter_sdk.models.document_analytics_response import (
    DocumentAnalyticsResponse,
)
from chatter_sdk.models.performance_metrics_response import (
    PerformanceMetricsResponse,
)
from chatter_sdk.models.system_analytics_response import (
    SystemAnalyticsResponse,
)
from chatter_sdk.models.usage_metrics_response import (
    UsageMetricsResponse,
)
from chatter_sdk.rest import RESTResponseType


class AnalyticsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    async def export_analytics_api_v1_analytics_export_post(
        self,
        metrics: Annotated[list[StrictStr], Field(description="List of metrics to export")],
        format: Annotated[StrictStr | None, Field(description="Export format (json, csv, xlsx)")] = None,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Export Analytics

        Export analytics reports.  Args:     format: Export format     metrics: List of metrics to export     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Exported analytics report

        :param metrics: List of metrics to export (required)
        :type metrics: List[str]
        :param format: Export format (json, csv, xlsx)
        :type format: str
        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._export_analytics_api_v1_analytics_export_post_serialize(
            metrics=metrics,
            format=format,
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "object",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def export_analytics_api_v1_analytics_export_post_with_http_info(
        self,
        metrics: Annotated[list[StrictStr], Field(description="List of metrics to export")],
        format: Annotated[StrictStr | None, Field(description="Export format (json, csv, xlsx)")] = None,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Export Analytics

        Export analytics reports.  Args:     format: Export format     metrics: List of metrics to export     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Exported analytics report

        :param metrics: List of metrics to export (required)
        :type metrics: List[str]
        :param format: Export format (json, csv, xlsx)
        :type format: str
        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._export_analytics_api_v1_analytics_export_post_serialize(
            metrics=metrics,
            format=format,
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "object",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def export_analytics_api_v1_analytics_export_post_without_preload_content(
        self,
        metrics: Annotated[list[StrictStr], Field(description="List of metrics to export")],
        format: Annotated[StrictStr | None, Field(description="Export format (json, csv, xlsx)")] = None,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Export Analytics

        Export analytics reports.  Args:     format: Export format     metrics: List of metrics to export     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Exported analytics report

        :param metrics: List of metrics to export (required)
        :type metrics: List[str]
        :param format: Export format (json, csv, xlsx)
        :type format: str
        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._export_analytics_api_v1_analytics_export_post_serialize(
            metrics=metrics,
            format=format,
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "object",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _export_analytics_api_v1_analytics_export_post_serialize(
        self,
        metrics,
        format,
        start_date,
        end_date,
        period,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
            "metrics": "multi",
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if format is not None:

            _query_params.append(("format", format))

        if metrics is not None:

            _query_params.append(("metrics", metrics))

        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        "start_date",
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(("start_date", start_date))

        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        "end_date",
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(("end_date", end_date))

        if period is not None:

            _query_params.append(("period", period))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "CustomHTTPBearer"
        ]

        return self.api_client.param_serialize(
            method="POST",
            resource_path="/api/v1/analytics/export",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def get_analytics_health_api_v1_analytics_health_get(
        self,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> dict[str, object]:
        """Get Analytics Health

        Get analytics system health status.  Returns:     Health check results for analytics system

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_analytics_health_api_v1_analytics_health_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "Dict[str, object]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def get_analytics_health_api_v1_analytics_health_get_with_http_info(
        self,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[dict[str, object]]:
        """Get Analytics Health

        Get analytics system health status.  Returns:     Health check results for analytics system

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_analytics_health_api_v1_analytics_health_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "Dict[str, object]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def get_analytics_health_api_v1_analytics_health_get_without_preload_content(
        self,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Analytics Health

        Get analytics system health status.  Returns:     Health check results for analytics system

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_analytics_health_api_v1_analytics_health_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "Dict[str, object]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_analytics_health_api_v1_analytics_health_get_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "CustomHTTPBearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/v1/analytics/health",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def get_analytics_metrics_summary_api_v1_analytics_metrics_summary_get(
        self,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> dict[str, object]:
        """Get Analytics Metrics Summary

        Get summary of key analytics metrics for monitoring.  Returns:     Summary of analytics metrics

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_analytics_metrics_summary_api_v1_analytics_metrics_summary_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "Dict[str, object]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def get_analytics_metrics_summary_api_v1_analytics_metrics_summary_get_with_http_info(
        self,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[dict[str, object]]:
        """Get Analytics Metrics Summary

        Get summary of key analytics metrics for monitoring.  Returns:     Summary of analytics metrics

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_analytics_metrics_summary_api_v1_analytics_metrics_summary_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "Dict[str, object]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def get_analytics_metrics_summary_api_v1_analytics_metrics_summary_get_without_preload_content(
        self,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Analytics Metrics Summary

        Get summary of key analytics metrics for monitoring.  Returns:     Summary of analytics metrics

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_analytics_metrics_summary_api_v1_analytics_metrics_summary_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "Dict[str, object]",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_analytics_metrics_summary_api_v1_analytics_metrics_summary_get_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "CustomHTTPBearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/v1/analytics/metrics/summary",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def get_conversation_stats_api_v1_analytics_conversations_get(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ConversationStatsResponse:
        """Get Conversation Stats

        Get conversation statistics.  Args:     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Conversation statistics

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_conversation_stats_api_v1_analytics_conversations_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "ConversationStatsResponse",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def get_conversation_stats_api_v1_analytics_conversations_get_with_http_info(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ConversationStatsResponse]:
        """Get Conversation Stats

        Get conversation statistics.  Args:     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Conversation statistics

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_conversation_stats_api_v1_analytics_conversations_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "ConversationStatsResponse",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def get_conversation_stats_api_v1_analytics_conversations_get_without_preload_content(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Conversation Stats

        Get conversation statistics.  Args:     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Conversation statistics

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_conversation_stats_api_v1_analytics_conversations_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "ConversationStatsResponse",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_conversation_stats_api_v1_analytics_conversations_get_serialize(
        self,
        start_date,
        end_date,
        period,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        "start_date",
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(("start_date", start_date))

        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        "end_date",
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(("end_date", end_date))

        if period is not None:

            _query_params.append(("period", period))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "CustomHTTPBearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/v1/analytics/conversations",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def get_dashboard_api_v1_analytics_dashboard_get(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DashboardResponse:
        """Get Dashboard

        Get comprehensive dashboard data.  Args:     request: Dashboard request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Complete dashboard data

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_dashboard_api_v1_analytics_dashboard_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "DashboardResponse",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def get_dashboard_api_v1_analytics_dashboard_get_with_http_info(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DashboardResponse]:
        """Get Dashboard

        Get comprehensive dashboard data.  Args:     request: Dashboard request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Complete dashboard data

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_dashboard_api_v1_analytics_dashboard_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "DashboardResponse",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def get_dashboard_api_v1_analytics_dashboard_get_without_preload_content(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Dashboard

        Get comprehensive dashboard data.  Args:     request: Dashboard request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Complete dashboard data

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_dashboard_api_v1_analytics_dashboard_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "DashboardResponse",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_dashboard_api_v1_analytics_dashboard_get_serialize(
        self,
        start_date,
        end_date,
        period,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        "start_date",
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(("start_date", start_date))

        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        "end_date",
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(("end_date", end_date))

        if period is not None:

            _query_params.append(("period", period))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "CustomHTTPBearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/v1/analytics/dashboard",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def get_document_analytics_api_v1_analytics_documents_get(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> DocumentAnalyticsResponse:
        """Get Document Analytics

        Get document analytics.  Args:     request: Document analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Document analytics

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_document_analytics_api_v1_analytics_documents_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "DocumentAnalyticsResponse",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def get_document_analytics_api_v1_analytics_documents_get_with_http_info(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[DocumentAnalyticsResponse]:
        """Get Document Analytics

        Get document analytics.  Args:     request: Document analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Document analytics

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_document_analytics_api_v1_analytics_documents_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "DocumentAnalyticsResponse",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def get_document_analytics_api_v1_analytics_documents_get_without_preload_content(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Document Analytics

        Get document analytics.  Args:     request: Document analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Document analytics

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_document_analytics_api_v1_analytics_documents_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "DocumentAnalyticsResponse",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_document_analytics_api_v1_analytics_documents_get_serialize(
        self,
        start_date,
        end_date,
        period,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        "start_date",
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(("start_date", start_date))

        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        "end_date",
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(("end_date", end_date))

        if period is not None:

            _query_params.append(("period", period))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "CustomHTTPBearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/v1/analytics/documents",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def get_performance_metrics_api_v1_analytics_performance_get(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PerformanceMetricsResponse:
        """Get Performance Metrics

        Get performance metrics.  Args:     request: Performance metrics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Performance metrics

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_performance_metrics_api_v1_analytics_performance_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "PerformanceMetricsResponse",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def get_performance_metrics_api_v1_analytics_performance_get_with_http_info(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PerformanceMetricsResponse]:
        """Get Performance Metrics

        Get performance metrics.  Args:     request: Performance metrics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Performance metrics

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_performance_metrics_api_v1_analytics_performance_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "PerformanceMetricsResponse",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def get_performance_metrics_api_v1_analytics_performance_get_without_preload_content(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Performance Metrics

        Get performance metrics.  Args:     request: Performance metrics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Performance metrics

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_performance_metrics_api_v1_analytics_performance_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "PerformanceMetricsResponse",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_performance_metrics_api_v1_analytics_performance_get_serialize(
        self,
        start_date,
        end_date,
        period,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        "start_date",
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(("start_date", start_date))

        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        "end_date",
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(("end_date", end_date))

        if period is not None:

            _query_params.append(("period", period))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "CustomHTTPBearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/v1/analytics/performance",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def get_system_analytics_api_v1_analytics_system_get(
        self,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SystemAnalyticsResponse:
        """Get System Analytics

        Get system analytics.  Args:     request: System analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     System analytics

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_system_analytics_api_v1_analytics_system_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "SystemAnalyticsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def get_system_analytics_api_v1_analytics_system_get_with_http_info(
        self,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SystemAnalyticsResponse]:
        """Get System Analytics

        Get system analytics.  Args:     request: System analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     System analytics

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_system_analytics_api_v1_analytics_system_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "SystemAnalyticsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def get_system_analytics_api_v1_analytics_system_get_without_preload_content(
        self,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get System Analytics

        Get system analytics.  Args:     request: System analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     System analytics

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_system_analytics_api_v1_analytics_system_get_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "SystemAnalyticsResponse",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_system_analytics_api_v1_analytics_system_get_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "CustomHTTPBearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/v1/analytics/system",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def get_tool_server_analytics_api_v1_analytics_toolservers_get(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> dict[str, object]:
        """Get Tool Server Analytics

        Get tool server analytics.  Args:     request: Tool server analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Tool server analytics data

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tool_server_analytics_api_v1_analytics_toolservers_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "Dict[str, object]",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def get_tool_server_analytics_api_v1_analytics_toolservers_get_with_http_info(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[dict[str, object]]:
        """Get Tool Server Analytics

        Get tool server analytics.  Args:     request: Tool server analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Tool server analytics data

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tool_server_analytics_api_v1_analytics_toolservers_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "Dict[str, object]",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def get_tool_server_analytics_api_v1_analytics_toolservers_get_without_preload_content(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Tool Server Analytics

        Get tool server analytics.  Args:     request: Tool server analytics request parameters     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Tool server analytics data

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tool_server_analytics_api_v1_analytics_toolservers_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "Dict[str, object]",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_tool_server_analytics_api_v1_analytics_toolservers_get_serialize(
        self,
        start_date,
        end_date,
        period,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        "start_date",
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(("start_date", start_date))

        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        "end_date",
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(("end_date", end_date))

        if period is not None:

            _query_params.append(("period", period))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "CustomHTTPBearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/v1/analytics/toolservers",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def get_usage_metrics_api_v1_analytics_usage_get(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UsageMetricsResponse:
        """Get Usage Metrics

        Get usage metrics.  Args:     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Usage metrics

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_usage_metrics_api_v1_analytics_usage_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "UsageMetricsResponse",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def get_usage_metrics_api_v1_analytics_usage_get_with_http_info(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UsageMetricsResponse]:
        """Get Usage Metrics

        Get usage metrics.  Args:     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Usage metrics

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_usage_metrics_api_v1_analytics_usage_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "UsageMetricsResponse",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def get_usage_metrics_api_v1_analytics_usage_get_without_preload_content(
        self,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Usage Metrics

        Get usage metrics.  Args:     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     Usage metrics

        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_usage_metrics_api_v1_analytics_usage_get_serialize(
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "UsageMetricsResponse",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_usage_metrics_api_v1_analytics_usage_get_serialize(
        self,
        start_date,
        end_date,
        period,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        # process the query parameters
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        "start_date",
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(("start_date", start_date))

        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        "end_date",
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(("end_date", end_date))

        if period is not None:

            _query_params.append(("period", period))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "CustomHTTPBearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/v1/analytics/usage",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    async def get_user_analytics_api_v1_analytics_users_user_id_get(
        self,
        user_id: StrictStr,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> dict[str, object]:
        """Get User Analytics

        Get per-user analytics.  Args:     user_id: User ID     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     User-specific analytics

        :param user_id: (required)
        :type user_id: str
        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_analytics_api_v1_analytics_users_user_id_get_serialize(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "Dict[str, object]",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    async def get_user_analytics_api_v1_analytics_users_user_id_get_with_http_info(
        self,
        user_id: StrictStr,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[dict[str, object]]:
        """Get User Analytics

        Get per-user analytics.  Args:     user_id: User ID     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     User-specific analytics

        :param user_id: (required)
        :type user_id: str
        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_analytics_api_v1_analytics_users_user_id_get_serialize(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "Dict[str, object]",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        await response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    async def get_user_analytics_api_v1_analytics_users_user_id_get_without_preload_content(
        self,
        user_id: StrictStr,
        start_date: Annotated[datetime | None, Field(description="Start date for analytics")] = None,
        end_date: Annotated[datetime | None, Field(description="End date for analytics")] = None,
        period: Annotated[StrictStr | None, Field(description="Predefined period (1h, 24h, 7d, 30d, 90d)")] = None,
        _request_timeout: None | Annotated[StrictFloat, Field(gt=0)] | tuple[Annotated[StrictFloat, Field(gt=0)], Annotated[StrictFloat, Field(gt=0)]] = None,
        _request_auth: dict[StrictStr, Any] | None = None,
        _content_type: StrictStr | None = None,
        _headers: dict[StrictStr, Any] | None = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get User Analytics

        Get per-user analytics.  Args:     user_id: User ID     start_date: Start date for analytics     end_date: End date for analytics     period: Predefined period     current_user: Current authenticated user     analytics_service: Analytics service  Returns:     User-specific analytics

        :param user_id: (required)
        :type user_id: str
        :param start_date: Start date for analytics
        :type start_date: datetime
        :param end_date: End date for analytics
        :type end_date: datetime
        :param period: Predefined period (1h, 24h, 7d, 30d, 90d)
        :type period: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_analytics_api_v1_analytics_users_user_id_get_serialize(
            user_id=user_id,
            start_date=start_date,
            end_date=end_date,
            period=period,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: dict[str, str | None] = {
            "200": "Dict[str, object]",
            "422": "HTTPValidationError",
        }
        response_data = await self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_user_analytics_api_v1_analytics_users_user_id_get_serialize(
        self,
        user_id,
        start_date,
        end_date,
        period,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: dict[str, str] = {
        }

        _path_params: dict[str, str] = {}
        _query_params: list[tuple[str, str]] = []
        _header_params: dict[str, str | None] = _headers or {}
        _form_params: list[tuple[str, str]] = []
        _files: dict[
            str, str | bytes | list[str] | list[bytes] | list[tuple[str, bytes]]
        ] = {}
        _body_params: bytes | None = None

        # process the path parameters
        if user_id is not None:
            _path_params["user_id"] = user_id
        # process the query parameters
        if start_date is not None:
            if isinstance(start_date, datetime):
                _query_params.append(
                    (
                        "start_date",
                        start_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(("start_date", start_date))

        if end_date is not None:
            if isinstance(end_date, datetime):
                _query_params.append(
                    (
                        "end_date",
                        end_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(("end_date", end_date))

        if period is not None:

            _query_params.append(("period", period))

        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if "Accept" not in _header_params:
            _header_params["Accept"] = self.api_client.select_header_accept(
                [
                    "application/json"
                ]
            )


        # authentication setting
        _auth_settings: list[str] = [
            "CustomHTTPBearer"
        ]

        return self.api_client.param_serialize(
            method="GET",
            resource_path="/api/v1/analytics/users/{user_id}",
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


