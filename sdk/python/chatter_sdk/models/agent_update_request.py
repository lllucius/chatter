
"""
    Chatter API

    Advanced AI Chatbot Backend API Platform

    The version of the OpenAPI document: 0.1.0
    Contact: support@chatter.ai
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictStr
from typing import Any, ClassVar
from typing import Annotated
from chatter_sdk.models.agent_capability import AgentCapability
from chatter_sdk.models.agent_status import AgentStatus
from typing import Self

class AgentUpdateRequest(BaseModel):
    """
    Request schema for updating an agent.
    """ # noqa: E501
    name: StrictStr | None = None
    description: StrictStr | None = None
    system_prompt: StrictStr | None = None
    status: AgentStatus | None = None
    personality_traits: list[StrictStr] | None = None
    knowledge_domains: list[StrictStr] | None = None
    response_style: StrictStr | None = None
    capabilities: list[AgentCapability] | None = None
    available_tools: list[StrictStr] | None = None
    primary_llm: StrictStr | None = None
    fallback_llm: StrictStr | None = None
    temperature: Annotated[float, Field(le=2.0, strict=True, ge=0.0)] | Annotated[int, Field(le=2, strict=True, ge=0)] | None = None
    max_tokens: Annotated[int, Field(le=32000, strict=True, ge=1)] | None = None
    max_conversation_length: Annotated[int, Field(le=1000, strict=True, ge=1)] | None = None
    context_window_size: Annotated[int, Field(le=32000, strict=True, ge=100)] | None = None
    response_timeout: Annotated[int, Field(le=300, strict=True, ge=1)] | None = None
    learning_enabled: StrictBool | None = None
    feedback_weight: Annotated[float, Field(le=1.0, strict=True, ge=0.0)] | Annotated[int, Field(le=1, strict=True, ge=0)] | None = None
    adaptation_threshold: Annotated[float, Field(le=1.0, strict=True, ge=0.0)] | Annotated[int, Field(le=1, strict=True, ge=0)] | None = None
    tags: list[StrictStr] | None = None
    metadata: dict[str, Any] | None = None
    __properties: ClassVar[list[str]] = ["name", "description", "system_prompt", "status", "personality_traits", "knowledge_domains", "response_style", "capabilities", "available_tools", "primary_llm", "fallback_llm", "temperature", "max_tokens", "max_conversation_length", "context_window_size", "response_timeout", "learning_enabled", "feedback_weight", "adaptation_threshold", "tags", "metadata"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Self | None:
        """Create an instance of AgentUpdateRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: set[str] = set()

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if name (nullable) is None
        # and model_fields_set contains the field
        if self.name is None and "name" in self.model_fields_set:
            _dict['name'] = None

        # set to None if description (nullable) is None
        # and model_fields_set contains the field
        if self.description is None and "description" in self.model_fields_set:
            _dict['description'] = None

        # set to None if system_prompt (nullable) is None
        # and model_fields_set contains the field
        if self.system_prompt is None and "system_prompt" in self.model_fields_set:
            _dict['system_prompt'] = None

        # set to None if status (nullable) is None
        # and model_fields_set contains the field
        if self.status is None and "status" in self.model_fields_set:
            _dict['status'] = None

        # set to None if personality_traits (nullable) is None
        # and model_fields_set contains the field
        if self.personality_traits is None and "personality_traits" in self.model_fields_set:
            _dict['personality_traits'] = None

        # set to None if knowledge_domains (nullable) is None
        # and model_fields_set contains the field
        if self.knowledge_domains is None and "knowledge_domains" in self.model_fields_set:
            _dict['knowledge_domains'] = None

        # set to None if response_style (nullable) is None
        # and model_fields_set contains the field
        if self.response_style is None and "response_style" in self.model_fields_set:
            _dict['response_style'] = None

        # set to None if capabilities (nullable) is None
        # and model_fields_set contains the field
        if self.capabilities is None and "capabilities" in self.model_fields_set:
            _dict['capabilities'] = None

        # set to None if available_tools (nullable) is None
        # and model_fields_set contains the field
        if self.available_tools is None and "available_tools" in self.model_fields_set:
            _dict['available_tools'] = None

        # set to None if primary_llm (nullable) is None
        # and model_fields_set contains the field
        if self.primary_llm is None and "primary_llm" in self.model_fields_set:
            _dict['primary_llm'] = None

        # set to None if fallback_llm (nullable) is None
        # and model_fields_set contains the field
        if self.fallback_llm is None and "fallback_llm" in self.model_fields_set:
            _dict['fallback_llm'] = None

        # set to None if temperature (nullable) is None
        # and model_fields_set contains the field
        if self.temperature is None and "temperature" in self.model_fields_set:
            _dict['temperature'] = None

        # set to None if max_tokens (nullable) is None
        # and model_fields_set contains the field
        if self.max_tokens is None and "max_tokens" in self.model_fields_set:
            _dict['max_tokens'] = None

        # set to None if max_conversation_length (nullable) is None
        # and model_fields_set contains the field
        if self.max_conversation_length is None and "max_conversation_length" in self.model_fields_set:
            _dict['max_conversation_length'] = None

        # set to None if context_window_size (nullable) is None
        # and model_fields_set contains the field
        if self.context_window_size is None and "context_window_size" in self.model_fields_set:
            _dict['context_window_size'] = None

        # set to None if response_timeout (nullable) is None
        # and model_fields_set contains the field
        if self.response_timeout is None and "response_timeout" in self.model_fields_set:
            _dict['response_timeout'] = None

        # set to None if learning_enabled (nullable) is None
        # and model_fields_set contains the field
        if self.learning_enabled is None and "learning_enabled" in self.model_fields_set:
            _dict['learning_enabled'] = None

        # set to None if feedback_weight (nullable) is None
        # and model_fields_set contains the field
        if self.feedback_weight is None and "feedback_weight" in self.model_fields_set:
            _dict['feedback_weight'] = None

        # set to None if adaptation_threshold (nullable) is None
        # and model_fields_set contains the field
        if self.adaptation_threshold is None and "adaptation_threshold" in self.model_fields_set:
            _dict['adaptation_threshold'] = None

        # set to None if tags (nullable) is None
        # and model_fields_set contains the field
        if self.tags is None and "tags" in self.model_fields_set:
            _dict['tags'] = None

        # set to None if metadata (nullable) is None
        # and model_fields_set contains the field
        if self.metadata is None and "metadata" in self.model_fields_set:
            _dict['metadata'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict[str, Any] | None) -> Self | None:
        """Create an instance of AgentUpdateRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "name": obj.get("name"),
            "description": obj.get("description"),
            "system_prompt": obj.get("system_prompt"),
            "status": obj.get("status"),
            "personality_traits": obj.get("personality_traits"),
            "knowledge_domains": obj.get("knowledge_domains"),
            "response_style": obj.get("response_style"),
            "capabilities": obj.get("capabilities"),
            "available_tools": obj.get("available_tools"),
            "primary_llm": obj.get("primary_llm"),
            "fallback_llm": obj.get("fallback_llm"),
            "temperature": obj.get("temperature"),
            "max_tokens": obj.get("max_tokens"),
            "max_conversation_length": obj.get("max_conversation_length"),
            "context_window_size": obj.get("context_window_size"),
            "response_timeout": obj.get("response_timeout"),
            "learning_enabled": obj.get("learning_enabled"),
            "feedback_weight": obj.get("feedback_weight"),
            "adaptation_threshold": obj.get("adaptation_threshold"),
            "tags": obj.get("tags"),
            "metadata": obj.get("metadata")
        })
        return _obj


